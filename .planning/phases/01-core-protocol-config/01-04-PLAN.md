---
phase: 01-core-protocol-config
plan: 04
type: execute
wave: 4
depends_on: ["01-01", "01-02", "01-03"]
files_modified: [src/cli/mod.rs, src/cli/commands.rs, src/main.rs]
autonomous: true

must_haves:
  truths:
    - "User can list all configured servers and their tools"
    - "User can inspect server details (DISC-02)"
    - "User can inspect tool details including JSON Schema (DISC-03)"
    - "User can execute tools with JSON arguments (EXEC-01, EXEC-02)"
    - "User can search tools using glob patterns (DISC-04)"
    - "Ambiguous commands prompt user with suggestions (ERR-06)"
    - "Context-aware error messages guide recovery (ERR-02)"
  artifacts:
    - path: "src/cli/mod.rs"
      provides: "CLI command definitions"
      min_lines: 80
    - path: "src/cli/commands.rs"
      provides: "Command implementation functions"
      min_lines: 150
    - path: "src/main.rs"
      provides: "CLI entry point and routing"
      min_lines: 60
  key_links:
    - from: "src/main.rs"
      to: "src/cli/commands.rs"
      via: "command handler functions"
      pattern: "cli::"
    - from: "src/cli/commands.rs"
      to: "src/client/mod.rs"
      via: "McpClient for tool operations"
      pattern: "client::"
    - from: "src/cli/commands.rs"
      to: "src/config/"
      via: "Config loading"
      pattern: "config::"
---

<objective>
Implement CLI commands for server discovery, tool inspection, and tool execution using MCP client.

Purpose: Enable users to discover available tools, inspect schemas, and execute tools via command-line interface with helpful error messages.
Output: Fully functional CLI that lists servers, inspects tools, and executes tool calls with JSON arguments.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-core-protocol-config/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CLI command handlers</name>
  <files>src/cli/commands.rs</files>
  <action>
  Create src/cli/commands.rs with async command handler functions.

  Create AppContext struct:
  ```rust
  pub struct AppContext {
      pub config: crate::config::Config,
  }
  ```

  Implement cmd_list_servers(ctx, with_descriptions) (DISC-01, DISC-02):
  - Get servers from config
  - For each server:
    - Connect using appropriate transport (via client module)
    - List tools using McpClient::list_tools()
    - Display: server name, transport type, tool count
    - If with_descriptions flag: show tool descriptions (DISC-06)
  - Format output for readability (plain text or table)
  - Handle connection failures gracefully (continue with other servers)
  - Return error if no servers configured

  Implement cmd_server_info(ctx, server_name) (DISC-02):
  - Get server from config
  - Display: name, transport type, connection details
  - If stdio: show command, args, working directory
  - If http: show URL, headers
  - Display server description if present
  - Return McpError::ServerNotFound if server doesn't exist (ERR-02)

  Implement cmd_tool_info(ctx, tool_id) (DISC-03, CLI-05):
  - Parse tool_id (supports "server/tool" and "server tool" formats - CLI-05)
  - Identify server and tool name
  - Get server from config
  - Connect and list tools
  - Find tool by name
  - Display: tool name, description, input JSON Schema
  - Return McpError::ToolNotFound if tool doesn't exist (ERR-02)
  - Return McpError::AmbiguousCommand if tool_id format unclear (ERR-06)

  Implement cmd_call_tool(ctx, tool_id, args) (EXEC-01, EXEC-02, EXEC-04, EXEC-06):
  - Parse tool_id (supports both formats - CLI-05)
  - Parse args JSON string (or read from stdin if TTY not present - EXEC-02)
  - Validate JSON (EXEC-04)
  - Build JSON-RPC request for "tools/call"
  - Execute via McpClient.call_tool() (implement this in client/mod.rs)
  - Format result to extract text content (EXEC-03)
  - Display formatted output
  - Handle errors with context (ERR-02)
  - Apply timeout (EXEC-06)

  Implement cmd_search_tools(ctx, pattern) (DISC-04):
  - Parse glob pattern from pattern argument
  - Use glob crate for wildcard matching (*, ?)
  - For each server:
    - Connect and list tools
    - Match tool names against pattern
    - Display matching tools: server/tool, description
  - Return empty list if no matches
  - Handle glob pattern errors gracefully

  Implement parse_tool_id(tool_id) helper (CLI-05, ERR-06):
  - Try parsing "server/tool" format (slash-separated)
  - Try parsing "server tool" format (space-separated)
  - If ambiguous, return McpError::AmbiguousCommand with hint (ERR-06)
  - Return (server_name, tool_name) tuple

  Implement read_stdin_async() helper (EXEC-02):
  - Use tokio::io::stdin to read from stdin
  - Return error if stdin is not readable
  - Support piping: echo '{"arg":1}' | mcp call tool

  Output formatting (EXEC-03):
  - Extract text content from tool result
  - Format JSON result as readable text
  - Handle different result types: text, image, resource
  </action>
  <verify>cargo check</verify>
  <done>All command handler functions compile</done>
</task>

<task type="auto">
  <name>Task 2: Implement CLI command definitions and routing</name>
  <files>src/cli/mod.rs, src/main.rs</files>
  <action>
  Update src/cli/mod.rs to export command handlers:
  - pub mod commands;

  Update src/main.rs:
  - Import: use mcp_cli_rs::cli::commands::*;
  - Update run() function to call command handlers instead of placeholders
  - For Commands::List: call cmd_list_servers(ctx, with_descriptions)
  - For Commands::Info: call cmd_server_info(ctx, name)
  - For Commands::Tool: call cmd_tool_info(ctx, tool)
  - For Commands::Call: call cmd_call_tool(ctx, tool, args)
  - For Commands::Search: call cmd_search_tools(ctx, pattern)
  - For None (default): call cmd_list_servers(ctx, false) to list all servers

  Update AppsContext creation in run():
  - Load config using config::loader::find_and_load(cli.config.as_path()).await
  - Create AppContext { config }

  Error handling improvements (ERR-02):
  - For ServerNotFound: suggest available servers
  - For ToolNotFound: suggest available tools from that server
  - For InvalidJson: show parse error with line number
  - For ConnectionError: show server name and transport details
  - For AmbiguousCommand: show hint (ERR-06)

  Add glob dependency to Cargo.toml:
  - glob = "0.3" (for DISC-04 pattern matching)

  Update src/main.rs to handle stdin detection (EXEC-02):
  - If args is None but tool is provided, check if stdin is readable
  - If stdin is TTY, prompt for interactive input or show error
  - If stdin is not TTY (piped content), read from stdin
  </action>
  <verify>cargo check and cargo run -- --help</verify>
  <done>CLI routing and command execution work</done>
</task>

<task type="auto">
  <name>Task 3: Implement tool execution in MCP client</name>
  <files>src/client/mod.rs</files>
  <action>
  Complete McpClient::call_tool() method (EXEC-01):

  Add ToolCallRequest struct:
  - name: String
  - arguments: Value (JSON object)

  Implement call_tool(tool_name, args) async method:
  - Build JSON-RPC request:
    - method: "tools/call"
    - params: { name, arguments }
  - Send via transport.send()
  - Parse response:
    - Extract result content
    - Return ToolResult struct
  - Handle errors with context

  Add ToolResult struct:
  - content: Vec<ContentItem>
  - isError: bool

  Add ContentItem enum:
  - Text { text: String }
  - Image { data: String, mime_type: String }
  - Resource { uri: String, mime_type: Option<String> }

  Add format_content() helper (EXEC-03):
  - Extract text from ContentItem::Text
  - Handle resource URIs
  - Display error if isError is true
  - Format for CLI output (not pretty-printed JSON)

  Apply timeout using tokio::time::timeout (EXEC-06):
  - Default timeout: 1800 seconds (from ROADMAP.md)
  - Return McpError::Timeout if timeout exceeded

  Error handling:
  - McpError::ToolNotFound if server returns tool not found
  - McpError::InvalidProtocol for malformed response
  - include server_name and tool_name in error context (ERR-02)
  </action>
  <verify>cargo check</verify>
  <done>Tool execution with formatted results works</done>
</task>

<task type="auto">
  <name>Task 4: Add config client conversion function</name>
  <files>src/config/mod.rs</files>
  <action>
  Add conversion function in src/config/mod.rs to create transports from config:

  Implement ServerConfig::to_transport() async method:
  - Takes server_name and self (ServerConfig)
  - Matches transport enum:
    - Stdio: create StdioTransport with command, args, env, cwd
    - Http: create HttpTransport with url, headers
  - Returns Result<Box<dyn Transport>, McpError>

  This function bridges config parsing and client connection.
  </action>
  <verify>cargo check</verify>
  <done>Config can be converted to transport objects</done>
</task>

</tasks>

<verification>
1. cargo check passes
2. mcp list displays all configured servers and tools (DISC-01)
3. mcp info <server> shows server details (DISC-02)
4. mcp tool <server>/<tool> shows tool schema (DISC-03)
5. mcp call <server>/<tool> '{"arg":1}' executes tool (EXEC-01)
6. echo '{"arg":1}' | mcp call <server>/<tool> reads from stdin (EXEC-02)
7. mcp search '*' finds all tools (DISC-04)
8. Error messages suggestAvailable servers/tools (ERR-02)
9. Ambiguous tool identifiers show helpful hints (ERR-06)
10. Tool results formatted as text, not JSON (EXEC-03)
</verification>

<success_criteria>
- Users can list all configured servers and discover tools (DISC-01)
- Users can inspect server details including transport info (DISC-02)
- Users can inspect tool details including JSON Schema (DISC-03)
- Users can search tools using glob patterns (*, ?) (DISC-04)
- Users can execute tools with inline JSON arguments (EXEC-01)
- Users can execute tools with piped stdin input (EXEC-02)
- Tool results formatted as readable text (EXEC-03)
- JSON arguments validated with clear error messages (EXEC-04)
- Tool execution respects timeout (EXEC-06)
- Context-aware error messages suggest alternatives (ERR-02)
- Ambiguous commands prompt with suggestions (ERR-06)
- Supports both "server/tool" and "server tool" formats (CLI-05)
- --with-descriptions flag shows tool descriptions (DISC-06)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-protocol-config/01-04-SUMMARY.md`
</output>
