---
phase: 01-core-protocol-config
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified: [src/client/mod.rs, src/client/transport.rs, src/client/stdio.rs, src/client/http.rs]
autonomous: true

must_haves:
  truths:
    - "Transport trait provides abstraction for stdio and HTTP"
    - "Stdio transport spawns processes with kill_on_drop (CONN-04)"
    - "Stdio transport uses newline-delimited JSON messages (XP-03)"
    - "HTTP transport communicates via reqwest client"
    - "Client can connect to servers and list tools"
  artifacts:
    - path: "src/client/transport.rs"
      provides: "Transport trait abstraction"
      min_lines: 40
    - path: "src/client/stdio.rs"
      provides: "StdioTransport implementation"
      min_lines: 120
    - path: "src/client/http.rs"
      provides: "HttpTransport implementation"
      min_lines: 80
    - path: "src/client/mod.rs"
      provides: "MCP client and protocol handling"
      min_lines: 100
  key_links:
    - from: "src/client/transport.rs"
      to: "src/error.rs"
      via: "McpError for connection failures"
      pattern: "McpError::Connection"
    - from: "src/client/stdio.rs"
      to: "src/client/transport.rs"
      via: "Transport trait implementation"
      pattern: "impl Transport for StdioTransport"
    - from: "src/client/http.rs"
      to: "src/client/transport.rs"
      via: "Transport trait implementation"
      pattern: "impl Transport for HttpTransport"
---

<objective>
Implement MCP protocol and transport abstractions for stdio and HTTP communication.

Purpose: Enable Rust CLI to communicate with MCP servers via stdio (process spawning) and HTTP transports, with proper Windows process cleanup and MCP protocol compliance.
Output: Working MCP client that can connect to servers and list their available tools.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-core-protocol-config/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create transport abstraction trait</name>
  <files>src/client/transport.rs</files>
  <action>
  Create src/client/transport.rs with Transport trait.

  Create Transport trait (ARCHITECTURE.md Pattern 1):
  ```rust
  use async_trait::async_trait;
  use serde_json::Value;

  #[async_trait]
  pub trait Transport: Send + Sync {
      /// Send JSON-RPC request and get response
      async fn send(&mut self, request: Value) -> Result<Value, crate::error::McpError>;

      /// Check if connection is healthy (for Phase 2 daemon health checks)
      async fn ping(&self) -> Result<(), crate::error::McpError>;

      /// Get transport type for debugging
      fn transport_type(&self) -> &str;
  }
  ```

  Add async-trait dependency to Cargo.toml:
  - async-trait = "0.1"

  Key points:
  - Trait-based abstraction enables stdio/HTTP switching without code changes
  - async-trait enables async trait methods
  - Uses serde_json::Value for flexible JSON-RPC messages
  </action>
  <verify>cargo check</verify>
  <done>Transport trait compiles with async methods</done>
</task>

<task type="auto">
  <name>Task 2: Implement StdioTransport</name>
  <files>src/client/stdio.rs</files>
  <action>
  Create src/client/stdio.rs implementing stdio transport.

  Create StdioTransport struct (CONN-01, CONN-04):
  ```rust
  use tokio::process::{Child, ChildStdin, ChildStdout};
  use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};

  pub struct StdioTransport {
      child: Child,
      stdin: ChildStdin,
      stdout: BufReader<ChildStdout>,
  }
  ```

  Implement StdioTransport::new(command, args, env, cwd):
  - Use tokio::process::Command::new(program).args(args).spawn()
  - Set kill_on_drop(true) to prevent Windows zombie processes (PITFALLS.md - CONN-04)
  - Set stdin, stdout to piped
  - Apply env variables and cwd if provided
  - Extract stdin and stdout handles
  - Wrap stdout in BufReader for line-by-line reading

  Implement Transport trait for StdioTransport:
  - send() method:
    - Serialize request to JSON
    - Write to stdin using writeln! with newline delimiter (PITFALLS.md - XP-03)
    - Flush stdin
    - Read response from stdout (read_line for newline-delimited JSON)
    - Parse JSON response
    - Return error on timeout (CONN-03)
  - ping() method:
    - Send minimal JSON-RPC request with id="ping"
    - Expect response
    - Return error if no response
  - transport_type() returns "stdio"

  MCP Protocol (XP-03):
  - JSON-RPC 2.0 format: {"jsonrpc":"2.0","method":...,"id":...}
  - Messages MUST be newline-delimited (use writeln! not write!)
  - NO embedded newlines in JSON (use \n escapes if needed)
  - Read one line per response (read_line)

  Error handling:
  - McpError::ConnectionError for spawn failures
  - McpError::InvalidProtocol for malformed JSON
  - McpError::Timeout for read timeouts
  </action>
  <verify>cargo check</verify>
  <done>StdioTransport compiles with kill_on_drop and newline handling</done>
</task>

<task type="auto">
  <name>Task 3: Implement HttpTransport</name>
  <files>src/client/http.rs</files>
  <action>
  Create src/client/http.rs implementing HTTP transport.

  Create HttpTransport struct (CONN-02):
  ```rust
  use reqwest::Client;

  pub struct HttpTransport {
      client: Client,
      base_url: String,
      headers: std::collections::HashMap<String, String>,
  }
  ```

  Implement HttpTransport::new(url, headers):
  - Create reqwest::Client
  - Store base_url and headers
  - Parse and validate URL

  Implement Transport trait for HttpTransport:
  - send() method:
    - Serialize request to JSON
    - POST to base_url with JSON body
    - Apply headers to request
    - Parse response JSON
    - Handle HTTP 4xx/5xx errors as connection errors (CONN-03)
  - ping() method:
    - Send minimal GET or POST request
    - Expect HTTP 200 OK
    - Return error on non-200 response or timeout
  - transport_type() returns "http"

  Error handling:
  - Use reqwest::Error for network failures
  - McpError::ConnectionError for HTTP 4xx/5xx
  - McpError::Timeout for request timeouts
  </action>
  <verify>cargo check</verify>
  <done>HttpTransport compiles with reqwest client</done>
</task>

<task type="auto">
  <name>Task 4: Create MCP client with tool listing</name>
  <files>src/client/mod.rs</files>
  <action>
  Create src/client/mod.rs with MCP client and protocol handling.

  Create McpClient struct with:
  - transport: Box<dyn Transport>
  - server_name: String

  Implement McpClient::new(server_name, transport):
  - Store transport and server name

  Implement list_tools() async method (DISC-01):
  - Build JSON-RPC request:
    - method: "tools/list"
    - id: generate unique ID (timestamp or counter)
    - params: {}
  - Send via transport.send()
  - Parse response:
    - Extract result.tools array
    - Return vector of ToolInfo structs
  - Handle errors with context

  Create ToolInfo struct:
  - name: String
  - description: Option<String>
  - input_schema: Value (JSON Schema for tool parameters, DISC-03)

  Implement json_rpc_request(method, params) helper:
  - Build JSON-RPC 2.0 request:
    - jsonrpc: "2.0"
    - method (String)
    - params (Value, default {})
    - id (u64 or string)

  Implement call_tool() stub method (for Plan 04):
  - Build JSON-RPC request for "tools/call"
  - Return error for now (TODO in Plan 04)

  Update src/config/mod.rs to add convert_to_transport() method on ServerTransport:
  - Convert stdio config to StdioTransport
  - Convert http config to HttpTransport
  - Return Box<dyn Transport>

  Error handling:
  - McpError::InvalidProtocol for malformed JSON-RPC responses
  - Include server_name in error context

  Note: Using tokio + serde_json directly instead of mcp-sdk (RESEARCH.md gap - mcp-sdk 0.0.3 has minimal docs)
  </action>
  <verify>cargo check</verify>
  <done>McpClient can connect and list tools</done>
</task>

</tasks>

<verification>
1. cargo check passes on all client modules
2. Transport trait implemented for both stdio and HTTP
3. StdioTransport uses kill_on_drop(true)
4. StdioTransport useswriteln! for messages (newline-delimited)
5. McpClient.list_tools() works with both transports
</verification>

<success_criteria>
- Transport abstraction trait enables stdio/HTTP switching
- StdioTransport spawns processes with kill_on_drop (CONN-04)
- StdioTransport uses newline-delimited JSON messages (XP-03)
- HttpTransport uses reqwest client for HTTP communication
- McpClient can connect to servers and list tools (DISC-01)
- Error handling covers connection failures, protocol errors, timeouts
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-protocol-config/01-03-SUMMARY.md`
</output>
