---
phase: 01-core-protocol-config
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [Cargo.toml, src/main.rs, src/error.rs, src/lib.rs]
autonomous: true

must_haves:
  truths:
    - "Project compiles with all dependencies"
    - "Error types cover all expected failure modes"
    - "CLI entry point can parse basic arguments"
    - "Library exports are defined for reuse"
  artifacts:
    - path: "Cargo.toml"
      provides: "Project dependencies and configuration"
      contains: "[dependencies]", "clap", "tokio", "serde", "thiserror", "anyhow"
    - path: "src/error.rs"
      provides: "Domain-specific error types"
      min_lines: 80
    - path: "src/main.rs"
      provides: "CLI entry point"
      min_lines: 30
    - path: "src/lib.rs"
      provides: "Library exports"
      min_lines: 10
  key_links:
    - from: "Cargo.toml"
      to: "src/error.rs"
      via: "thiserror dependency"
      pattern: "thiserror"
    - from: "src/main.rs"
      to: "src/error.rs"
      via: "error type imports"
      pattern: "use.*error"
---

<objective>
Initialize Rust project with MCP protocol dependencies and establish error handling foundation.

Purpose: Create buildable project structure with core dependencies and domain-specific error types that will be used throughout the CLI.
Output: Working Rust project with clap CLI parser and comprehensive error types.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-core-protocol-config/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Cargo project and add dependencies</name>
  <files>Cargo.toml</files>
  <action>
  Create Cargo.toml with project metadata and dependencies:

  **Project metadata:**
  - name: "mcp-cli-rs"
  - version: "0.1.0"
  - edition: "2021"
  - description: "MCP CLI client in Rust with cross-platform support"

  **Dependencies** (from STACK.md):
  ```toml
  [dependencies]
  # Core framework
  clap = { version = "4.5", features = ["derive"] }
  tokio = { version = "1.49", features = ["full"] }

  # MCP protocol
  serde = { version = "1.0", features = ["derive"] }
  serde_json = "1.0"

  # Transport/Network
  reqwest = { version = "0.12", features = ["json"] }

  # Error handling
  anyhow = "1.0"
  thiserror = "2.0"

  # Logging
  tracing = "0.1"
  tracing-subscriber = "0.3"

  # Utilities
  shell-words = "1.1"
  glob = "0.3"
  ```

  **Dev dependencies:**
  ```toml
  [dev-dependencies]
  tokio-test = "0.4"
  tempfile = "3.13"
  ```

  Note: NOT including mcp-sdk 0.0.3 due to minimal documentation (11%), using tokio + serde_json directly (as recommended in RESEARCH.md gap analysis).
  </action>
  <verify>cargo check</verify>
  <done>Project compiles with all required dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create error types with thiserror</name>
  <files>src/error.rs</files>
  <action>
  Create src/error.rs with domain-specific error types using thiserror derive macro:

  **Error types** (from REQUIREMENTS.md ERR-01 through ERR-06, XP-03):

  ```rust
  use thiserror::Error;

  /// Main error type for MCP CLI
  #[derive(Error, Debug)]
  pub enum McpError {
      // Configuration errors (CONFIG-01, CONFIG-04)
      #[error("Failed to read config file '{}': {}", path.display(), source)]
      ConfigReadError {
          path: std::path::PathBuf,
          #[source] source: std::io::Error,
      },

      #[error("Invalid TOML in config file '{}': {}", path.display(), source)]
      ConfigParseError {
          path: std::path::PathBuf,
          #[source] source: Box<dyn std::error::Error + Send + Sync>,
      },

      #[error("Missing required field '{}' in server configuration for '{}'", field, server)]
      MissingRequiredField {
          server: String,
          field: &'static str,
      },

      // Connection errors (CONN-01, CONN-02, CONN-03)
      #[error("Failed to connect to server '{}': {}", server, source)]
      ConnectionError {
          server: String,
          #[source] source: std::io::Error,
      },

      #[error("Server '{}' not found", server)]
      ServerNotFound { server: String },

      // Tool errors (EXEC-04, DISC-03)
      #[error("Tool '{}' not found in server '{}'", tool, server)]
      ToolNotFound { tool: String, server: String },

      #[error("Invalid JSON arguments: {}", source)]
      InvalidJson {
          #[from] source: serde_json::Error,
      },

      // Protocol errors (XP-03)
      #[error("Invalid MCP protocol message: {}", message)]
      InvalidProtocol { message: String },

      #[error("Timeout waiting for server response ({}s timeout)", timeout)]
      Timeout { timeout: u64 },

      // CLI errors (ERR-06)
      #[error("Ambiguous command: {}", hint)]
      AmbiguousCommand { hint: String },
  }

  /// Exit codes (ERR-03)
  pub fn exit_code(error: &McpError) -> i32 {
      match error {
          McpError::ServerNotFound { .. }
          | McpError::ToolNotFound { .. }
          | McpError::ConfigReadError { .. }
          | McpError::ConfigParseError { .. }
          | McpError::MissingRequiredField { .. }
          | McpError::InvalidJson { .. }
          | McpError::AmbiguousCommand { .. } => 1, // Client error

          McpError::InvalidProtocol { .. } => 2, // Server error

          McpError::ConnectionError { .. } | McpError::Timeout { .. } => 3, // Network error
      }
  }

  /// Context helper for missing fields (CONFIG-04)
  impl McpError {
      pub fn missing_field(server: &str, field: &'static str) -> Self {
          Self::MissingRequiredField {
              server: server.to_string(),
              field,
          }
      }

      pub fn config_read(path: &std::path::Path, source: std::io::Error) -> Self {
          Self::ConfigReadError {
              path: path.to_path_buf(),
              source,
          }
      }

      pub fn connection_error(server: &str, source: std::io::Error) -> Self {
          Self::ConnectionError {
              server: server.to_string(),
              source,
          }
      }

      pub fn tool_not_found(tool: &str, server: &str) -> Self {
          Self::ToolNotFound {
              tool: tool.to_string(),
              server: server.to_string(),
          }
      }
  }

  // Result type alias (anyhow style)
  pub type Result<T> = std::result::Result<T, McpError>;
  ```

  Key points:
  - Use thiserror for Display and Error impls (ERR-01)
  - Include detailed error context messages (ERR-01)
  - Implement exit code conventions (ERR-03)
  - Helper constructors for common error cases
  </action>
  <verify>cargo check</verify>
  <done>Error types compile with proper Display and Error impls</done>
</task>

<task type="auto">
  <name>Task 3: Create lib.rs and main.rs scaffolds</name>
  <files>src/lib.rs, src/main.rs</files>
  <action>
  Create library exports and main entry point:

  **src/lib.rs:**
  ```rust
  //! MCP CLI Rust Rewrite
  //!
  //! Cross-platform MCP client with stdio and HTTP transport support.

  pub mod error;
  pub use error::{McpError, Result, exit_code};

  // These modules will be created in subsequent plans
  // pub mod client;
  // pub mod config;
  // pub mod cli;
  ```

  **src/main.rs:**
  ```rust
  use clap::{Parser, Subcommand};
  use mcp_cli_rs::error::{exit_code, McpError, Result};

  #[derive(Parser)]
  #[command(name = "mcp")]
  #[command(about = "MCP CLI client for tool discovery and execution", long_about = None)]
  struct Cli {
      /// Path to configuration file (mcp_servers.toml)
      #[arg(short, long, global = true)]
      config: Option<std::path::PathBuf>,

      #[command(subcommand)]
      command: Option<Commands>,
  }

  #[derive(Subcommand)]
  enum Commands {
      /// List all servers and their available tools (CLI-01, DISC-01)
      List {
          /// Include tool descriptions
          #[arg(short = 'd', long)]
          with_descriptions: bool,
      },

      /// Show details for a specific server (DISC-02)
      Info {
          /// Server name
          name: String,
      },

      /// Show details for a specific tool (DISC-03)
      Tool {
          /// Tool identifier (server/tool or server tool)
          #[arg(value_name = "TOOL")]
          tool: String,
      },

      /// Execute a tool (EXEC-01, EXEC-02)
      Call {
          /// Tool identifier (server/tool or server tool)
          #[arg(value_name = "TOOL")]
          tool: String,

          /// JSON arguments for the tool
          #[arg(value_name = "ARGS")]
          args: Option<String>,
      },

      /// Search for tools by name pattern (DISC-04)
      Search {
          /// Glob pattern to match tool names
          #[arg(value_name = "PATTERN")]
          pattern: String,
      },
  }

  #[tokio::main]
  async fn main() {
      // CLI-02: Display version with --version (handled by clap)
      // CLI-01: Display help with --help (handled by clap)

      let cli = Cli::parse();

      if let Err(e) = run(cli).await {
          eprintln!("error: {}", e);
          std::process::exit(exit_code(&e));
      }
  }

  async fn run(cli: Cli) -> Result<()> {
      match cli.command {
          Some(Commands::List { with_descriptions }) => {
              // TODO: Implement in Plan 04
              eprintln!("List command not yet implemented");
              Ok(())
          }
          Some(Commands::Info { name }) => {
              // TODO: Implement in Plan 04
              eprintln!("Info command not yet implemented");
              Ok(())
          }
          Some(Commands::Tool { tool }) => {
              // TODO: Implement in Plan 04
              eprintln!("Tool command not yet implemented");
              Ok(())
          }
          Some(Commands::Call { tool, args }) => {
              // TODO: Implement in Plan 04
              eprintln!("Call command not yet implemented");
              Ok(())
          }
          Some(Commands::Search { pattern }) => {
              // TODO: Implement in Plan 04
              eprintln!("Search command not yet implemented");
              Ok(())
          }
          None => {
              // DISC-01: List all servers when no subcommand provided
              // TODO: Implement in Plan 04
              eprintln!("No command specified - will list servers");
              Ok(())
          }
      }
  }
  ```

  Key points:
  - Use clap derive macros for CLI parsing (CLI-01, CLI-02, CLI-03)
  - Version flag (CLI-02) and help flag (CLI-01) handled by clap
  - Config path flag (CLI-03) in global options
  - Async main with tokio
  - Command enum with placeholders for future implementation
  </action>
  <verify>cargo check && cargo run -- --help</verify>
  <done>CLI help displays correctly, project compiles and runs</done>
</task>

</tasks>

<verification>
1. `cargo check` passes with no errors
2. `cargo run -- --help` displays CLI usage
3. `cargo run -- --version` displays version
4. All error types in src/error.rs compile with proper Display impls
</verification>

<success_criteria>
- Project compiles with all dependencies
- CLI can parse basic arguments (--help, --version)
- Error types cover all expected failure modes (config, connection, tool, protocol, CLI errors)
- Exit codes follow convention (0=success, 1=client, 2=server, 3=network)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-protocol-config/01-01-SUMMARY.md`
</output>
