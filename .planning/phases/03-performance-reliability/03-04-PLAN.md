---
phase: 03-performance-reliability
plan: 04
type: execute
wave: 3
depends_on: ["03-01", "03-02"]
files_modified:
  - src/cli/commands.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "cmd_list_servers processes multiple servers concurrently using ParallelExecutor"
    - "cmd_search_tools searches across all servers concurrently"
    - "Partial failures display warning messages (ERR-07) but operation continues"
    - "Error and warning messages use colored output when appropriate (ERR-04)"
  artifacts:
    - path: "src/cli/commands.rs"
      provides: "Parallel discovery with colored output"
      contains: "use crate::parallel::"
      contains: "use crate::output::"
  key_links:
    - from: "src/cli/commands.rs"
      to: "src/parallel.rs"
      via: "ParallelExecutor::default() and list_tools_parallel"
      pattern: "list_tools_parallel.*executor"
    - from: "src/cli/commands.rs"
      to: "src/output.rs"
      via: "print_error, print_warning"
      pattern: "print_error|print_warning"
    - from: "src/cli/commands.rs"
      to: "src/ipc/ProtocolClient"
      via: "daemon.list_tools() calls"
      pattern: "daemon\.list_tools\(server\)\.await"
---

<objective>
Integrate parallel execution and colored output into discovery CLI commands.

Purpose: Implement DISC-05 (parallel server discovery), ERR-04 (colored output), ERR-07 (partial failure warnings) for cmd_list_servers and cmd_search_tools. Users experience faster discovery across multiple servers with clear feedback on success/failure.

Output: Updated cmd_list_servers and cmd_search_tools with ParallelExecutor, colored output warnings, and partial failure handling.
</objective>

<execution_context>
@.opencode/get-shit-done/workflows/execute-plan.md
@.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@src/cli/commands.rs
@src/parallel.rs
@src/output.rs
@src/ipc/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Update cmd_list_servers for parallel discovery</name>
  <files>src/cli/commands.rs</files>
  <action>Modify cmd_list_servers in src/cli/commands.rs to use parallel execution:

1. Add imports at the top of the file (after existing imports):
```rust
use crate::parallel::{ParallelExecutor, list_tools_parallel};
use crate::output::{print_error, print_warning, print_info};
```

2. Replace the entire cmd_list_servers function with this implementation:

```rust
/// Execute the list servers command.
///
/// Lists all configured MCP servers and their tool availability.
/// Implements DISC-01: discovery of available tools.
/// Implements DISC-05: parallel server discovery with configurable concurrency.
/// Implements ERR-07: partial failure warnings.
///
/// # Arguments
/// * `daemon` - Daemon IPC client
/// * `with_descriptions` - If true, show tool descriptions (DISC-06)
///
/// # Errors
/// Returns McpError::ConfigParseError if config file is invalid
pub async fn cmd_list_servers(
    mut daemon: Box<dyn crate::ipc::ProtocolClient>,
    with_descriptions: bool,
) -> Result<()> {
    if daemon.config().is_empty() {
        print_error("No servers configured. Please create a config file.");
        return Ok(());
    }

    print_info("Configured servers:");
    println!();

    // Get server names from daemon
    let server_names = match daemon.list_servers().await {
        Ok(names) => names,
        Err(e) => {
            print_error(&format!("Failed to get servers list: {}", e));
            return Err(e);
        }
    };

    // Create parallel executor with concurrency limit from config
    let executor = ParallelExecutor::new(daemon.config().concurrency_limit);

    // List tools from all servers in parallel using list_tools_parallel
    let (successes, failures) = list_tools_parallel(
        server_names,
        // Closure that lists tools for a single server
        |server: String| async move {
            daemon.list_tools(&server).await
                .map_err(|e| {
                    // Log individual failures but continue with other servers
                    tracing::warn!("Failed to list tools for {}: {}", server, e);
                    e
                })
        },
        &executor,
    )
    .await?;

    // Display successful results
    for (server_name, tools) in successes {
        // Get server info from config for display
        if let Some(server_config) = daemon.config().get_server(&server_name) {
            println!("{} {} ({})", server_name, server_config.description.as_deref().unwrap_or(""), server_config.transport.type_name());
        } else {
            println!("{} (unknown)", server_name);
        }

        print_info(&format!("    Tools: {}", tools.len()));
        if with_descriptions && !tools.is_empty() {
            for tool in &tools {
                println!("      - {}: {}", tool.name, tool.description.as_deref().unwrap_or(""));
            }
        }
        println!();
    }

    // Warn about partial failures (ERR-07)
    if !failures.is_empty() {
        print_warning(&format!(
            "Failed to connect to {} of {} servers: {}",
            failures.len(),
            successes.len() + failures.len(),
            failures.join(", ")
        ));
        println!();
    }

    Ok(())
}
```

Key changes:
- Uses ParallelExecutor with config.concurrency_limit
- Calls list_tools_parallel to process servers concurrently
- Separates successes vs failures for partial failure reporting (ERR-07)
- Uses colored output functions (print_error, print_warning, print_info)
- Displays summary warning when some servers fail but operation continues</action>
  <verify>Run `cargo check` to verify cmd_list_servers compiles. Test that the function signature matches the original (takes daemon and with_descriptions parameters).</verify>
  <done>cmd_list_servers uses ParallelExecutor, list_tools_parallel, colored output, partial failure warnings, code compiles.</done>
</task>

<task type="auto">
  <name>Update cmd_search_tools for parallel discovery</name>
  <files>src/cli/commands.rs</files>
  <action>Modify cmd_search_tools in src/cli/commands.rs to use parallel execution:

Replace the entire cmd_search_tools function with this implementation:

```rust
/// Execute search tools command.
///
/// Search for tools using glob patterns across all servers in parallel.
/// Implements DISC-04: search of tools using glob patterns.
/// Implements DISC-05: parallel server discovery.
/// Implements ERR-07: partial failure warnings.
///
/// # Arguments
/// * `daemon` - Daemon IPC client
/// * `pattern` - Glob pattern to search for (e.g., "*", "search*", "tool-*")
///
/// # Errors
/// Returns empty result if no tools match
pub async fn cmd_search_tools(
    mut daemon: Box<dyn crate::ipc::ProtocolClient>,
    pattern: &str,
) -> Result<()> {
    if daemon.config().is_empty() {
        print_error("No servers configured. Please create a config file.");
        return Ok(());
    }

    print_info(&format!("Searching for tools matching '{}':", pattern));

    // Get server names from daemon
    let server_names = match daemon.list_servers().await {
        Ok(names) => names,
        Err(e) => {
            print_error(&format!("Failed to get servers list: {}", e));
            return Err(e);
        }
    };

    // Create parallel executor with concurrency limit from config
    let executor = ParallelExecutor::new(daemon.config().concurrency_limit);

    // List tools from all servers in parallel
    let (successes, failures) = list_tools_parallel(
        server_names,
        |server: String| async move {
            daemon.list_tools(&server).await
                .map_err(|e| {
                    tracing::warn!("Failed to list tools for {}: {}", server, e);
                    e
                })
        },
        &executor,
    )
    .await?;

    let mut matches_found = false;
    let mut total_matches = 0;

    // Search across successfully discovered servers
    for (server_name, tools) in successes {
        println!("Server: {}:", server_name);

        // Match tool names against the glob pattern
        let matched_tools: Vec<_> = tools
            .iter()
            .filter(|tool| {
                let tool_name = &tool.name;
                // Use globset for pattern matching
                match glob::Pattern::new(pattern) {
                    Ok(pattern_obj) => pattern_obj.matches(tool_name),
                    Err(_) => tool_name.contains(pattern),
                }
            })
            .collect();

        if !matched_tools.is_empty() {
            matches_found = true;
            total_matches += matched_tools.len();
            print_info(&format!("  - {} tool(s):", matched_tools.len()));
            for tool in matched_tools {
                println!("      - {}: {}", tool.name, tool.description.as_deref().unwrap_or(""));
            }
        }
    }

    // Warn about partial failures (ERR-07)
    if !failures.is_empty() {
        print_warning(&format!(
            "Search limited to {} servers ({} failed): {}",
            successes.len(),
            failures.len(),
            failures.join(", ")
        ));
        println!();
    }

    if !matches_found {
        print_error("No matching tools found.");
    } else {
        println!();
        print_info(&format!("Total matches: {}", total_matches));
    }

    Ok(())
}
```

Key changes:
- Uses ParallelExecutor with config.concurrency_limit
- Calls list_tools_parallel to process servers concurrently
- Searches across successfully discovered servers in parallel
- Displays partial failure warnings when some servers fail
- Uses colored output (print_error, print_warning, print_info)
- Shows total matches found across all servers</action>
  <verify>Run `cargo check` to verify cmd_search_tools compiles. Test that glob pattern matching still works correctly.</verify>
  <done>cmd_search_tools uses ParallelExecutor, list_tools_parallel, colored output, partial failure warnings, code compiles.</done>
</task>

<task type="auto">
  <name>Apply colored output to remaining CLI error messages</name>
  <files>src/cli/commands.rs</files>
  <action>Update remaining error messages in CLI commands to use colored output:

1. Update cmd_server_info to use print_error for error cases:
```rust
// Replace eprintln! calls with print_error where appropriate
// Example:
// Old: eprintln!("Server '{}' not found", server_name);
// New: print_error(&format!("Server '{}' not found", server_name));
```

2. Update cmd_tool_info to use print_error for error cases:
```rust
// Replace any eprintln! error messages with print_error
```

3. Update cmd_call_tool to use print_error/stdin message handling:
```rust
// Replace: println!("No arguments provided...")
// With: print_error("No arguments provided. Pass JSON arguments as a command-line argument, or pipe JSON to stdin.");

// Replace: println!("Error from server '{}':", server_name);
// With: print_error(&format!("Error from server '{}': {}", server_name, message));
```

4. Ensure all existing print statements for success/info use print_info where appropriate.

Scan through the commands.rs file and replace error/warning eprintln! statements with the colored output utilities (print_error for errors, print_warning for warnings, print_info for info messages).

Note: Keep println! statements that display actual data (server names, tool lists, results) - only apply colored output to status/error messages.</action>
  <verify>Run `cargo check` to verify all colored output functions compile correctly. Scan commands.rs to ensure all error/warning messages use colored utilities.</verify>
  <done>All error messages use print_error, warnings use print_warning, info messages use print_info, code compiles.</done>
</task>

</tasks>

<verification>
Run `cargo check` to verify all changes compile together:
- cmd_list_servers uses ParallelExecutor and list_tools_parallel
- cmd_search_tools uses ParallelExecutor and list_tools_parallel
- Colored output utilities used throughout commands.rs
- Error/warning messages consistent

Expected: No compilation errors, commands ready for execution with parallel discovery.

Optional: Test with `cargo test` if there are command integration tests.
</verification>

<success_criteria>
1. cmd_list_servers uses ParallelExecutor(config.concurrency_limit) with list_tools_parallel
2. cmd_search_tools uses ParallelExecutor(config.concurrency_limit) with list_tools_parallel
3. Both functions display partial failure warnings using print_warning when some servers fail
4. Error messages use print_error, warnings use print_warning, info uses print_info
5. Successful tool discovery continues even when some servers fail
6. Code compiles and function signatures unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance-reliability/03-04-SUMMARY.md`
</output>
