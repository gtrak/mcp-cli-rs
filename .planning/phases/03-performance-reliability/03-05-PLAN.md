---
phase: 03-performance-reliability
plan: 05
type: execute
wave: 4
depends_on: ["03-01", "03-03", "03-06", "03-04"]
files_modified:
  - src/cli/commands.rs
  - src/main.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "cmd_call_tool automatically retries on transient errors with exponential backoff (EXEC-05)"
    - "Tool execution respects overall timeout and cancels when budget exhausted (EXEC-06)"
    - "Retry limits enforced (max 3 attempts, base 1000ms delay) (EXEC-07)"
    - "CLI handles SIGINT/SIGTERM gracefully with proper cleanup (CLI-04)"
  artifacts:
    - path: "src/cli/commands.rs"
      provides: "Retry and timeout for tool execution"
      contains: "use crate::retry::"
    - path: "src/main.rs"
      provides: "Signal handling integration"
      contains: "use crate::shutdown::"
  key_links:
    - from: "src/cli/commands.rs"
      to: "src/retry.rs"
      via: "retry_with_backoff and timeout_wrapper"
      pattern: "retry_with_backoff.*daemon\.execute_tool"
    - from: "src/cli/commands.rs"
      to: "src/config/mod.rs"
      via: "RetryConfig::from_config"
      pattern: "RetryConfig::from_config.*config"
    - from: "src/main.rs"
      to: "src/shutdown.rs"
      via: "GracefulShutdown::new and run_with_graceful_shutdown"
      pattern: "GracefulShutdown::new|run_with_graceful_shutdown"
---

<objective>
Integrate retry logic with tool execution and add signal handling to main CLI.

Purpose: Implement EXEC-05 (automatic retry with exponential backoff), EXEC-06 (operation timeout enforcement), EXEC-07 (retry limits) for cmd_call_tool, and CLI-04 (graceful signal handling) in main CLI loop. Users experience reliable tool execution that recovers from transient failures and clean termination on signals.

Output: Updated cmd_call_tool with retry_with_backoff and timeout_wrapper, main.rs with GracefulShutdown integration.
</objective>

<execution_context>
@.opencode/get-shit-done/workflows/execute-plan.md
@.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@src/cli/commands.rs
@src/retry.rs
@src/shutdown.rs
@src/config/mod.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Update cmd_call_tool with retry and timeout</name>
  <files>src/cli/commands.rs</files>
  <action>Modify cmd_call_tool in src/cli/commands.rs to use retry logic and timeout enforcement:

1. Add imports at the top of the file (verify these are present, add if missing):
```rust
use crate::retry::{RetryConfig, retry_with_backoff, timeout_wrapper};
```

2. Replace the entire cmd_call_tool function with this implementation:

```rust
/// Execute tool call command.
///
/// Executes a tool with JSON arguments, retrying on transient failures.
/// Implements EXEC-01, EXEC-02, EXEC-04, EXEC-05, EXEC-06, EXEC-07.
///
/// # Arguments
/// * `daemon` - Daemon IPC client
/// * `tool_id` - Tool identifier in format "server/tool" or "server tool"
/// * `args_json` - JSON arguments as a string, or None to read from stdin
///
/// # Errors
/// Returns McpError::InvalidProtocol for malformed response
/// Returns McpError::Timeout if timeout exceeded (EXEC-06)
/// Returns McpError::MaxRetriesExceeded if all retry attempts fail (EXEC-07)
pub async fn cmd_call_tool(
    mut daemon: Box<dyn crate::ipc::ProtocolClient>,
    tool_id: &str,
    args_json: Option<&str>,
) -> Result<()> {
    let (server_name, tool_name) = parse_tool_id(tool_id)?;

    let _server = daemon
        .config()
        .get_server(&server_name)
        .ok_or_else(|| McpError::ServerNotFound {
            server: server_name.clone(),
        })?;

    // Parse arguments (inline or from stdin)
    let arguments = match args_json {
        Some(args) => {
            serde_json::from_str(args).map_err(|e| McpError::InvalidJson { source: e })?
        }
        None => {
            // Read from stdin if not provided (EXEC-02)
            if std::io::stdin().is_terminal() {
                print_error("No arguments provided. Pass JSON arguments as a command-line argument, or pipe JSON to stdin.");
                let available_tools = match daemon.list_tools(&server_name).await {
                    Ok(tools) => tools.iter().map(|t| &t.name).collect::<Vec<_>>().join(", "),
                    Err(_) => "(unavailable)".to_string(),
                };
                println!();
                print_info(&format!("Available tools on '{}': {}", server_name, available_tools));
                return Ok(());
            }

            let input = read_stdin_async()?;
            serde_json::from_str(&input).map_err(|e| McpError::InvalidJson { source: e })?
        }
    };

    // Execute tool with retry logic (EXEC-05, EXEC-07)
    let retry_config = RetryConfig::from_config(daemon.config());
    let timeout_secs = daemon.config().timeout_secs;

    // Wrap execution with both retry logic and overall timeout
    let result = timeout_wrapper(
        || async {
            retry_with_backoff(
                || {
                    let server_name = server_name.clone();
                    let tool_name = tool_name.clone();
                    let arguments = arguments.clone();

                    async move {
                        // Send ExecuteTool request to daemon
                        daemon
                            .execute_tool(&server_name, &tool_name, arguments)
                            .await
                    }
                },
                &retry_config,
            )
            .await
        },
        timeout_secs,
    )
    .await;

    match result {
        Ok(result) => {
            // Format and display the result (EXEC-03)
            format_and_display_result(&result, &server_name);
            Ok(())
        }
        Err(McpError::MaxRetriesExceeded { attempts }) => {
            print_error(&format!(
                "Tool execution failed after {} retry attempts. Last error: {}",
                attempts,
                "No additional information available"
            ));
            Err(McpError::MaxRetriesExceeded { attempts })
        }
        Err(McpError::OperationCancelled { timeout }) => {
            print_error(&format!(
                "Tool execution cancelled after {}s timeout",
                timeout
            ));
            Err(McpError::OperationCancelled { timeout })
        }
        Err(e) => {
            print_error(&format!("Tool execution failed: {}", e));
            Err(e)
        }
    }
}
```

Key changes:
- Uses RetryConfig::from_config to get retry settings
- Wraps daemon.execute_tool with retry_with_backoff for automatic retry on transient errors (EXEC-05, EXEC-07)
- Wraps entire operation with timeout_wrapper for overall timeout enforcement (EXEC-06)
- Provides clearer error messages for max retries and timeout cases
- Uses colored output for error messages
- Shows available tools when no arguments provided (better UX)</action>
  <verify>Run `cargo check` to verify cmd_call_tool compiles. Test that the function can handle both inline and stdin arguments.</verify>
  <done>cmd_call_tool uses retry_with_backoff with RetryConfig::from_config, timeout_wrapper, colored error messages, code compiles.</done>
</task>

<task type="auto">
  <name>Integrate signal handling in main CLI</name>
  <files>src/main.rs</files>
  <action>Modify src/main.rs to integrate graceful signal handling:

1. Add imports at the top of main.rs (after existing imports):
```rust
use mcp_cli_rs::shutdown::{GracefulShutdown, run_with_graceful_shutdown};
```

2. Find the main function (likely starting with `#[tokio::main]` or similar) and wrap it with signal handling:

If main.rs has this structure:
```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // ... CLI setup and command execution
}
```

Replace it with:

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create graceful shutdown handler
    let shutdown = GracefulShutdown::new();
    shutdown.spawn_signal_listener();

    // Run main CLI logic with graceful shutdown support
    let result = run_with_graceful_shutdown(
        || async {
            // Original main logic here
            run_cli().await
        },
        shutdown.subscribe(),
    )
    .await;

    // Handle result
    match result {
        Ok(_) => Ok(()),
        Err(e) => {
            // Check if it was a shutdown (interrupted)
            if let Some(io_err) = e.downcast_ref::<std::io::Error>() {
                if io_err.kind() == std::io::ErrorKind::Interrupted {
                    // User initiated shutdown - clean exit
                    return Ok(());
                }
            }
            // Other errors - propagate
            Err(e.into())
        }
    }
}

/// Run the main CLI logic.
///
/// This function contains the actual CLI command parsing and execution.
/// Separated from main() to enable graceful shutdown wrapping.
async fn run_cli() -> Result<(), Box<dyn std::error::Error>> {
    // Original main logic starts here
    // ... (rest of main.rs content)
}
```

If main.rs has a different structure, adapt the wrapper pattern accordingly:
1. Create GracefulShutdown and spawn signal listener
2. Wrap existing main logic in run_with_graceful_shutdown
3. Handle Interrupted error as clean shutdown

The key is that all async CLI operations should be wrapped with run_with_graceful_shutdown to enable signal handling throughout the application.</action>
  <verify>Run `cargo check` to verify main.rs compiles with signal handling. Ensure that GracefulShutdown captures SIGINT/SIGTERM on Unix and Ctrl+C on Windows.</verify>
  <done>GracefulShutdown initialized in main, signal listener spawned, main logic wrapped with run_with_graceful_shutdown, code compiles.</done>
</task>

<task type="auto">
  <name>Apply colored output to cmd_call_tool success messages</name>
  <files>src/cli/commands.rs</files>
  <action>Update cmd_call_tool to use colored output for success/info messages:

1. Update format_and_display_result to use print_info for informational messages:
```rust
// In format_and_display_result function:

// Replace: println!("Result:");
// With: print_info("Result:");

// Replace: println!("  {}", line);
// With: println!("{}", line);  // Keep raw output for tool results, not colored
```

2. Add success message after successful tool execution in cmd_call_tool:
```rust
// In cmd_call_tool, after format_and_display_result call:
match result {
    Ok(result) => {
        // Format and display the result (EXEC-03)
        format_and_display_result(&result, &server_name);

        // Add success message
        println!();
        print_info(&format!("Tool '{}' executed successfully on server '{}'", tool_name, server_name));

        Ok(())
    }
    // ... rest of error handling
}
```

Note: Only apply colored output to status/info messages, not the actual tool result data (which should be displayed in plain text for readability and scriptability).</action>
  <verify>Run `cargo check` to verify colored output integration in cmd_call_tool. Test with `cargo test` if there are command tests.</verify>
  <done>cmd_call_tool uses print_info for status messages, success message displayed after execution, code compiles.</done>
</task>

</tasks>

<verification>
Run `cargo check` to verify all changes compile together:
- cmd_call_tool uses retry_with_backoff with RetryConfig::from_config
- cmd_call_tool uses timeout_wrapper with config.timeout_secs
- main.rs integrates GracefulShutdown with run_with_graceful_shutdown
- All colored output functions used appropriately
- Error handling for max retries and timeout cases

Expected: No compilation errors, CLI ready for signal handling and robust tool execution.

Optional: Test signal handling by running the binary and pressing Ctrl+C (test that "Shutting down gracefully..." message appears).
</verification>

<success_criteria>
1. cmd_call_tool wraps daemon.execute_tool with retry_with_backoff (automatic retry on transient errors)
2. cmd_call_tool wraps entire operation with timeout_wrapper (enforces timeout from config)
3. RetryConfig loaded from config (max_attempts, base_delay_ms, max_delay_ms)
4. Clear error messages for MaxRetriesExceeded and OperationCancelled cases
5. main.rs creates GracefulShutdown and spawns signal listener
6. Main CLI logic wrapped with run_with_graceful_shutdown for signal handling
7. Clean shutdown on SIGINT/SIGTERM (Unix) or Ctrl+C (Windows)
8. Code compiles and executes correctly
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance-reliability/03-05-SUMMARY.md`
</output>
