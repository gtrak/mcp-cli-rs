---
phase: 03-performance-reliability
plan: 06
type: execute
wave: 2
depends_on: []
files_modified:
  - src/shutdown.rs
  - src/lib.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "GracefulShutdown can handle SIGINT/SIGTERM on Unix and Ctrl+C on Windows"
    - "spawn_signal_listener creates async task to listen for signals"
    - "run_with_graceful_shutdown provides wrapper for operations with shutdown support"
  artifacts:
    - path: "src/shutdown.rs"
      provides: "Signal handling infrastructure"
      exports: ["GracefulShutdown", "run_with_graceful_shutdown"]
      contains: "tokio::signal"
    - path: "src/lib.rs"
      provides: "Shutdown module exports"
      contains: "pub mod shutdown"
  key_links:
    - from: "src/shutdown.rs"
      to: "src/main.rs"
      via: "GracefulShutdown integration"
      pattern: "run_with_graceful_shutdown"
---

<objective>
Create signal handling infrastructure for graceful shutdown.

Purpose: Implement CLI-04 (graceful signal handling). Uses tokio::signal for cross-platform signal handling on Unix (SIGINT/SIGTERM) and Windows (Ctrl+C). Provides broadcast channel pattern for clean resource cleanup on termination.

Output: src/shutdown.rs with GracefulShutdown and run_with_graceful_shutdown; shutdown module export in lib.rs.
</objective>

<execution_context>
@.opencode/get-shit-done/workflows/execute-plan.md
@.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/phases/03-performance-reliability/03-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create signal handling module</name>
  <files>src/shutdown.rs</files>
  <action>Create a new file src/shutdown.rs with signal handling infrastructure:

```rust
//! Graceful signal handling and shutdown utilities.
//!
//! Provides cross-platform signal handling for SIGINT/SIGTERM (Unix)
//! and Ctrl+C (Windows). Implements CLI-04.

use tokio::sync::broadcast;
use tokio::signal;

/// Graceful shutdown handler for signals.
///
/// Allows async operations to respond to termination requests
/// and clean up resources properly.
pub struct GracefulShutdown {
    /// Shutdown sender.
    shutdown_tx: broadcast::Sender<bool>,

    /// Shutdown receiver.
    shutdown_rx: broadcast::Receiver<bool>,
}

impl GracefulShutdown {
    /// Create a new GracefulShutdown handler.
    pub fn new() -> Self {
        let (shutdown_tx, shutdown_rx) = broadcast::channel(1);

        Self {
            shutdown_tx,
            shutdown_rx,
        }
    }

    /// Spawn the signal listener task.
    ///
    /// Listens for SIGINT/SIGTERM on Unix and Ctrl+C on Windows.
    /// Sends shutdown signal when received.
    pub fn spawn_signal_listener(&self) {
        let mut shutdown_tx = self.shutdown_tx.clone();

        tokio::spawn(async move {
            #[cfg(unix)]
            {
                use tokio::signal::unix::{self, SignalKind};

                // Setup signal handlers for POSIX systems
                let mut sigint = unix::signal(SignalKind::interrupt())
                    .expect("Failed to setup SIGINT handler");
                let mut sigterm = unix::signal(SignalKind::terminate())
                    .expect("Failed to setup SIGTERM handler");

                tokio::select! {
                    _ = sigint.recv() => {
                        println!("\nReceived SIGINT (Ctrl+C), shutting down...");
                    }
                    _ = sigterm.recv() => {
                        println!("\nReceived SIGTERM, shutting down...");
                    }
                }
            }

            #[cfg(windows)]
            {
                // Setup Ctrl+C handler for Windows
                if signal::ctrl_c().await.is_ok() {
                    println!("\nReceived shutdown signal, shutting down...");
                }
            }

            // Send shutdown signal to all listeners
            let _ = shutdown_tx.send(true);
        });
    }

    /// Subscribe to shutdown notifications.
    ///
    /// Operations holding a receiver can check for shutdown requests.
    pub fn subscribe(&self) -> broadcast::Receiver<bool> {
        self.shutdown_tx.subscribe()
    }

    /// Check if shutdown was requested.
    ///
    /// Returns true if shutdown signal was sent.
    pub fn is_shutdown_requested(&mut self) -> bool {
        if let Ok(Ok(_)) = self.shutdown_rx.try_recv() {
            true
        } else {
            false
        }
    }
}

impl Default for GracefulShutdown {
    fn default() -> Self {
        Self::new()
    }
}

/// Run an async operation with graceful shutdown support.
///
/// Automatically spawns signal listener and cancels operation on shutdown.
///
/// # Arguments
/// * `op` - Async operation to run
///
/// # Returns
/// Result<T> from the operation or Ok(()) if shutdown occurred
///
/// # Example
/// ```rust,ignore
/// let shutdown = GracefulShutdown::new();
/// shutdown.spawn_signal_listener();
///
/// let result = run_with_graceful_shutdown(
///     || async {
///         // Your async operation here
///         Ok::<_, McpError>("success")
///     },
///     shutdown.subscribe(),
/// ).await?;
/// ```
pub async fn run_with_graceful_shutdown<F, T, Fut>(op: F, mut shutdown_rx: broadcast::Receiver<bool>) -> Result<T>
where
    F: Fn() -> Fut,
    Fut: std::future::Future<Output = crate::error::Result<T>>,
{
    tokio::select! {
        result = op() => result,
        _ = shutdown_rx.recv() => {
            println!("Shutting down gracefully...");
            // Return success on shutdown (user initiated)
            Err(crate::error::McpError::io_error(
                std::io::Error::new(std::io::ErrorKind::Interrupted, "Shutdown requested")
            ))
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_graceful_shutdown_default() {
        let shutdown = GracefulShutdown::default();
        // Create a receiver to ensure the system is initialized
        let _rx = shutdown.subscribe();
    }

    #[test]
    fn test_is_shutdown_requested() {
        let mut shutdown = GracefulShutdown::new();
        assert!(!shutdown.is_shutdown_requested());

        // Send shutdown signal
        let _ = shutdown.shutdown_tx.send(true);
        assert!(shutdown.is_shutdown_requested());
    }
}
```

Key implementation details:
- Cross-platform: Unix uses SignalKind::interrupt/terminate, Windows uses signal::ctrl_c()
- Uses tokio::sync::broadcast for channel pattern (multiple subscribers, one sender)
- spawn_signal_listener is async-friendly (tokio::spawn)
- run_with_graceful_shutdown provides wrapper pattern for easy integration</action>
  <verify>Run `cargo check` to verify the shutdown module compiles. Ensure tokio signal features are available (tokio "full" features include signal).</verify>
  <done>src/shutdown.rs exists with GracefulShutdown and run_with_graceful_shutdown, code compiles, tests pass.</done>
</task>

<task type="auto">
  <name>Add shutdown module to lib exports</name>
  <files>src/lib.rs</files>
  <action>Add the shutdown module to src/lib.rs exports:

Find the module declaration section in lib.rs and add (after existing modules, likely after retry module):
```rust
pub mod shutdown;
```

If modules are declared elsewhere, add them in a consistent pattern matching the existing code.

This makes GracefulShutdown and run_with_graceful_shutdown available to main.rs and CLI commands.</action>
  <verify>Run `cargo check` to verify the shutdown module is accessible. Test with `cargo test` to ensure all unit tests pass.</verify>
  <done>shutdown module exported in lib.rs, code compiles, utilities accessible from other modules.</done>
</task>

</tasks>

<verification>
Run `cargo check` to verify all changes compile together:
- src/shutdown.rs with GracefulShutdown
- lib.rs exports shutdown module
- tokio signal handling available

Expected: No compilation errors, shutdown utilities ready for CLI integration.

Run `cargo test` to verify unit tests in shutdown module pass.
</verification>

<success_criteria>
1. src/shutdown.rs module exists with GracefulShutdown (spawn_signal_listener, subscribe) and run_with_graceful_shutdown
2. Signal handling cross-platform (SIGINT/SIGTERM on Unix, Ctrl+C on Windows)
3. GracefulShutdown uses tokio::sync::broadcast for channel pattern
4. run_with_graceful_shutdown provides wrapper pattern for async operations
5. Shutdown module exported in lib.rs, code compiles, tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance-reliability/03-06-SUMMARY.md`
</output>
