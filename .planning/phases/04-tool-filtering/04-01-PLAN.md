# Plan: 04-01 Tool Filtering Features

**Type:** auto
**Dependencies:** None
**Requirements:** FILT-01, FILT-02, FILT-03, FILT-04, FILT-05

## Objective

Implement tool filtering capabilities allowing users to restrict available tools via glob patterns in server configuration. Support for both allowedTools and disabledTools with precedence rules.

## Context

- Phase 1: Core Protocol & Configuration (complete)
- Phase 2: Connection Daemon & Cross-Platform IPC (complete)
- Phase 3: Performance & Reliability (complete)

Tool filtering addresses critical security concerns for production environments where tool access must be tightly controlled.

## Tasks

### Task 1: Add Tool Filtering Configuration Fields

**Type:** auto
**TDD:** true

**Behavior:**
1. Add two new optional fields to Config struct:
   - `allowed_tools: Vec<String>` - Glob patterns for tools that are allowed to be called
   - `disabled_tools: Vec<String>` - Glob patterns for tools that are explicitly blocked

2. Create `allowed_tools_config` section in config schema with description and default values (empty lists)

3. Parse these fields from mcp_servers.toml configuration file

4. Create validation to ensure at least one field is provided (no blank configuration)

5. Update Config struct Clone implementation to support cloning with these new fields

**Implementation:**
- Modify `src/types/config.rs` to add `allowed_tools` and `disabled_tools` fields
- Add validation logic in config parsing
- Update config schema documentation
- Test parsing with TOML files containing allowedTools and/or disabledTools

**Tests:**
```rust
#[test]
fn test_config_parsing_with_allowed_tools() {
    let toml = r#"
    [mcp_servers.my_server]
    transport = "stdio"
    command = "python"
    args = ["-m", "mcp_server"]
    allowedTools = ["*"]
    "#;

    let config = Config::from_str(toml).unwrap();
    assert!(config.servers.iter().any(|s| s.allowed_tools == vec!["*".to_string()]));

    let tool_info = cmd_tool_info(&config, "my_server", "*").unwrap();
    assert_eq!(tool_info.name, "list_tools");
}

#[test]
fn test_config_parsing_with_disabled_tools() {
    let toml = r#"
    [mcp_servers.my_server]
    transport = "stdio"
    command = "python"
    args = ["-m", "mcp_server"]
    disabledTools = ["password_*"]
    "#;

    let config = Config::from_str(toml).unwrap();
    assert!(config.servers.iter().any(|s| s.disabled_tools == vec!["password_*".to_string()]));

    let call_result = cmd_call_tool(&config, "my_server", "password_set", "{}").unwrap();
    assert!(call_result.contains("disabled") || call_result.contains("blocked"));
}
```

**Verification:**
- Configuration parses correctly with allowedTools and/or disabledTools
- Both fields default to empty Vecs if not specified
- Validation prevents both fields being empty
- Clone works correctly with new fields

**Commit:**
```
feat(04-01): add tool filtering configuration fields
```

### Task 2: Implement Glob Pattern Matching

**Type:** auto
**TDD:** true

**Behavior:**
1. Create `tool_matches_pattern(tool_name: &str, pattern: &str) -> bool` function

2. Support wildcard matching with:
   - `*` matches any sequence of characters (non-greedy)
   - `?` matches any single character
   - Standard glob pattern matching using `glob` crate

3. Create `tools_match_any(tool_name: &str, patterns: &[String]) -> bool` for checking if a tool matches any pattern

4. Handle case sensitivity (case-insensitive matching recommended)

5. Create tests for various patterns:
   - Exact matches
   - Wildcard patterns (*)
   - Single-character wildcards (?)
   - Multiple wildcards (*test*)
   - Special characters in tool names

**Implementation:**
- Add glob pattern matching utility in `src/cli/filter.rs` module
- Use `glob` crate v0.3.x for pattern matching
- Implement case-insensitive matching
- Add comprehensive test coverage

**Tests:**
```rust
#[test]
fn test_exact_match() {
    assert!(tool_matches_pattern("list_tools", "list_tools"));
}

#[test]
fn test_wildcard_single_star() {
    assert!(tool_matches_pattern("my_custom_tool", "*"));
    assert!(tool_matches_pattern("another_tool", "*"));
}

#[test]
fn test_wildcard_multiple() {
    assert!(tool_matches_pattern("password_set", "pass*"));
    assert!(tool_matches_pattern("password_check", "pass*"));
    assert!(tool_matches_pattern("password_generate", "pass*"));
}

#[test]
fn test_single_char_wildcard() {
    assert!(tool_matches_pattern("test_tool", "t?t"));
    assert!(tool_matches_pattern("toast_tool", "t?t"));
    assert!(!tool_matches_pattern("top_tool", "t?t")); // fails single char
}

#[test]
fn test_case_insensitive() {
    assert!(tool_matches_pattern("PASSWORD_SET", "pass*"));
}
```

**Verification:**
- Tool names match patterns correctly
- Case-insensitive matching works
- Glob patterns are efficient and reliable
- No regressions in existing tool discovery

**Commit:**
```
feat(04-01): implement glob pattern matching for tool names
```

### Task 3: Apply Filtering in Tool Discovery

**Type:** auto
**TDD:** true

**Behavior:**
1. Modify `list_tools_parallel()` in `src/cli/commands.rs` to apply filtering:

   - For each server, filter available tools based on:
     - If `disabled_tools` is non-empty, skip any tool that matches any pattern
     - If `allowed_tools` is non-empty, return only tools that match any pattern
     - If both are empty, return all tools (default behavior)

2. Update parallel executor to accept Config reference (already done)

3. Return filtered tool lists to CLI commands
   - `cmd_list_servers()` - show only allowed tools per server
   - `cmd_search_tools()` - search only allowed tools

4. Add colored warning for partial filtering results

**Implementation:**
- Modify `parallel.rs` to filter tool results based on Config
- Update CLI commands to pass Config reference
- Add filtering logic after tool discovery completes
- Preserve original tool list for debugging if needed

**Tests:**
```rust
#[test]
fn test_filtering_all_disabled_tools() {
    let config = Config {
        servers: vec![
            ServerConfig {
                name: "server1".to_string(),
                disabled_tools: vec!["*password*".to_string()],
                ..Default::default()
            }
        ],
        ..Default::default()
    };

    let tools = list_tools_parallel(&config).unwrap();
    let server1_tools = &tools.0[0];
    assert!(server1_tools.iter().all(|t| !t.contains("password")));
}

#[test]
fn test_filtering_allowed_tools_only() {
    let config = Config {
        servers: vec![
            ServerConfig {
                name: "server1".to_string(),
                allowed_tools: vec!["list_*".to_string()],
                ..Default::default()
            }
        ],
        ..Default::default()
    };

    let tools = list_tools_parallel(&config).unwrap();
    let server1_tools = &tools.0[0];
    assert!(server1_tools.iter().all(|t| t.starts_with("list")));
}
```

**Verification:**
- Tools correctly filtered based on disabledTools patterns
- Tools correctly filtered based on allowedTools patterns
- Parallel execution maintains filtering efficiency
- CLI commands display filtered results
- Warnings shown for filtered operations

**Commit:**
```
feat(04-01): apply tool filtering in parallel discovery
```

### Task 4: Block Disabled Tool Execution

**Type:** auto
**TDD:** true

**Behavior:**
1. Modify `cmd_call_tool()` to check if called tool matches disabledTools patterns:

   - For each server, check if called tool matches any `disabled_tools` pattern
   - If match found, return error message indicating tool is disabled
   - Error message should be clear and actionable

2. Apply same check before executing tool execution (after discovery)

3. Include detailed error message showing:
   - Server name
   - Tool name
   - Which pattern blocked it (if applicable)
   - Suggestion to remove tool from disabledTools

4. Test error message clarity and content

**Implementation:**
- Add filtering check in `cmd_call_tool()` before calling daemon
- Use existing `tool_matches_pattern()` function
- Format error message with context
- Return specific error type or formatted message

**Tests:**
```rust
#[test]
fn test_calling_disabled_tool_returns_error() {
    let config = Config {
        servers: vec![
            ServerConfig {
                name: "server1".to_string(),
                disabled_tools: vec!["password_*".to_string()],
                ..Default::default()
            }
        ],
        ..Default::default()
    };

    let result = cmd_call_tool(&config, "server1", "password_set", "{}").unwrap_err();
    assert!(result.to_string().contains("disabled") ||
            result.to_string().contains("blocked") ||
            result.to_string().contains("cannot execute"));
}

#[test]
fn test_calling_allowed_tool_works() {
    let config = Config {
        servers: vec![
            ServerConfig {
                name: "server1".to_string(),
                allowed_tools: vec!["list_*".to_string()],
                ..Default::default()
            }
        ],
        ..Default::default()
    };

    // Should work because "list_tools" matches "list_*"
    assert!(cmd_call_tool(&config, "server1", "list_tools", "{}").is_ok());
}
```

**Verification:**
- Disabled tools return appropriate error
- Error message is clear and actionable
- Allowed tools still execute normally
- No false positives (no errors for non-disabled tools)
- Error handling preserved from retry logic

**Commit:**
```
feat(04-01): block execution of disabled tools
```

### Task 5: Document Precedence Rules & CLI Support

**Type:** auto
**TDD:** false

**Behavior:**
1. Create comprehensive documentation for precedence rules:

   - If `disabledTools` is defined (non-empty), `disabledTools` takes precedence over `allowedTools`
   - If `disabledTools` is empty and `allowedTools` is defined, only allowed tools can be called
   - If both are empty, all tools are accessible (no filtering)

2. Add CLI command documentation:
   - Update `help` output to explain tool filtering options
   - Add help topic for "tool filtering"
   - Document configuration format for allowedTools/disabledTools

3. Add examples to README or wiki:
   - Example 1: Allowing all tools (allowedTools = ["*"])
   - Example 2: Blocking specific tools (disabledTools = ["password_*", "sudo_*"])
   - Example 3: Restricting to specific tools (allowedTools = ["list_*", "search_*"])

4. Update Config struct documentation with new fields

5. Test CLI help output includes filtering documentation

**Implementation:**
- Add help documentation for tool filtering
- Update README with examples
- Add inline documentation to Config struct
- Verify help text is clear

**Tests:**
```rust
#[test]
fn test_help_documentation_exists() {
    let config = Config::from_str("[mcp_servers.server]")
        .unwrap();

    // Check help text mentions filtering
    // This would be a manual verification check
}
```

**Verification:**
- Help output includes filtering documentation
- Precedence rules clearly documented
- Examples provided for common use cases
- README updated with filtering examples
- Config documentation includes new fields

**Commit:**
```
docs(04-01): document tool filtering precedence rules and CLI usage
```

## Verification

- All 5 tasks completed and committed
- FILT-01: Server configuration specifies glob patterns for allowedTools
- FILT-02: Server configuration specifies glob patterns for disabledTools
- FILT-03: disabledTools patterns take precedence when both fields defined
- FILT-04: User receives clear error message when attempting disabled tool
- FILT-05: Glob patterns support wildcards (*, ?) for flexible matching

## Success Criteria

1. ✅ User can configure glob patterns for allowedTools to restrict available tools
2. ✅ User can configure glob patterns for disabledTools to block specific tools
3. ✅ When both allowedTools and disabledTools defined, disabledTools takes precedence
4. ✅ User receives clear error message when attempting to call a disabled tool
5. ✅ Tool filtering supports glob patterns with wildcards (*, ?) for flexible matching

## Implementation Notes

- Glob pattern matching uses `glob` crate v0.3.x
- Case-insensitive matching recommended for better UX
- Empty configuration (both fields empty) means no filtering (backward compatible)
- Precedence rules follow security principle: deny by default when both present

## Technical Decisions

1. **`glob` crate for pattern matching:** Lightweight, well-tested, supports standard glob wildcards
2. **Case-insensitive matching:** Improves usability, consistent with shell behavior
3. **Precedence rule (disabled > allowed):** Security-first approach, prevents accidental tool access
4. **Backward compatibility:** Empty config fields default to no filtering
5. **Error message clarity:** Include server name, tool name, and pattern information

## Dependencies

- Phase 1: Config parsing infrastructure
- Phase 2: Connection daemon for tool execution
- Phase 3: Parallel execution for tool discovery

## Affects Future Phases

- CLI Support (CLI-05): Tool filtering features integrated into CLI commands
- Cross-Platform (XP-02, XP-04): Future validation will test filtering on all platforms

## Tech Stack Added

- `glob` crate v0.3.x - Glob pattern matching

## Files Modified

- `src/types/config.rs` - Added allowed_tools and disabled_tools fields
- `src/cli/filter.rs` - Created tool matching utility module
- `src/cli/commands.rs` - Applied filtering in list and search commands
- `README.md` - Added tool filtering documentation
- `.planning/phases/04-tool-filtering/04-01-PLAN.md` - This plan file

## Task Commits

- {hash}: feat(04-01): add tool filtering configuration fields
- {hash}: feat(04-01): implement glob pattern matching for tool names
- {hash}: feat(04-01): apply tool filtering in parallel discovery
- {hash}: feat(04-01): block execution of disabled tools
- {hash}: docs(04-01): document tool filtering precedence rules and CLI usage
