---
phase: 04-tool-filtering
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/windows_process_tests.rs
  - tests/windows_process_spawn_tests.rs
autonomous: true
must_haves:
  truths:
    - "Child processes spawned on Windows terminate cleanly when StdioTransport is dropped"
    - "No zombie processes remain after normal operation"
    - "Processes killed via kill_on_drop(true) terminate within timeout"
    - "Process handles are properly cleaned up on error paths"
  artifacts:
    - path: "tests/windows_process_tests.rs"
      provides: "Windows process spawning validation tests"
      min_lines: 150
    - path: "tests/windows_process_spawn_tests.rs"
      provides: "Integration tests for process lifecycle"
      min_lines: 100
  key_links:
    - from: "tests/windows_process_tests.rs"
      to: "src/client/stdio.rs"
      via: "imports StdioTransport"
      pattern: "use mcp_cli_rs::client::stdio::StdioTransport"
---

<objective>
Validate Windows process spawning to confirm no zombie processes occur (XP-01).

Purpose: Ensure tokio::process::Command with kill_on_drop(true) prevents zombie processes on Windows, which was a critical issue in the Bun implementation that this Rust rewrite aims to solve.

Output: Comprehensive test suite proving clean process termination on Windows.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md

@src/client/stdio.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Windows process spawning unit tests</name>
  <files>tests/windows_process_tests.rs</files>
  <action>
Create comprehensive unit tests for Windows process spawning validation:

1. **Test normal process lifecycle:**
   - Spawn a simple process (e.g., `cmd.exe /c echo test`)
   - Verify StdioTransport creation succeeds
   - Drop the StdioTransport
   - Wait up to 5 seconds and verify process has terminated (check process ID no longer exists)
   - Use `tasklist` on Windows or `ps` on Unix to verify

2. **Test kill_on_drop on early drop:**
   - Spawn a long-running process (e.g., `timeout 10` or `sleep 10`)
   - Drop StdioTransport immediately
   - Verify process is killed within 2 seconds
   - Confirm no zombie process remains

3. **Test multiple sequential spawns:**
   - Create 10 StdioTransport instances sequentially
   - Drop each immediately
   - Verify no orphaned processes after all 10 drops

4. **Test error path cleanup:**
   - Configure invalid command that fails to spawn
   - Verify no partial process handles remain
   - Check for cleanup on spawn failure

5. **Test signal handling:**
   - Spawn process with StdioTransport
   - Send simulated SIGTERM (Windows signal)
   - Verify clean termination

Use conditional compilation:
- `#[cfg(windows)]` for Windows-specific tests using `tasklist` command
- `#[cfg(unix)]` for Unix variants as sanity checks
- Mark tests as `#[ignore]` by default, use `cargo test -- --ignored` to run

Use tempfile crate for creating temporary test scripts if needed.
  </action>
  <verify>
Run `cargo test windows_process -- --ignored` and verify:
- All tests pass
- No zombie processes remain (manual verification via tasklist)
- Tests complete within 60 seconds total
  </verify>
  <done>All Windows process spawning tests pass, confirming XP-01: Windows process spawning has no zombie processes after execution.</done>
</task>

<task type="auto">
  <name>Task 2: Create integration tests for process cleanup</name>
  <files>tests/windows_process_spawn_tests.rs</files>
  <action>
Create integration tests for real-world process cleanup scenarios:

1. **Test CLI command execution:**
   - Simulate CLI calling a simple MCP server (mock server using Python or Node)
   - Execute tool call via StdioTransport
   - Verify clean shutdown after tool returns result
   - Check for no zombie processes

2. **Test concurrent process spawning:**
   - Spawn 5 processes simultaneously in parallel threads
   - Drop all transports randomly
   - Verify all processes terminated cleanly

3. **Test process timeout scenarios:**
   - Spawn process that never responds
   - Let tokio timeout trigger (30s timeout)
   - Verify process killed by timeout and drop
   - Confirm no zombie remains

4. **Test daemon process cleanup:**
   - Verify daemon process spawning uses kill_on_drop
   - Test daemon startup/shutdown cycles (3 iterations)
   - Confirm no orphaned daemon processes

These should be integration tests that exercise the actual StdioTransport implementation in realistic scenarios, not unit tests.

Use `tokio::test` for async tests, `tokio::spawn` for concurrent processes.
  </action>
  <verify>
Run `cargo test process_cleanup -- --ignored` and verify:
- All integration tests pass
- Process cleanup verified in concurrent scenarios
- Timeout scenarios result in clean process termination
- Daemon cycles produce no orphans
  </verify>
  <done>Integration tests confirm clean process cleanup in realistic CLI and daemon scenarios.</done>
</task>

</tasks>

<verification>
- All test files compile without errors
- Tests pass on Windows (primary validation platform)
- Tests also pass on Unix (sanity check)
- Manual verification: no zombie processes after test runs
- Test execution time: < 60 seconds total
  </verification>

<success_criteria>
1. Windows process spawning tests confirm kill_on_drop(true) prevents zombie processes
2. Normal process lifecycle terminates cleanly
3. Early drops (errors, timeouts) kill processes immediately
4. Multiple sequential spawns produce no orphans
5. Concurrent process spawning cleans up all processes
6. daemon lifecycle tests show no orphaned daemon processes
7. XP-01 verified: No zombie processes on Windows after execution
</success_criteria>

<output>
After completion, create `.planning/phases/04-tool-filtering/04-02-SUMMARY.md`
</output>
