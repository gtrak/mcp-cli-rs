---
phase: 04-tool-filtering
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/cross_platform_daemon_tests.rs
  - tests/daemon_lifecycle_tests.rs
autonomous: true
must_haves:
  truths:
    - "Connection daemon starts and connects on Linux"
    - "Connection daemon starts and connects on macOS"
    - "Connection daemon starts and connects on Windows"
    - "Unix socket IPC works correctly on Linux"
    - "Unix socket IPC works correctly on macOS"
    - "Named pipe IPC works correctly on Windows"
    - "Daemon self-terminates after 60-second idle timeout"
    - "Orphaned daemon processes and sockets are cleaned up on startup"
  artifacts:
    - path: "tests/cross_platform_daemon_tests.rs"
      provides: "Cross-platform IPC validation tests"
      min_lines: 200
    - path: "tests/daemon_lifecycle_tests.rs"
      provides: "Daemon lifecycle and cleanup validation"
      min_lines: 150
  key_links:
    - from: "tests/cross_platform_daemon_tests.rs"
      to: "src/ipc/mod.rs"
      via: "uses create_ipc_server and create_ipc_client"
      pattern: "use mcp_cli_rs::ipc::create_ipc_server"
    - from: "tests/cross_platform_daemon_tests.rs"
      to: "src/ipc/unix.rs"
      via: "conditional compilation for Unix sockets"
      pattern: "#\\[cfg\\(unix\\)\\]"
    - from: "tests/cross_platform_daemon_tests.rs"
      to: "src/ipc/windows.rs"
      via: "conditional compilation for named pipes"
      pattern: "#\\[cfg\\(windows\\)\\]"
---

<objective>
Validate connection daemon functionality across Linux, macOS, and Windows (XP-04).

Purpose: Ensure the daemon implemented in Phase 2 works correctly on all three major platforms with their respective IPC mechanisms (Unix sockets on *nix, named pipes on Windows). This validates cross-platform consistency and catches platform-specific bugs.

Output: Comprehensive cross-platform test suite proving daemon IPC works identically on Linux, macOS, and Windows.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md

@src/ipc/mod.rs
@src/ipc/unix.rs
@src/ipc/windows.rs
@src/cli/daemon.rs
@tests/ipc_tests.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create platform-specific IPC validation tests</name>
  <files>tests/cross_platform_daemon_tests.rs</files>
  <action>
Create comprehensive IPC validation tests that run on all platforms:

1. **Unix socket tests (Linux/macOS):**
   ```
   #[cfg(unix)]
   mod unix_socket_tests {
       - Test socket creation in /tmp directory
       - Test client connection to server socket
       - Test multiple concurrent connections (3 clients)
       - Test large message transfer over sockets (100KB)
       - Test server cleanup on socket path removal
       - Test StaleSocketError handling
   }
   ```

2. **Windows named pipe tests:**
   ```
   #[cfg(windows)]
   mod named_pipe_tests {
       - Test pipe creation with "\\\\.\\pipe\\mcp-test-*" naming
       - Test client connection to server pipe
       - Test multiple concurrent connections (3 clients)
       - Test large message transfer over pipes (100KB)
       - Test SECURITY_IDENTIFICATION flags applied
       - Test pipe cleanup on server shutdown
   }
   ```

3. **Cross-platform IPC trait tests:**
   - Test IpcServer trait methods work identically
   - Test IpcClient trait methods work identically
   - Test protocol (NDJSON) is consistent across platforms
   - Test error handling is consistent

Use conditional compilation to run platform-specific tests on the appropriate OS. All tests should verify:
- Successful connection establishment
- Request/response roundtrip works
- Multiple concurrent clients supported
- Large messages transfer correctly
- Clean shutdown without leaks

Reuse existing test patterns from tests/ipc_tests.rs but expand with more comprehensive scenarios.
  </action>
  <verify>
Run `cargo test cross_platform_ipc` and verify:
- Unix socket tests pass on Linux
- Unix socket tests pass on macOS
- Named pipe tests pass on Windows
- All platform-specific tests validate identical behavior
- No resource leaks (sockets/pipes cleaned up)
  </verify>
  <done>IPC validation tests confirm daemon communication works correctly on Linux, macOS, and Windows.</done>
</task>

<task type="auto">
  <name>Task 2: Create daemon lifecycle validation tests</name>
  <files>tests/daemon_lifecycle_tests.rs</files>
  <action>
Create daemon lifecycle tests for all platforms:

1. **Test daemon startup and connection:**
   ```
   #[tokio::test]
   async fn test_daemon_startup_connection() {
       - Start daemon with test config
       - Create client and connect
       - Send Ping request
       - Verify Pong response
       - Shutdown daemon cleanly
   }
   ```

2. **Test idle timeout (60-second default):**
   ```
   #[tokio::test]
   async fn test_daemon_idle_timeout() {
       - Start daemon with 2-second timeout (for faster test)
       - Connect client
       - Send no requests
       - Wait 3 seconds
       - Verify daemon has terminated (connection fails)
   }
   ```

3. **Test orphaned daemon cleanup:**
   ```
   #[tokio::test]
   async fn test_orphaned_daemon_cleanup() {
       - Manually create stale PID file
       - Manually create stale socket/pipe
       - Start new daemon
       - Verify orphan cleanup removes stale resources
       - Verify new daemon starts cleanly
   }
   ```

4. **Test config change detection:**
   ```
   #[tokio::test]
   async fn test_config_change_restart() {
       - Start daemon with config A
       - Modify config to config B (different fingerprint)
       - Connect client triggering restart
       - Verify new daemon with config B responds
       - Verify old daemon terminated
   }
   ```

5. **Test graceful shutdown:**
   ```
   #[tokio::test]
   async fn test_daemon_graceful_shutdown() {
       - Start daemon with active connection
       - Send shutdown signal
       - Verify daemon finishes current request then terminates
       - Verify socket/pipe cleaned up
   }
   ```

6. **Test cross-platform consistency:**
   Run all tests on Linux, macOS, Windows and compare:
   - Startup time variance < 2 seconds
   - Idle timeout variance < 1 second
   - Request/response latency variance < 100ms
   - Memory usage patterns similar

Use tokio::time::sleep for timing tests, tempfile for config files.
  </action>
  <verify>
Run `cargo test daemon_lifecycle` on each platform and verify:
- Daemon starts and connects successfully (all platforms)
- Idle timeout terminates daemon within expected window
- Orphan cleanup removes stale resources (all platforms)
- Config change triggers restart with new config
- Graceful shutdown completes cleanly
- Performance metrics consistent across platforms (Â±15% variance)
  </verify>
  <done>Daemon lifecycle tests confirm consistent behavior across Linux, macOS, and Windows with proper cleanup.</done>
</task>

</tasks>

<verification>
- All test files compile without errors
- Platform-specific tests run on correct OS (conditional compilation)
- Tests pass on Linux (all IPC and daemon tests)
- Tests pass on macOS (all IPC and daemon tests)
- Tests pass on Windows (all IPC and daemon tests)
- No resource leaks (manual verification: no orphan processes, sockets, pipes)
- Performance consistency verified across platforms
  </verification>

<success_criteria>
1. Unix socket IPC works correctly on Linux and macOS
2. Named pipe IPC works correctly on Windows
3. Daemon starts and connects on all three platforms
4. Multiple concurrent clients supported on all platforms
5. Idle timeout self-termination works identically on all platforms
6. Orphaned daemon cleanup works on all platforms
7. Config change detection triggers daemon restart on all platforms
8. Graceful shutdown works on all platforms
9. XP-04 verified: Connection daemon functions correctly on Linux, macOS, and Windows
</success_criteria>

<output>
After completion, create `.planning/phases/04-tool-filtering/04-03-SUMMARY.md`
</output>
