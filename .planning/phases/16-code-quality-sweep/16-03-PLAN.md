---
phase: 16-code-quality-sweep
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/error.rs
  - src/lib.rs
  - src/cli/mod.rs

must_haves:
  truths:
    - "Library code uses thiserror for rich error types"
    - "CLI code uses anyhow for error bubbling"
    - "Clear separation between library and CLI error handling"
  artifacts:
    - path: "src/error.rs"
      provides: "thiserror-based error types"
      contains: "thiserror"
    - path: "src/cli/mod.rs"
      provides: "anyhow for CLI error handling"
      contains: "anyhow"
---

<objective>
Establish consistent error handling patterns (QUAL-03).

Per CONTEXT.md decisions:
- Library code (src/lib/ modules): use thiserror for rich, specific error types
- CLI code (src/cli/ modules): use anyhow for bubbling up errors
- Keep separation clean

Output: Consistent error handling across codebase.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md (QUAL-03)
@.planning/ROADMAP.md (Phase 16)
@.planning/phases/16-code-quality-sweep/16-CONTEXT.md

**User Decisions from CONTEXT.md:**
- "Use thiserror for library code (src/lib/ modules) — rich, specific error types with context"
- "Use anyhow for CLI code (src/cli/ modules) — just bubble up errors that can't be recovered"
- "Keep the separation clean: library = thiserror, CLI = anyhow"
- "Per-module error types using thiserror - each library module defines its own error enum"
- "No global error type — keeps thiserror benefits (context, no crate coupling)"
</context>

<tasks>

<task type="auto">
  <name>Review current error handling in src/error.rs</name>
<files>src/error.rs</files>
<action>
Examine current error.rs:
1. Check if it uses thiserror or plain error types
2. Identify what error types exist
3. Determine if per-module errors are needed (per CONTEXT: "per-module error types using thiserror")
4. Plan migration to thiserror if not already using it

Current error types should be reviewed for thiserror adoption.
  </action>
  <verify>Check src/error.rs structure</verify>
  <done>Current error handling reviewed</done>
</task>

<task type="auto">
  <name>Add thiserror to library error types</name>
<files>src/error.rs, src/lib.rs</files>
<action>
If src/error.rs doesn't use thiserror:
1. Add `thiserror` to Cargo.toml dependencies
2. Refactor McpError to use thiserror::Error derive
3. Add context variants for common error scenarios

Note: The current codebase already has a working error type. Focus on improving it with thiserror if not already using it. Check if already using thiserror.
  </action>
  <verify>Cargo check passes with thiserror</verify>
  <done>Library errors use thiserror</done>
</task>

<task type="auto">
  <name>Verify CLI uses anyhow appropriately</name>
<files>src/cli/mod.rs, src/cli/*.rs</files>
<action>
Check CLI error handling:
1. Determine if CLI already uses anyhow or uses custom error types
2. If using custom types, consider migrating to anyhow for simpler error bubbling
3. Ensure CLI errors use anyhow::Result and ? operator

From CONTEXT.md: "anyhow for just bubbling up errors that can't be recovered"
  </action>
  <verify>Cargo check passes</verify>
  <done>CLI uses appropriate error handling</done>
</task>

</tasks>

<verification>
- `cargo check` passes
- Library uses thiserror where applicable
- CLI uses anyhow for error bubbling
</verification>

<success_criteria>
- [ ] Error handling reviewed and improved
- [ ] thiserror used for library code
- [ ] anyhow used for CLI code
- [ ] cargo check passes
</success_criteria>

<output>
After completion, create `.planning/phases/16-code-quality-sweep/16-03-SUMMARY.md`
</output>
