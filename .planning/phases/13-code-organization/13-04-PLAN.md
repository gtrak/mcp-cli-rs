---
phase: 13-code-organization
plan: 04
type: execute
wave: 2
depends_on: ["13-02"]
files_modified:
  - src/cli/daemon_lifecycle.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - Daemon lifecycle management extracted to src/cli/daemon_lifecycle.rs
    - main.rs imports daemon lifecycle functions
    - Functions: start_daemon, stop_daemon, run_auto_daemon_mode, run_require_daemon_mode
    - Daemon lifecycle is reusable and testable
    - main.rs size further reduced
  artifacts:
    - path: src/cli/daemon_lifecycle.rs
      provides: Daemon lifecycle management functions
      max_lines: 300
  key_links:
    - from: src/main.rs
      to: src/cli/daemon_lifecycle.rs
      via: use crate::cli::daemon_lifecycle::*
---

<objective>
Extract daemon lifecycle management from src/main.rs into src/cli/daemon_lifecycle.rs.

Purpose: Separate daemon management concerns from main.rs to reduce its size and improve modularity. This is part of main.rs refactoring (ORG-02).
Output: New daemon_lifecycle.rs module with extracted daemon functions.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-code-organization/13-CONTEXT.md
@src/main.rs
@src/cli/mod.rs
@src/cli/daemon.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Identify daemon lifecycle code in main.rs</name>
  <files>src/main.rs</files>
  <action>
Read src/main.rs and identify functions and code related to:
- run_auto_daemon_mode (around line 402)
- run_require_daemon_mode (around line 485)
- start_daemon function if exists
- stop_daemon function if exists
- Daemon startup logic
- Daemon shutdown logic
- Daemon connection management
- Any daemon-related helper structs (like DirectProtocolClient around line 608)

Look for patterns like:
- `run_auto_daemon_mode`
- `run_require_daemon_mode`
- `start_daemon`
- `stop_daemon`
- `DirectProtocolClient`
- `create_ipc_client`
- Daemon-related async blocks

Document line ranges and function signatures.
  </action>
  <verify>
grep -n "run_auto_daemon_mode\|run_require_daemon_mode\|DirectProtocolClient" src/main.rs
# Should show line numbers
grep -n "^pub async fn\|^async fn\|^fn" src/main.rs | head -20
# List all functions
  </verify>
  <done>Identified all daemon lifecycle functions in main.rs</done>
</task>

<task type="auto">
  <name>Task 2: Create src/cli/daemon_lifecycle.rs with extracted functions</name>
  <files>src/cli/daemon_lifecycle.rs</files>
  <action>
Create new file with:

```rust
//! Daemon lifecycle management for CLI.
//!
//! Provides functions for starting, stopping, and managing
the MCP daemon process lifecycle.

use crate::config::Config;
use crate::error::Result;
use crate::ipc::create_ipc_client;
use crate::ipc::ProtocolClient;
use std::path::PathBuf;
use std::sync::Arc;
use std::time::Duration;

/// Run command in auto-daemon mode (start daemon if needed).
///
/// # Arguments
/// * `config` - Application configuration
/// * `command` - Async closure to execute with daemon client
///
/// # Returns
/// * `Ok(T)` - Command result
/// * `Err(McpError)` - Daemon or command error
pub async fn run_auto_daemon_mode<F, T>(
    config: &Config,
    command: F,
) -> Result<T>
where
    F: FnOnce(Box<dyn ProtocolClient>) -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<T>>>>,
{
    // Implementation from main.rs
}

/// Run command requiring an existing daemon.
///
/// Fails if daemon is not already running.
pub async fn run_require_daemon_mode<F, T>(
    config: &Config,
    command: F,
) -> Result<T>
where
    F: FnOnce(Box<dyn ProtocolClient>) -> std::pin::Pin<Box<dyn std::future::Future<Output = Result<T>>>>,
{
    // Implementation from main.rs
}

/// Direct protocol client for no-daemon mode.
pub struct DirectProtocolClient {
    // Fields from main.rs
}

impl DirectProtocolClient {
    // Implementation from main.rs
}

impl ProtocolClient for DirectProtocolClient {
    // Implementation from main.rs
}
```

Extract implementations from main.rs. Target: ~250-350 lines.
  </action>
  <verify>
cat src/cli/daemon_lifecycle.rs | wc -l
# Should be 200-350 lines
grep -c "pub async fn run_auto_daemon_mode" src/cli/daemon_lifecycle.rs
# Should be 1
grep -c "pub async fn run_require_daemon_mode" src/cli/daemon_lifecycle.rs
# Should be 1
grep -c "pub struct DirectProtocolClient" src/cli/daemon_lifecycle.rs
# Should be 1
  </verify>
  <done>daemon_lifecycle.rs created with extracted daemon functions</done>
</task>

<task type="auto">
  <name>Task 3: Update src/cli/mod.rs to include daemon_lifecycle module</name>
  <files>src/cli/mod.rs</files>
  <action>
Add to src/cli/mod.rs:

```rust
pub mod daemon_lifecycle;

// Re-export daemon lifecycle functions
pub use daemon_lifecycle::{
    run_auto_daemon_mode,
    run_require_daemon_mode,
    DirectProtocolClient,
};
```

Place after existing module declarations but before the command modules.
  </action>
  <verify>
grep "pub mod daemon_lifecycle" src/cli/mod.rs
# Should find the line
cargo check --lib 2>&1 | grep -c "error"
# Should be 0
  </verify>
  <done>daemon_lifecycle module declared in cli/mod.rs</done>
</task>

<task type="auto">
  <name>Task 4: Update main.rs to use daemon_lifecycle module</name>
  <files>src/main.rs</files>
  <action>
In main.rs:
1. Add import: `use mcp_cli_rs::cli::daemon_lifecycle::{run_auto_daemon_mode, run_require_daemon_mode, DirectProtocolClient};`
2. Replace the extracted function implementations with calls or imports
3. Remove the extracted functions from main.rs
4. Keep main.rs focused on CLI argument parsing and top-level dispatch

The goal is to reduce main.rs by ~200-300 lines.

Key changes:
- Remove DirectProtocolClient struct and impl from main.rs
- Remove run_auto_daemon_mode function from main.rs
- Remove run_require_daemon_mode function from main.rs
- Import these from daemon_lifecycle module instead
  </action>
  <verify>
wc -l src/main.rs
# Should show further reduction from previous plans (target <500 lines total)
grep -c "run_auto_daemon_mode" src/main.rs
# Should be 0 (moved to module)
grep "use.*daemon_lifecycle" src/main.rs
# Should find the import
cargo check --bin mcp 2>&1 | tail -10
# Should show no errors
  </verify>
  <done>main.rs updated to use daemon_lifecycle, extracted code removed</done>
</task>

<task type="auto">
  <name>Task 5: Verify compilation and run tests</name>
  <files>src/main.rs, src/cli/daemon_lifecycle.rs</files>
  <action>
Run full verification:
1. cargo check --all-targets
2. cargo test --no-run

Check that daemon functionality still works:
- Daemon mode detection
- Auto-daemon spawning
- Direct mode (no-daemon)
- All daemon lifecycle states

If any errors, fix imports or function signatures.
  </action>
  <verify>
cargo check --all-targets 2>&1 | grep -E "^error" | wc -l
# Should be 0
cargo test --no-run 2>&1 | tail -5
# Should compile successfully
wc -l src/main.rs
# Should be reduced by ~200-300 lines from original 809
  </verify>
  <done>All targets compile, main.rs significantly reduced</done>
</task>

</tasks>

<verification>
After all tasks:
- [ ] src/cli/daemon_lifecycle.rs exists with daemon functions (200-350 lines)
- [ ] src/cli/mod.rs declares daemon_lifecycle module
- [ ] main.rs imports from daemon_lifecycle
- [ ] run_auto_daemon_mode and run_require_daemon_mode moved
- [ ] DirectProtocolClient moved
- [ ] main.rs reduced by ~200-300 lines
- [ ] cargo check passes with no errors
</verification>

<success_criteria>
- Daemon lifecycle logic extracted to dedicated module
- main.rs size significantly reduced
- All daemon functionality preserved
- All code compiles and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-code-organization/13-04-SUMMARY.md` documenting:
- Functions extracted
- Line count changes
- Module dependencies
</output>
