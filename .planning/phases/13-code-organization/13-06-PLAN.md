---
phase: 13-code-organization
plan: 06
type: execute
wave: 3
depends_on: ["13-02", "13-04", "13-05"]
files_modified:
  - src/cli/entry.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - CLI entry point extracted to src/cli/entry.rs
    - main.rs becomes thin wrapper only
    - Cli struct and main function in entry.rs
    - main.rs just calls entry::main()
    - Binary compiles and runs correctly
  artifacts:
    - path: src/cli/entry.rs
      provides: CLI entry point (Cli struct, main function)
      max_lines: 150
    - path: src/main.rs
      provides: Thin binary entry wrapper
      max_lines: 50
  key_links:
    - from: src/main.rs
      to: src/cli/entry.rs
      via: use crate::cli::entry::main as entry_main
---

<objective>
Extract CLI entry point from src/main.rs to src/cli/entry.rs, leaving main.rs as a thin wrapper.

Purpose: Complete main.rs refactoring by moving the entry point logic to a library module. This allows main.rs to be a minimal binary entry point (ORG-05).
Output: New entry.rs module with Cli struct and main logic, minimal main.rs.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-code-organization/13-CONTEXT.md
@src/main.rs (after 13-02, 13-04, 13-05 changes)
@src/cli/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Identify remaining entry point code in main.rs</name>
  <files>src/main.rs</files>
  <action>
Read main.rs and identify:
- Cli struct with derive(Parser)
- init_tracing function
- main() function
- run() function (if still exists here)
- Any other entry-level code

After previous extractions, main.rs should have:
- use statements
- Cli struct definition
- init_tracing function
- main() function
- Possibly a run() helper

Document what needs to move to entry.rs.
  </action>
  <verify>
cat src/main.rs
# View entire file after previous extractions
grep -n "struct Cli" src/main.rs
grep -n "fn main" src/main.rs
grep -n "fn init_tracing" src/main.rs
# Identify entry-level constructs
  </verify>
  <done>Identified all entry point code remaining in main.rs</done>
</task>

<task type="auto">
  <name>Task 2: Create src/cli/entry.rs with entry point</name>
  <files>src/cli/entry.rs</files>
  <action>
Create new file src/cli/entry.rs with CLI entry point structure.

Include:
- Module documentation header
- Imports (clap, crate modules, std)
- Cli struct with derive(Parser) and all fields
- init_tracing function
- pub async fn main() function
- Graceful shutdown wrapper if needed

Target: ~100-150 lines.
  </action>
  <verify>
cat src/cli/entry.rs | wc -l
# Should be 80-150 lines
grep "pub struct Cli" src/cli/entry.rs
# Should exist
grep "pub async fn main" src/cli/entry.rs
# Should exist
grep "pub fn init_tracing" src/cli/entry.rs
# Should exist
cargo check --lib 2>&1 | grep -c "error"
# Should be 0
  </verify>
  <done>entry.rs created with Cli struct and main function</done>
</task>

<task type="auto">
  <name>Task 3: Update src/cli/mod.rs to include entry module</name>
  <files>src/cli/mod.rs</files>
  <action>
Add to src/cli/mod.rs:

pub mod entry;

// Re-export main entry point
pub use entry::{Cli, main as entry_main, init_tracing};

This makes the entry point available as both a module and re-exported items.
  </action>
  <verify>
grep "pub mod entry" src/cli/mod.rs
# Should find the line
cargo check --lib 2>&1 | grep -c "error"
# Should be 0
  </verify>
  <done>entry module declared in cli/mod.rs</done>
</task>

<task type="auto">
  <name>Task 4: Reduce main.rs to thin wrapper</name>
  <files>src/main.rs</files>
  <action>
Replace entire src/main.rs with a thin wrapper that delegates to the library entry point.

The new main.rs should:
1. Import entry_main from cli::entry module
2. Import exit_code from error module
3. Define main() function that calls entry_main()
4. Handle exit codes appropriately

This should be approximately 20-50 lines.
  </action>
  <verify>
cat src/main.rs | wc -l
# Should be 20-50 lines (was 809 originally)
grep "entry_main" src/main.rs
# Should find the import and call
grep "async fn main" src/main.rs
# Should find main function
cargo check --bin mcp 2>&1 | tail -10
# Should show no errors
  </verify>
  <done>main.rs reduced to thin wrapper under 50 lines</done>
</task>

<task type="auto">
  <name>Task 5: Verify binary builds and runs</name>
  <files>src/main.rs, src/cli/entry.rs</files>
  <action>
Run verification:
1. cargo build --bin mcp
2. cargo run --bin mcp -- --help
3. Verify help output displays correctly
4. Verify no runtime errors

Test that the binary still works with basic commands.

Check that error handling works properly.
  </action>
  <verify>
cargo build --bin mcp 2>&1 | tail -5
# Should build successfully
./target/debug/mcp --help 2>&1 | head -10
# Should show help output
echo $?
# Should be 0
cargo test --no-run 2>&1 | tail -5
# Should compile tests
  </verify>
  <done>Binary builds and runs correctly</done>
</task>

<task type="auto">
  <name>Task 6: Final line count verification</name>
  <files>src/main.rs, src/cli/*.rs, src/config/*.rs</files>
  <action>
Verify all size requirements met:

Check all new/modified files are under 600 lines:
- commands.rs: under 300
- list.rs: under 600
- info.rs: under 600
- call.rs: under 600
- search.rs: under 600
- daemon_lifecycle.rs: under 350
- command_router.rs: under 350
- config_setup.rs: under 250
- entry.rs: under 150
- main.rs: under 50
- types.rs: under 300
- parser.rs: under 350
- validator.rs: under 200
- mod.rs (config): under 100

Use wc -l to verify each file.
  </action>
  <verify>
wc -l src/main.rs src/cli/*.rs src/config/*.rs 2>/dev/null
# All should be under 600 lines
# Verify no file exceeds limit
  </verify>
  <done>All files under 600 lines, refactoring complete</done>
</task>

</tasks>

<verification>
After all tasks:
- [ ] src/cli/entry.rs exists with Cli struct and main function (80-150 lines)
- [ ] src/cli/mod.rs declares entry module and re-exports
- [ ] src/main.rs is thin wrapper calling entry_main (20-50 lines)
- [ ] Binary builds successfully: cargo build --bin mcp
- [ ] Binary runs: cargo run --bin mcp -- --help
- [ ] All CLI files under 600 lines
- [ ] All config files under 600 lines
- [ ] main.rs under 100 lines
- [ ] cargo test compiles
</verification>

<success_criteria>
- Entry point extracted to entry.rs
- main.rs reduced to thin wrapper (under 50 lines)
- All modules under 600 lines
- Binary compiles and runs
- All tests pass
</success_criteria>

<output>
After completion, create .planning/phases/13-code-organization/13-06-SUMMARY.md documenting:
- Entry point extraction complete
- Final file sizes
- Main.rs now thin wrapper
</output>
