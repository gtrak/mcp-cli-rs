---
phase: 13-code-organization
plan: 05
type: execute
wave: 2
depends_on: ["13-02", "13-04"]
files_modified:
  - src/cli/command_router.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - Command routing logic extracted to src/cli/command_router.rs
    - main.rs imports command router
    - Functions: dispatch_command, run_command
    - Command match logic moved from main.rs
    - main.rs becomes minimal entry point
  artifacts:
    - path: src/cli/command_router.rs
      provides: Command routing and dispatch logic
      max_lines: 350
  key_links:
    - from: src/main.rs
      to: src/cli/command_router.rs
      via: use crate::cli::command_router::dispatch_command
---

<objective>
Extract command routing and dispatch logic from src/main.rs into src/cli/command_router.rs.

Purpose: Separate command routing from main.rs entry point, making main.rs a minimal wrapper. This is part of main.rs refactoring (ORG-03).
Output: New command_router.rs module with dispatch functions.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-code-organization/13-CONTEXT.md
@src/main.rs (after 13-02 and 13-04 changes)
@src/cli/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Identify command routing code in main.rs</name>
  <files>src/main.rs</files>
  <action>
Read main.rs (after previous extractions) and identify:
- Command match/dispatch logic (the big match on Commands enum)
- Any dispatch helper functions
- Command execution flow
- Command error handling at dispatch level

Look for patterns like:
- `match cli.command`
- `Commands::List { ... }`
- `Commands::Call { ... }`
- `Commands::Info { ... }`
- Command variant handling

This is typically the largest remaining chunk of main.rs after daemon and config extraction.

Document the command dispatch logic structure.
  </action>
  <verify>
grep -n "match cli.command\|match command\|Commands::" src/main.rs | head -30
# Should show dispatch logic
grep -n "^async fn\|^fn" src/main.rs
# List remaining functions
  </verify>
  <done>Identified command dispatch logic in main.rs</done>
</task>

<task type="auto">
  <name>Task 2: Create src/cli/command_router.rs with dispatch logic</name>
  <files>src/cli/command_router.rs</files>
  <action>
Create new file with:

```rust
//! Command routing and dispatch for CLI.
//!
//! Handles the main command dispatch logic, routing each CLI subcommand
//! to its appropriate handler.

use crate::cli::{
    call::cmd_call_tool,
    info::{cmd_server_info, cmd_tool_info},
    list::cmd_list_servers,
    search::cmd_search_tools,
    DetailLevel,
};
use crate::cli::daemon_lifecycle::{
    run_auto_daemon_mode, run_require_daemon_mode, DirectProtocolClient,
};
use crate::cli::config_setup::setup_config;
use crate::config::Config;
use crate::error::Result;
use crate::format::OutputMode;
use crate::ipc::ProtocolClient;

/// Dispatch a CLI command to its handler.
///
/// # Arguments
/// * `command` - The CLI subcommand to execute
/// * `config` - Application configuration
///
/// # Returns
/// * `Ok(())` - Command executed successfully
/// * `Err(McpError)` - Command execution error
pub async fn dispatch_command(
    command: Commands,
    config: &Config,
) -> Result<()> {
    match command {
        Commands::List { describe, verbose } => {
            let detail_level = if verbose {
                DetailLevel::Verbose
            } else if describe {
                DetailLevel::Describe
            } else {
                DetailLevel::None
            };
            run_auto_daemon_mode(config, |daemon| {
                Box::pin(async move {
                    cmd_list_servers(daemon, detail_level, OutputMode::Human).await
                })
            }).await
        }
        Commands::Info { name } => {
            // Similar dispatch pattern
        }
        Commands::Call { tool, args } => {
            // Similar dispatch pattern
        }
        Commands::Search { pattern } => {
            // Similar dispatch pattern
        }
        // ... other commands
    }
}

/// Commands enum (moved from main.rs or re-exported)
#[derive(Clone, clap::Subcommand)]
pub enum Commands {
    /// List all servers and their available tools
    List {
        #[arg(short = 'd', long)]
        describe: bool,
        #[arg(short = 'v', long)]
        verbose: bool,
    },
    /// Show details for a specific server
    Info {
        name: String,
    },
    /// Show details for a specific tool
    Tool {
        tool: String,
        #[arg(short = 'd', long)]
        describe: bool,
        #[arg(short = 'v', long)]
        verbose: bool,
    },
    /// Execute a tool
    Call {
        tool: String,
        args: Option<String>,
    },
    /// Search for tools
    Search {
        pattern: String,
    },
    // ... other variants
}
```

Note: If Commands enum is defined in main.rs with #[derive(clap::Subcommand)], it needs to move here OR be re-exported. The Cli struct with #[derive(Parser)] typically stays in main.rs or entry.rs.

Target: ~250-350 lines for dispatch logic.
  </action>
  <verify>
cat src/cli/command_router.rs | wc -l
# Should be 250-350 lines
grep -c "pub async fn dispatch_command" src/cli/command_router.rs
# Should be 1
grep "pub enum Commands" src/cli/command_router.rs
# Should find Commands enum
cargo check --lib 2>&1 | grep -c "error"
# Should be 0
  </verify>
  <done>command_router.rs created with dispatch logic</done>
</task>

<task type="auto">
  <name>Task 3: Update src/cli/mod.rs to include command_router</name>
  <files>src/cli/mod.rs</files>
  <action>
Add to src/cli/mod.rs:

```rust
pub mod command_router;

// Re-export Commands enum if it moved
pub use command_router::Commands;
```

Add after daemon_lifecycle declaration.
  </action>
  <verify>
grep "pub mod command_router" src/cli/mod.rs
# Should find the line
cargo check --lib 2>&1 | grep -c "error"
# Should be 0
  </verify>
  <done>command_router module declared in cli/mod.rs</done>
</task>

<task type="auto">
  <name>Task 4: Update main.rs to use command_router</name>
  <files>src/main.rs</files>
  <action>
In main.rs:
1. Update import to use Commands from command_router:
   `use mcp_cli_rs::cli::command_router::{Commands, dispatch_command};`
2. Remove Commands enum definition from main.rs (or mark as re-export)
3. Replace inline command dispatch with call to dispatch_command
4. Remove the large match block from main.rs

Before extraction, main.rs had command dispatch inline. After:
```rust
// In main.rs
async fn run(cli: Cli) -> Result<()> {
    let config = setup_config(cli.config).await?;
    if let Some(command) = cli.command {
        dispatch_command(command, &config).await
    } else {
        // Show help or default behavior
        Ok(())
    }
}
```

The goal is to reduce main.rs by ~150-250 lines.
  </action>
  <verify>
wc -l src/main.rs
# Should be significantly reduced (target <300 lines total)
grep -c "dispatch_command" src/main.rs
# Should be 1 (the call, not definition)
grep "Commands" src/main.rs | head -5
# Should show import, not definition
cargo check --bin mcp 2>&1 | tail -10
# Should show no errors
  </verify>
  <done>main.rs updated to use command_router dispatch</done>
</task>

<task type="auto">
  <name>Task 5: Verify main.rs is now minimal entry point</name>
  <files>src/main.rs</files>
  <action>
Verify main.rs structure is now minimal:

```rust
// Should look like:
use clap::Parser;
use mcp_cli_rs::cli::command_router::{dispatch_command, Commands};
use mcp_cli_rs::cli::config_setup::setup_config;
// ... other imports

#[derive(Parser)]
#[command(name = "mcp")]
// ... Cli struct definition (kept here or moved to entry.rs in next plan)

#[tokio::main]
async fn main() {
    // Error handling wrapper
    // Setup config
    // Dispatch command
}

async fn run(cli: Cli) -> Result<()> {
    // Minimal logic calling dispatch_command
}
```

Check line count. Target for main.rs after all extractions: ~200-300 lines.
  </action>
  <verify>
wc -l src/main.rs
# Should be 200-400 lines (originally 809)
cat src/main.rs | head -50
# Should show minimal structure
  </verify>
  <done>main.rs is now minimal entry point</done>
</task>

<task type="auto">
  <name>Task 6: Verify compilation and test</name>
  <files>src/main.rs, src/cli/command_router.rs</files>
  <action>
Run full verification:
1. cargo check --all-targets
2. cargo test --no-run
3. Verify all commands still dispatch correctly

Test that command routing works:
- List command routes to cmd_list_servers
- Info command routes to cmd_server_info
- Call command routes to cmd_call_tool
- Search command routes to cmd_search_tools

If any routing errors, fix the dispatch match arms.
  </action>
  <verify>
cargo check --all-targets 2>&1 | grep -E "^error" | wc -l
# Should be 0
cargo test --no-run 2>&1 | tail -5
# Should compile successfully
echo "Line counts:"
wc -l src/main.rs src/cli/command_router.rs
# main.rs should be <400, command_router.rs <400
  </verify>
  <done>All targets compile, routing works correctly</done>
</task>

</tasks>

<verification>
After all tasks:
- [ ] src/cli/command_router.rs exists with dispatch logic (250-350 lines)
- [ ] Commands enum defined in command_router.rs or properly re-exported
- [ ] dispatch_command function routes all commands
- [ ] src/cli/mod.rs declares command_router module
- [ ] main.rs imports Commands and dispatch_command
- [ ] main.rs no longer has large command match block
- [ ] main.rs reduced by ~150-250 lines
- [ ] cargo check passes with no errors
</verification>

<success_criteria>
- Command routing extracted to dedicated module
- main.rs significantly reduced
- All command dispatch preserved
- All code compiles and tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/13-code-organization/13-05-SUMMARY.md` documenting:
- Routing logic extracted
- Line count changes
- Commands enum location
</output>
