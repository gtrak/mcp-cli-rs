---
phase: 07-json-output-machine-readable
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified: [src/cli/commands.rs, src/daemon/protocol.rs]
autonomous: true

must_haves:
  truths:
    - "list command outputs JSON when --json flag is used"
    - "info command outputs JSON when --json flag is used"
    - "search command outputs JSON when --json flag is used"
    - "JSON output includes complete tool metadata"
  artifacts:
    - path: "src/cli/commands.rs"
      provides: "JSON output for list, info, search commands"
      patterns: ["OutputMode::Json", "print_json"]
    - path: "src/daemon/protocol.rs"
      provides: "Serializable tool and server structures"
      contains: "#[derive.*Serialize]"
  key_links:
    - from: "cmd_list_servers"
      to: "print_json"
      via: "OutputMode::Json branch"
    - from: "ToolInfo"
      to: "JSON serialization"
      via: "Serialize derive"
---

<objective>
Implement JSON output for discovery commands (list, info, search).

Purpose: Enable scripts to parse tool listings programmatically with consistent JSON schema.
Output: list, info, and search commands support --json flag with complete metadata.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/07-json-output-machine-readable/07-01-SUMMARY.md
@.planning/REQUIREMENTS.md (OUTP-07, OUTP-08, OUTP-10)

Phase 7-01 provides OutputMode enum and --json flag infrastructure. Commands currently output human-readable text only. ToolInfo and related structures need Serialize derives for JSON output.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Serialize derives to protocol types</name>
  <files>src/daemon/protocol.rs</files>
  <action>
Add serde::Serialize derive to protocol types in src/daemon/protocol.rs:

1. Find ToolInfo struct and add Serialize derive:
```rust
#[derive(Debug, Clone, Serialize)]
pub struct ToolInfo {
    pub name: String,
    pub description: String,
    pub input_schema: serde_json::Value,
}
```

2. Create a serializable ServerInfo struct for list output:
```rust
/// Server information for JSON output
#[derive(Debug, Clone, Serialize)]
pub struct ServerInfo {
    pub name: String,
    pub status: String, // "connected", "failed"
    pub tool_count: usize,
    pub tools: Vec<ToolInfo>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
}
```

3. Create a ListOutput struct for consistent schema:
```rust
/// Top-level structure for list command JSON output
#[derive(Debug, Serialize)]
pub struct ListOutput {
    pub servers: Vec<ServerInfo>,
    pub total_servers: usize,
    pub connected_servers: usize,
    pub failed_servers: usize,
    pub total_tools: usize,
}
```

4. Similarly create SearchOutput and ToolDetailOutput structs.

Ensure all necessary imports are present (serde::Serialize).
  </action>
  <verify>cargo check passes</verify>
  <done>Protocol types have Serialize derives, output structs created</done>
</task>

<task type="auto">
  <name>Task 2: Implement JSON output for list command</name>
  <files>src/cli/commands.rs</files>
  <action>
Modify cmd_list_servers in src/cli/commands.rs to support JSON output:

1. Update function signature to accept OutputMode:
```rust
pub async fn cmd_list_servers(
    mut daemon: Box<dyn ProtocolClient>, 
    detail_level: DetailLevel,
    output_mode: OutputMode,
) -> Result<()>
```

2. At the start of the function, handle JSON mode:
```rust
if output_mode == OutputMode::Json {
    return cmd_list_servers_json(daemon).await;
}
```

3. Create new async function cmd_list_servers_json that:
   - Gathers all server and tool data (same as human version)
   - Builds ListOutput struct with complete metadata
   - Calls print_json(&output)
   - Returns Ok(())

4. The JSON output must include:
   - All servers with their connection status
   - All tools with complete metadata (name, description, input_schema)
   - Summary statistics (total_servers, connected_servers, etc.)
   - Error information for failed servers

5. Ensure the existing human-readable code path remains unchanged.
  </action>
  <verify>cargo check passes, both code paths compile</verify>
  <done>list command has separate JSON implementation with complete metadata</done>
</task>

<task type="auto">
  <name>Task 3: Implement JSON output for info and search commands</name>
  <files>src/cli/commands.rs</files>
  <action>
Update cmd_tool_info and cmd_search_tools to support JSON output:

1. Update cmd_tool_info signature:
```rust
pub async fn cmd_tool_info(
    mut daemon: Box<dyn ProtocolClient>, 
    tool_id: &str, 
    detail_level: DetailLevel,
    output_mode: OutputMode,
) -> Result<()>
```

2. Add JSON branch that outputs complete tool information:
   - Tool name, description
   - Server name
   - Complete input_schema
   - Parameter details extracted from schema

3. Update cmd_search_tools signature similarly.

4. Add JSON branch for search that outputs:
   - Search pattern used
   - Total matches
   - Array of matches with server name, tool name, description
   - Failed servers (if any)

5. Update all call sites in src/main.rs to pass output_mode.

6. Create consistent output structures:
```rust
#[derive(Serialize)]
struct ToolDetailOutput {
    name: String,
    description: String,
    server: String,
    parameters: Vec<ParameterDetail>,
    input_schema: serde_json::Value,
}

#[derive(Serialize)]
struct SearchOutput {
    pattern: String,
    total_matches: usize,
    matches: Vec<SearchMatch>,
    failed_servers: Vec<String>,
}
```
  </action>
  <verify>cargo check passes</verify>
  <done>info and search commands support JSON output with complete metadata</done>
</task>

</tasks>

<verification>
- [ ] `cargo check` passes without errors
- [ ] `cargo build` succeeds
- [ ] All commands compile with new signatures
- [ ] Serialize derives present on protocol types
- [ ] Output structs created for JSON serialization
</verification>

<success_criteria>
1. list, info, and search commands accept OutputMode parameter
2. JSON output path exists for all three commands
3. Protocol types implement Serialize
4. JSON output includes complete metadata as per OUTP-08
5. Human-readable output is unchanged when --json not used
</success_criteria>

<output>
After completion, create `.planning/phases/07-json-output-machine-readable/07-02-SUMMARY.md`
</output>
