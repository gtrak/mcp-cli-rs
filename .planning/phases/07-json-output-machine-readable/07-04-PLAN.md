---
phase: 07-json-output-machine-readable
plan: 04
type: execute
wave: 3
depends_on: [07-02, 07-03]
files_modified: []
autonomous: true

must_haves:
  truths:
    - "All commands produce valid JSON when --json flag is used"
    - "JSON schema is consistent across list, info, search, call commands"
    - "Plain text mode works correctly when stdout is not a TTY"
  artifacts:
    - path: "tests/json_output_tests.rs" (new)
      provides: "JSON output verification tests"
      contains: ["test_list_json", "test_call_json"]
  key_links:
    - from: "--json flag"
      to: "JSON output"
      via: "OutputMode::Json"
    - from: "TTY detection"
      to: "NO_COLOR"
      via: "output::use_color()"
---

<objective>
Verify JSON output works correctly across all commands and ensure plain text mode compliance.

Purpose: Validate OUTP-07 through OUTP-10 requirements are met.
Output: Working JSON output on all commands, tests verify behavior.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/07-json-output-machine-readable/07-01-SUMMARY.md
@.planning/phases/07-json-output-machine-readable/07-02-SUMMARY.md
@.planning/phases/07-json-output-machine-readable/07-03-SUMMARY.md
@.planning/REQUIREMENTS.md (OUTP-09 - plain text mode)

All commands now have JSON output support. Need to verify:
1. JSON output is valid and parseable
2. Schema is consistent
3. Plain text mode works when piped (OUTP-09)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create JSON output integration tests</name>
  <files>tests/json_output_tests.rs</files>
  <action>
Create integration tests for JSON output functionality:

```rust
//! Integration tests for JSON output mode
//!
//! Tests verify that --json flag produces valid, parseable JSON output
//! across all commands.

use std::process::Command;

/// Helper to run the CLI and capture JSON output
fn run_json_command(args: &[&str]) -> Result<serde_json::Value, String> {
    let output = Command::new("cargo")
        .args(&["run", "--"])
        .args(args)
        .args(&["--json"])
        .output()
        .map_err(|e| format!("Failed to run command: {}", e))?;
    
    if !output.status.success() {
        return Err(format!(
            "Command failed: {}",
            String::from_utf8_lossy(&output.stderr)
        ));
    }
    
    let stdout = String::from_utf8_lossy(&output.stdout);
    serde_json::from_str(&stdout)
        .map_err(|e| format!("Invalid JSON output: {}\nOutput: {}", e, stdout))
}

#[test]
fn test_list_json_schema() {
    // Test that list --json produces valid JSON with expected structure
    let result = run_json_command(&["list"]);
    
    // Skip if no config (expected in test environment)
    let json = match result {
        Ok(j) => j,
        Err(e) if e.contains("No servers configured") => return,
        Err(e) => panic!("Unexpected error: {}", e),
    };
    
    // Verify structure
    assert!(json.get("servers").is_some(), "Missing 'servers' field");
    assert!(json.get("total_servers").is_some(), "Missing 'total_servers' field");
    assert!(json.get("total_tools").is_some(), "Missing 'total_tools' field");
}

#[test]
fn test_list_json_with_mock_config() {
    // Create a temporary config file for testing
    use std::io::Write;
    use tempfile::NamedTempFile;
    
    let config_content = r#"
[[servers]]
name = "test-server"
command = "echo"
args = ["test"]
"#;
    
    let mut temp_file = NamedTempFile::new().unwrap();
    temp_file.write_all(config_content.as_bytes()).unwrap();
    
    let output = Command::new("cargo")
        .args(&["run", "--", "-c"])
        .arg(temp_file.path())
        .args(&["list", "--json"])
        .output()
        .expect("Failed to run command");
    
    // Just verify it produces valid JSON (may be empty servers if echo doesn't respond)
    let stdout = String::from_utf8_lossy(&output.stdout);
    if !stdout.trim().is_empty() {
        let json: serde_json::Value = serde_json::from_str(&stdout)
            .expect(&format!("Invalid JSON: {}", stdout));
        assert!(json.get("servers").is_some());
    }
}

#[test]
fn test_json_no_color_interference() {
    // Verify that JSON output doesn't include ANSI color codes
    let output = Command::new("cargo")
        .args(&["run", "--", "list", "--json"])
        .env("NO_COLOR", "1")
        .output()
        .expect("Failed to run command");
    
    let stdout = String::from_utf8_lossy(&output.stdout);
    
    // Check for ANSI escape sequences
    assert!(!stdout.contains('\u{001b}'), "JSON output contains ANSI codes: {}", stdout);
}

#[test]
fn test_plain_text_when_piped() {
    // Verify plain text mode works when stdout is not a TTY
    // This is harder to test in Rust, but we can verify the flag logic
    use mcp_cli_rs::format::OutputMode;
    
    assert!(OutputMode::from_flags(false).is_human());
    assert!(OutputMode::from_flags(true).is_json());
}
```

Create the tests directory if it doesn't exist and add the test file.
  </action>
  <verify>cargo test --test json_output_tests passes or skips appropriately</verify>
  <done>Integration tests exist and verify JSON output functionality</done>
</task>

<task type="auto">
  <name>Task 2: Verify plain text mode compliance (OUTP-09)</name>
  <files>src/output.rs</files>
  <action>
Verify and ensure plain text mode works correctly:

1. Review the existing `use_color()` function in src/output.rs - it should already handle:
   - NO_COLOR environment variable
   - TTY detection

2. Ensure JSON output mode automatically disables colors:
   - When OutputMode::Json is used, no color codes should appear in output
   - The print_json function should not use any coloring

3. Add explicit test in output module if needed:
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_json_output_no_colors() {
        // Verify print_json doesn't add color codes
        let value = serde_json::json!({"test": "value"});
        // This is harder to test since it prints to stdout,
        // but we can at least verify it doesn't panic
        print_json(&value);
    }
}
```

4. Document the behavior in module docs:
   - JSON mode never uses colors
   - Human mode respects NO_COLOR and TTY detection

5. Run manual verification:
   ```bash
   # Should have colors (if TTY)
   cargo run -- list
   
   # Should NOT have colors
   NO_COLOR=1 cargo run -- list
   
   # Should be valid JSON without color codes
   cargo run -- list --json
   
   # Should be valid JSON without color codes
   cargo run -- list --json | cat
   ```
  </action>
  <verify>Manual verification shows no color codes in JSON output</verify>
  <done>Plain text mode verified, JSON output never contains color codes</done>
</task>

<task type="auto">
  <name>Task 3: Document JSON schema</name>
  <files>docs/json-schema.md (new)</files>
  <action>
Create documentation for the JSON output schema:

```markdown
# JSON Output Schema

The MCP CLI supports JSON output mode via the `--json` flag for programmatic use.

## Usage

Add `--json` to any command:

```bash
mcp list --json
mcp info server/tool --json
mcp call server/tool '{"arg": "value"}' --json
mcp search "pattern" --json
```

## Schema Reference

### List Command

```json
{
  "servers": [
    {
      "name": "server-name",
      "status": "connected",
      "tool_count": 5,
      "tools": [
        {
          "name": "tool-name",
          "description": "Tool description",
          "input_schema": { ... }
        }
      ],
      "error": null
    }
  ],
  "total_servers": 1,
  "connected_servers": 1,
  "failed_servers": 0,
  "total_tools": 5
}
```

### Info Command

```json
{
  "name": "tool-name",
  "description": "Tool description",
  "server": "server-name",
  "parameters": [
    {
      "name": "param-name",
      "param_type": "string",
      "required": true,
      "description": "Parameter description"
    }
  ],
  "input_schema": { ... }
}
```

### Call Command (Success)

```json
{
  "server": "server-name",
  "tool": "tool-name",
  "status": "success",
  "result": { ... },
  "metadata": {
    "timestamp": "2026-02-10T10:30:00Z",
    "retry_count": null
  }
}
```

### Call Command (Error)

```json
{
  "server": "server-name",
  "tool": "tool-name",
  "status": "error",
  "error": {
    "message": "Error description",
    "code": 123
  },
  "metadata": {
    "timestamp": "2026-02-10T10:30:00Z"
  }
}
```

### Search Command

```json
{
  "pattern": "search-pattern",
  "total_matches": 3,
  "matches": [
    {
      "server": "server-name",
      "tool": "tool-name",
      "description": "Tool description"
    }
  ],
  "failed_servers": []
}
```

## Notes

- JSON output never includes ANSI color codes
- Schema is consistent across all commands
- All timestamps are in ISO 8601 format (UTC)
- Optional fields are omitted when null (using `skip_serializing_if`)
```

Create docs directory if it doesn't exist and add the file.
  </action>
  <verify>Documentation file exists and is complete</verify>
  <done>JSON schema documentation created</done>
</task>

</tasks>

<verification>
- [ ] `cargo test --test json_output_tests` passes
- [ ] JSON output contains no ANSI color codes
- [ ] Documentation exists explaining JSON schema
- [ ] All commands support --json flag
- [ ] Manual testing shows working JSON output
</verification>

<success_criteria>
1. All four commands (list, info, search, call) produce valid JSON with --json flag
2. JSON schema is documented and consistent
3. Plain text mode respects NO_COLOR and TTY detection (OUTP-09)
4. Integration tests verify JSON output behavior
5. OUTP-07, OUTP-08, OUTP-09, OUTP-10 requirements are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/07-json-output-machine-readable/07-04-SUMMARY.md`
</output>
