---
phase: 07-json-output-machine-readable
plan: 03
type: execute
wave: 2
depends_on: [07-01]
files_modified: [src/cli/commands.rs]
autonomous: true

must_haves:
  truths:
    - "call command outputs JSON when --json flag is used"
    - "JSON output includes tool execution result"
    - "Error responses are valid JSON"
  artifacts:
    - path: "src/cli/commands.rs"
      provides: "JSON output for call command"
      patterns: ["cmd_call_tool.*output_mode", "OutputMode::Json"]
    - path: "src/cli/commands.rs"
      provides: "ToolResult output struct"
      contains: "struct ToolResult"
  key_links:
    - from: "cmd_call_tool"
      to: "print_json"
      via: "JSON output branch"
    - from: "tool execution result"
      to: "JSON serialization"
      via: "ToolResult struct"
---

<objective>
Implement JSON output for tool execution (call command) with consistent schema.

Purpose: Enable scripts to capture and parse tool execution results programmatically.
Output: call command supports --json flag, outputs structured execution results.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/07-json-output-machine-readable/07-01-SUMMARY.md
@.planning/phases/07-json-output-machine-readable/07-02-SUMMARY.md
@.planning/REQUIREMENTS.md (OUTP-07, OUTP-08, OUTP-10)

Phase 7-01 and 7-02 provide infrastructure and discovery command implementations. Call command is the remaining major command needing JSON support.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define tool result output structures</name>
  <files>src/cli/commands.rs</files>
  <action>
Add output structures for tool execution JSON format in src/cli/commands.rs:

```rust
/// Tool execution result for JSON output
#[derive(Debug, Serialize)]
pub struct ToolResult {
    /// Server name
    pub server: String,
    /// Tool name
    pub tool: String,
    /// Execution status
    pub status: String, // "success" or "error"
    /// Execution result (present on success)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub result: Option<serde_json::Value>,
    /// Error details (present on error)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<ToolError>,
    /// Execution metadata
    pub metadata: ExecutionMetadata,
}

/// Error details for failed tool execution
#[derive(Debug, Serialize)]
pub struct ToolError {
    /// Error message
    pub message: String,
    /// Error code if available
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<i64>,
}

/// Execution metadata
#[derive(Debug, Serialize)]
pub struct ExecutionMetadata {
    /// Timestamp of execution (ISO 8601 format)
    pub timestamp: String,
    /// Number of retry attempts (if applicable)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retry_count: Option<u32>,
}
```

Add necessary imports for Serialize and chrono (if not already present). If chrono is not available, use a simple string timestamp format.
  </action>
  <verify>cargo check passes</verify>
  <done>ToolResult, ToolError, ExecutionMetadata structs defined</done>
</task>

<task type="auto">
  <name>Task 2: Implement JSON output for call command</name>
  <files>src/cli/commands.rs</files>
  <action>
Modify cmd_call_tool to support JSON output:

1. Update function signature:
```rust
pub async fn cmd_call_tool(
    mut daemon: Box<dyn ProtocolClient>, 
    tool_id: &str, 
    args_json: Option<&str>,
    output_mode: OutputMode,
) -> Result<()>
```

2. For JSON output mode:
   - Skip all human-readable output (colors, formatting)
   - Execute tool normally
   - Build ToolResult struct with:
     - server: server_name
     - tool: tool_name
     - status: "success" or "error"
     - result: the JSON result from tool execution (on success)
     - error: ToolError with message and optional code (on failure)
     - metadata: timestamp and retry_count
   - Call print_json(&result)

3. JSON output must be valid even for errors - don't print error messages to stdout, include them in the JSON structure.

4. Example success output:
```json
{
  "server": "filesystem",
  "tool": "read_file",
  "status": "success",
  "result": {
    "content": [{"type": "text", "text": "file contents"}]
  },
  "metadata": {
    "timestamp": "2026-02-10T10:30:00Z"
  }
}
```

5. Example error output:
```json
{
  "server": "filesystem",
  "tool": "read_file",
  "status": "error",
  "error": {
    "message": "File not found: /path/to/file",
    "code": null
  },
  "metadata": {
    "timestamp": "2026-02-10T10:30:00Z"
  }
}
```
  </action>
  <verify>cargo check passes</verify>
  <done>call command outputs structured JSON for both success and error cases</done>
</task>

<task type="auto">
  <name>Task 3: Update main.rs call sites</name>
  <files>src/main.rs</files>
  <action>
Update all command handler call sites in src/main.rs execute_command function:

1. Update Commands::List handler to pass output_mode
2. Update Commands::Info handler - currently doesn't have output_mode
3. Update Commands::Tool handler to pass output_mode
4. Update Commands::Call handler to pass output_mode
5. Update Commands::Search handler to pass output_mode
6. Update default (None) case to pass output_mode

For Commands::Info (server info), also add JSON support:
- Create ServerDetailOutput struct
- In JSON mode, output server configuration details as JSON
- Include server name, transport type, transport details

Ensure all branches compile correctly after signature changes from plans 07-01 and 07-02.
  </action>
  <verify>cargo build passes</verify>
  <done>All command handlers pass output_mode, server info has JSON support</done>
</task>

</tasks>

<verification>
- [ ] `cargo build` passes without errors
- [ ] All commands accept and use output_mode parameter
- [ ] ToolResult structures are serializable
- [ ] Call command has separate JSON code path
</verification>

<success_criteria>
1. call command accepts OutputMode parameter
2. JSON output includes complete execution result or error details
3. Error cases produce valid JSON (not text to stdout)
4. All commands have consistent JSON schema approach
5. Server info command also supports JSON output
</success_criteria>

<output>
After completion, create `.planning/phases/07-json-output-machine-readable/07-03-SUMMARY.md`
</output>
