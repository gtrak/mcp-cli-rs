---
phase: 07-json-output-machine-readable
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/main.rs, src/output.rs, src/format/mod.rs]
autonomous: true

must_haves:
  truths:
    - "User can add --json flag to any command"
    - "JSON flag is defined as global CLI argument"
    - "Output mode is passed through to all commands"
  artifacts:
    - path: "src/main.rs"
      provides: "--json global flag in Cli struct"
      contains: "json: bool"
    - path: "src/format/mod.rs"
      provides: "OutputMode enum"
      exports: ["OutputMode"]
    - path: "src/output.rs"
      provides: "JSON output helper functions"
      exports: ["print_json"]
  key_links:
    - from: "src/main.rs"
      to: "OutputMode"
      via: "import from format module"
    - from: "Commands"
      to: "output mode"
      via: "passed to command handlers"
---

<objective>
Add --json flag infrastructure to CLI and create output mode abstraction.

Purpose: Enable JSON output mode across all commands by adding the global flag and output mode infrastructure.
Output: CLI accepts --json flag, OutputMode enum tracks output format preference.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md (Phase 7 requirements OUTP-07, OUTP-09)
@.planning/REQUIREMENTS.md (OUTP-07, OUTP-09)

The codebase already uses serde/serde_json. Output formatting utilities exist in src/output.rs with NO_COLOR support. The CLI uses clap derive macros in src/main.rs.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OutputMode enum to format module</name>
  <files>src/format/mod.rs</files>
  <action>
Add an `OutputMode` enum to src/format/mod.rs that tracks whether output should be human-readable or JSON:

```rust
/// Output format mode for CLI commands
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum OutputMode {
    /// Human-readable output with colors (when TTY)
    Human,
    /// Machine-readable JSON output
    Json,
}

impl OutputMode {
    /// Determine output mode from CLI flags and environment
    /// 
    /// Priority:
    /// 1. --json flag forces JSON mode
    /// 2. If not TTY and not explicitly human, could consider JSON (but keep human as default)
    pub fn from_flags(json_flag: bool) -> Self {
        if json_flag {
            OutputMode::Json
        } else {
            OutputMode::Human
        }
    }

    /// Check if this is JSON mode
    pub fn is_json(&self) -> bool {
        matches!(self, OutputMode::Json)
    }

    /// Check if this is human mode
    pub fn is_human(&self) -> bool {
        matches!(self, OutputMode::Human)
    }
}
```

Export OutputMode from the module.
  </action>
  <verify>cargo check passes</verify>
  <done>OutputMode enum exists with from_flags(), is_json(), is_human() methods</done>
</task>

<task type="auto">
  <name>Task 2: Add --json global flag to CLI</name>
  <files>src/main.rs</files>
  <action>
Add `--json` global flag to the Cli struct in src/main.rs:

1. Add to the Cli struct after existing global args:
```rust
/// Output results as JSON for programmatic use
#[arg(long, global = true)]
json: bool,
```

2. Update the execute_command function signature to accept output mode:
```rust
async fn execute_command(
    cli: &Cli, 
    mut client: Box<dyn ProtocolClient>,
    output_mode: OutputMode,
) -> Result<()>
```

3. Create OutputMode at the start of run() and pass it through:
```rust
let output_mode = OutputMode::from_flags(cli.json);
```

4. Update all calls to execute_command to pass output_mode.

5. Update command handlers in execute_command to pass output_mode where needed.
  </action>
  <verify>cargo check passes, --json flag appears in help output</verify>
  <done>--json flag defined in Cli struct, OutputMode flows through to command execution</done>
</task>

<task type="auto">
  <name>Task 3: Add JSON output helper to output module</name>
  <files>src/output.rs</files>
  <action>
Add JSON serialization helper to src/output.rs:

```rust
/// Print a value as formatted JSON to stdout.
///
/// This function serializes any serializable value to pretty-printed JSON
/// and writes it to stdout. Used for --json output mode.
///
/// # Type Parameters
/// * `T` - Any type implementing Serialize
///
/// # Arguments
/// * `value` - The value to serialize and print
///
/// # Errors
/// Prints error to stderr if serialization fails
pub fn print_json<T: serde::Serialize>(value: &T) {
    match serde_json::to_string_pretty(value) {
        Ok(json) => println!("{}", json),
        Err(e) => {
            eprintln!("{{\"error\": \"Failed to serialize output: {}\"}}", e);
        }
    }
}

/// Print a value as compact JSON to stdout.
///
/// Used when minimal output size is preferred.
pub fn print_json_compact<T: serde::Serialize>(value: &T) {
    match serde_json::to_string(value) {
        Ok(json) => println!("{}", json),
        Err(e) => {
            eprintln!("{{\"error\": \"Failed to serialize output: {}\"}}", e);
        }
    }
}
```

These helpers ensure consistent JSON formatting across all commands.
  </action>
  <verify>cargo check passes</verify>
  <done>print_json and print_json_compact functions exist in output module</done>
</task>

</tasks>

<verification>
- [ ] `cargo check` passes without errors
- [ ] `cargo build` succeeds
- [ ] `mcp --help` shows --json flag
- [ ] `mcp list --help` shows --json flag (inherited from global)
- [ ] OutputMode enum is accessible from all command modules
</verification>

<success_criteria>
1. --json flag is available on all commands (global flag)
2. OutputMode enum tracks the output format preference
3. JSON output helpers are available for use in command implementations
4. Infrastructure is in place for subsequent plans to implement JSON output
</success_criteria>

<output>
After completion, create `.planning/phases/07-json-output-machine-readable/07-01-SUMMARY.md`
</output>
