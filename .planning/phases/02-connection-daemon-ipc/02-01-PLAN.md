---
phase: 02-connection-daemon-ipc
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/ipc/mod.rs
  - src/ipc/unix.rs
  - src/error.rs
autonomous: true

must_haves:
  truths:
    - "Unix sockets work on Linux and macOS for IPC communication"
    - "IPC abstraction hides platform details from core logic"
    - "Daemon can accept multiple concurrent connections via Unix sockets"
  artifacts:
    - path: "src/ipc/mod.rs"
      provides: "Platform-agnostic IPC trait definitions"
      exports: ["IpcServer", "IpcClient", "IpcStream"]
    - path: "src/ipc/unix.rs"
      provides: "Unix socket implementation"
      exports: ["UnixIpcServer", "UnixIpcClient"]
    - path: "Cargo.toml"
      provides: "interprocess dependency"
      contains: "interprocess"
  key_links:
    - from: "src/ipc/mod.rs"
      to: "src/ipc/unix.rs"
      via: "pub use unix::*"
      pattern: "cfg.*unix"
    - from: "src/error.rs"
      to: "src/ipc/mod.rs"
      via: "IpcError variant"
      pattern: "IpcError"
---

<objective>
Create cross-platform IPC abstraction with Unix socket implementation for *nix systems.

Purpose: Enable daemon-CLI communication using Unix domain sockets on Linux/macOS while hiding platform differences behind traits.

Output: Working IPC module with trait-based abstraction and Unix implementation that can accept connections.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/02-connection-daemon-ipc/02-RESEARCH.md
@src/transport.rs
@src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Add interprocess dependency</name>
  <files>Cargo.toml</files>
  <action>
    Add `interprocess = { version = "2.3", features = ["tokio"] }` to [dependencies] section in Cargo.toml.
    This crate provides unified IPC abstraction over Unix sockets and Windows named pipes.
    Run `cargo check` to verify the dependency resolves correctly.
  </action>
  <verify>cargo check passes with new dependency</verify>
  <done>interprocess v2.3+ is in Cargo.toml dependencies and compiles</done>
</task>

<task type="auto">
  <name>Create IPC module with trait definitions</name>
  <files>src/ipc/mod.rs</files>
  <action>
    Create src/ipc/mod.rs with platform-agnostic IPC traits:
    
    1. Define `IpcStream` trait extending AsyncRead + AsyncWrite + Send + Sync + Unpin
    2. Define `IpcServer` trait with `accept()` method returning (Box<dyn IpcStream>, String)
    3. Define `IpcClient` trait with `connect()` method returning Box<dyn IpcStream>
    4. Add factory function `create_ipc_server(path: &Path) -> Result<Box<dyn IpcServer>>` with #[cfg(unix)] and #[cfg(windows)] implementations
    5. Add helper function `get_socket_path() -> PathBuf` returning platform-specific path:
       - Unix: /run/user/{uid}/mcp-cli/daemon.sock or /tmp/mcp-cli-{uid}/daemon.sock
    6. Re-export platform-specific types behind cfg gates
    
    Use async_trait for async trait methods. Follow the pattern in RESEARCH.md section "Pattern 1: IPC Abstraction Trait".
  </action>
  <verify>cargo check passes, no compiler errors in ipc module</verify>
  <done>src/ipc/mod.rs exists with IpcServer, IpcClient, IpcStream traits and factory function</done>
</task>

<task type="auto">
  <name>Implement Unix socket backend</name>
  <files>src/ipc/unix.rs</files>
  <action>
    Create src/ipc/unix.rs with Unix socket implementation:
    
    1. Define `UnixIpcServer` struct wrapping tokio::net::UnixListener
    2. Implement `new(path: &Path) -> Result<Self>` that:
       - Creates parent directory if needed (tokio::fs::create_dir_all)
       - Removes stale socket file if exists
       - Binds UnixListener to path
    3. Implement IpcServer trait for UnixIpcServer:
       - accept() awaits listener.accept(), returns (Box<dyn IpcStream>, addr_string)
    4. Define `UnixIpcClient` struct
    5. Implement IpcClient trait for UnixIpcClient:
       - connect() uses tokio::net::UnixStream::connect(path)
    6. Implement IpcStream for tokio::net::UnixStream (it already has AsyncRead/AsyncWrite)
    
    Follow the pattern in RESEARCH.md section "Unix Implementation". Handle errors with proper context using crate::error::Result.
  </action>
  <verify>cargo check passes on Unix platform (or with --target)</verify>
  <done>src/ipc/unix.rs implements UnixIpcServer, UnixIpcClient with tokio UnixListener/UnixStream</done>
</task>

<task type="auto">
  <name>Add IPC errors to error module</name>
  <files>src/error.rs</files>
  <action>
    Add IPC-specific error variants to the error enum in src/error.rs:
    
    1. Add `IpcError { message: String }` variant
    2. Add `SocketBindError { path: String, source: std::io::Error }` variant  
    3. Add `ConnectionRefused { path: String }` variant
    4. Add `StaleSocket` variant for when socket file exists but daemon not responding
    
    Ensure all variants implement std::error::Error with proper Display messages.
    Update any From impls needed for interprocess or tokio errors.
  </action>
  <verify>cargo check passes, all error variants compile</verify>
  <done>error.rs has IpcError, SocketBindError, ConnectionRefused, StaleSocket variants</done>
</task>

</tasks>

<verification>
1. `cargo check` passes with no errors
2. `cargo build` succeeds on Linux/macOS
3. Module structure: src/ipc/mod.rs exists and exports traits
4. Platform implementation: src/ipc/unix.rs exists with UnixIpcServer
5. Error handling: IPC errors added to error.rs
</verification>

<success_criteria>
- interprocess crate added to Cargo.toml
- IPC abstraction traits (IpcServer, IpcClient, IpcStream) defined in src/ipc/mod.rs
- Unix socket implementation complete in src/ipc/unix.rs
- Error variants for IPC failures added
- Code compiles on Unix platforms
- No platform-specific code outside ipc/ module
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection-daemon-ipc/02-01-SUMMARY.md`
</output>
