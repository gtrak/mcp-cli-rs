---
phase: 02-connection-daemon-ipc
plan: 05
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - src/daemon/fingerprint.rs
  - src/daemon/orphan.rs
  - src/daemon/mod.rs
  - src/cli/daemon.rs
autonomous: true

must_haves:
  truths:
    - "Config fingerprinting detects changes via hash comparison"
    - "Stale daemons are shut down when config changes detected"
    - "Orphaned daemon processes cleaned up on CLI startup"
    - "PID files track daemon process for orphan detection"
  artifacts:
    - path: "src/daemon/fingerprint.rs"
      provides: "Config fingerprinting for change detection"
      exports: ["calculate_fingerprint", "ConfigFingerprint"]
    - path: "src/daemon/orphan.rs"
      provides: "Orphan cleanup logic"
      exports: ["cleanup_orphaned_daemon", "is_daemon_running"]
    - path: "src/cli/daemon.rs"
      provides: "CLI daemon management"
      exports: ["ensure_daemon", "spawn_daemon"]
  key_links:
    - from: "src/cli/daemon.rs"
      to: "src/daemon/orphan.rs"
      via: "cleanup on startup"
      pattern: "cleanup_orphaned_daemon"
    - from: "src/cli/daemon.rs"
      to: "src/daemon/fingerprint.rs"
      via: "fingerprint comparison"
      pattern: "calculate_fingerprint"
---

<objective>
Implement config change detection via fingerprinting and orphan cleanup for robust daemon lifecycle.

Purpose: Ensure daemon uses fresh config when configuration changes and clean up orphaned processes/sockets from crashed daemons to prevent resource leaks.

Output: Working config fingerprinting that triggers daemon restart on changes, and cleanup logic that removes stale resources on CLI startup.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/phases/02-connection-daemon-ipc/02-RESEARCH.md
@src/daemon/mod.rs
@src/config/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Implement config fingerprinting</name>
  <files>src/daemon/fingerprint.rs</files>
  <action>
    Create src/daemon/fingerprint.rs for config change detection:
    
    1. Define `ConfigFingerprint` struct:
       - hash: String (SHA256 of config content)
       - mtime: SystemTime (modification time as backup)
    2. Implement `calculate_fingerprint(config_path: &Path) -> Result<ConfigFingerprint>`:
       - Read config file content
       - Calculate SHA256 hash using sha2 crate (or simple hash if avoiding deps)
       - Get file metadata for mtime
       - Return ConfigFingerprint { hash, mtime }
    3. Implement `PartialEq` and `Eq` for ConfigFingerprint
    4. Add serialization support (Serialize/Deserialize) for sending to CLI
    5. Add helper `from_config_content(content: &str) -> ConfigFingerprint`:
       - Hash the content directly (for daemon to calculate its fingerprint)
    6. Create constant `FINGERPRINT_FILE` name: "daemon.fingerprint"
    
    The fingerprint is stored in a file alongside the PID file so CLI can compare.
    Alternatively, CLI requests fingerprint from running daemon via IPC.
    See RESEARCH.md "Pattern 4: Config Change Detection" section.
  </action>
  <verify>cargo check passes, fingerprint code compiles</verify>
  <done>src/daemon/fingerprint.rs with SHA256-based config fingerprinting</done>
</task>

<task type="auto">
  <name>Implement orphan cleanup logic</name>
  <files>src/daemon/orphan.rs</files>
  <action>
    Create src/daemon/orphan.rs for detecting and cleaning up orphaned daemons:
    
    1. Define paths helper:
       - `get_pid_file_path() -> PathBuf`: socket_path.with_extension("pid")
       - `get_fingerprint_file_path() -> PathBuf`: socket_path.with_extension("fingerprint")
    2. Implement `is_daemon_running(pid: u32) -> bool`:
       - Unix: send signal 0 with nix::sys::signal::kill(pid, None)
       - Windows: OpenProcess(PROCESS_QUERY_INFORMATION, false, pid) then check exit code
       - Returns true if process exists and is running
    3. Implement `read_daemon_pid(socket_path: &Path) -> Result<u32>`:
       - Read PID file content
       - Parse as u32
    4. Implement `cleanup_orphaned_daemon(socket_path: &Path) -> Result<()>`:
       - Try to connect to daemon via IPC
       - If connection succeeds: daemon running, return Ok(())
       - If connection fails: daemon dead/crashed
       - Remove stale socket file (Unix only)
       - Read PID file, check if process exists with is_daemon_running()
       - If process exists but not responding: kill it
       - Remove PID file
       - Remove fingerprint file
       - Return Ok(())
    5. Add `write_daemon_pid(socket_path: &Path, pid: u32) -> Result<()>`:
       - Write PID to file (called by daemon on startup)
    
    See RESEARCH.md "Pitfall 2: Orphaned Daemon Processes" section.
    Use platform-specific process detection but keep logic clean.
  </action>
  <verify>cargo check passes, orphan cleanup code compiles</verify>
  <done>src/daemon/orphan.rs with PID tracking and cleanup logic</done>
</task>

<task type="auto">
  <name>Integrate fingerprint and cleanup with daemon</name>
  <files>src/daemon/mod.rs</files>
  <action>
    Update daemon to write PID and fingerprint on startup:
    
    1. In run_daemon(), before starting main loop:
       - Calculate config fingerprint from config content
       - Get current process PID using std::process::id()
       - Write PID to file: orphan::write_daemon_pid(&socket_path, pid)
       - Write fingerprint to file (optional - can be requested via IPC instead)
    2. Update DaemonState to include fingerprint:
       ```rust
       pub struct DaemonState {
           pub config: Arc<Config>,
           pub config_fingerprint: String,
           ...
       }
       ```
    3. Ensure cleanup on shutdown:
       - Remove PID file
       - Remove fingerprint file
       - Remove socket file (already done)
    4. Update handle_get_config_fingerprint() to return stored fingerprint
    
    Daemon now tracks its identity and config version for CLI to check.
  </action>
  <verify>cargo check passes, daemon writes PID/fingerprint</verify>
  <done>Daemon writes PID file and fingerprint on startup, cleans up on exit</done>
</task>

<task type="auto">
  <name>Create CLI daemon management module</name>
  <files>src/cli/daemon.rs</files>
  <action>
    Create src/cli/daemon.rs for CLI-side daemon lifecycle management:
    
    1. Implement `ensure_daemon(config_path: &Path) -> Result<IpcClient>`:
       - Call orphan::cleanup_orphaned_daemon() first
       - Calculate current config fingerprint
       - Try to connect to existing daemon via IPC
       - If connected:
         * Request fingerprint from daemon
         * If fingerprints match: return client (reuse daemon)
         * If mismatch: send shutdown to old daemon, continue to spawn
       - If not connected or after shutdown:
         * Spawn new daemon process
         * Wait briefly for daemon to start
         * Connect via IPC
         * Return client
    2. Implement `spawn_daemon(config_path: &Path, fingerprint: &ConfigFingerprint) -> Result<()>`:
       - Find daemon binary (same directory as CLI binary, or in PATH)
       - Spawn process with tokio::process::Command
       - Pass config path as argument
       - Use kill_on_drop(true) to prevent zombies
       - Don't wait for exit - daemon runs independently
    3. Implement `shutdown_daemon() -> Result<()>`:
       - Connect to daemon
       - Send Shutdown request
       - Wait for ShutdownAck
    4. Add helper `wait_for_daemon_startup(timeout: Duration) -> Result<()>`:
       - Retry connecting with exponential backoff
       - Return when connection succeeds or timeout
    
    This is the primary interface CLI uses to ensure daemon is running with fresh config.
  </action>
  <verify>cargo check passes, CLI daemon management compiles</verify>
  <done>src/cli/daemon.rs with ensure_daemon() and spawn_daemon() functions</done>
</task>

</tasks>

<verification>
1. `cargo check` passes with all modules integrated
2. Config fingerprinting calculates SHA256 hash
3. Orphan cleanup detects stale PIDs and removes files
4. Daemon writes PID and fingerprint on startup
5. CLI has ensure_daemon() that handles cleanup and spawning
6. Config change detection compares fingerprints
</verification>

<success_criteria>
- Config fingerprint calculated via SHA256 hash of config content
- PID file tracks daemon process ID for orphan detection
- cleanup_orphaned_daemon() removes stale socket/PID/fingerprint files
- is_daemon_running() correctly checks process existence on both platforms
- Daemon writes PID and fingerprint on startup, cleans up on shutdown
- CLI ensure_daemon() checks for orphans, compares fingerprints, spawns if needed
- Config change triggers old daemon shutdown and new daemon spawn
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection-daemon-ipc/02-05-SUMMARY.md`
</output>
