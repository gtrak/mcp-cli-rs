---
phase: 02-connection-daemon-ipc
plan: 06
type: execute
wave: 4
depends_on: ["02-03", "02-04", "02-05"]
files_modified:
  - src/main.rs
  - src/cli/mod.rs
  - src/cli/commands.rs
  - tests/daemon_tests.rs
  - tests/ipc_tests.rs
autonomous: false

must_haves:
  truths:
    - "CLI transparently uses daemon when available, falls back to direct connection"
    - "First execution spawns daemon, subsequent executions reuse it"
    - "50%+ performance improvement on repeated tool calls"
    - "Daemon self-terminates after 60s idle and restarts fresh on next access"
  artifacts:
    - path: "src/main.rs"
      provides: "CLI entry with daemon integration"
      contains: "ensure_daemon"
    - path: "src/cli/commands.rs"
      provides: "Commands using daemon client"
      contains: "execute_via_daemon"
    - path: "tests/daemon_tests.rs"
      provides: "Daemon lifecycle tests"
      contains: "test_daemon_spawn"
    - path: "tests/ipc_tests.rs"
      provides: "IPC communication tests"
      contains: "test_ipc_roundtrip"
  key_links:
    - from: "src/main.rs"
      to: "src/cli/daemon.rs"
      via: "ensure_daemon call"
      pattern: "cli::daemon::ensure_daemon"
    - from: "src/cli/commands.rs"
      to: "src/daemon/protocol.rs"
      via: "DaemonRequest/DaemonResponse"
      pattern: "send_request.*receive_response"
---

<objective>
Integrate daemon with CLI commands and add cross-platform tests for the complete IPC/daemon system.

Purpose: Make daemon usage transparent to users - CLI automatically spawns daemon on first access, reuses cached connections, and achieves 50%+ performance improvement on repeated calls.

Output: Working end-to-end system with CLI using daemon for all operations, plus tests validating daemon lifecycle, IPC communication, and performance improvement.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/phases/02-connection-daemon-ipc/02-RESEARCH.md
@src/main.rs
@src/cli/commands.rs
@src/cli/daemon.rs
</context>

<tasks>

<task type="auto">
  <name>Integrate daemon with CLI main entry</name>
  <files>src/main.rs</files>
  <action>
    Update src/main.rs to use daemon for operations:
    
    1. Modify main() to call ensure_daemon() at startup:
       ```rust
       #[tokio::main]
       async fn main() -> anyhow::Result<()> {
           let cli = Cli::parse();
           
           // Ensure daemon is running with fresh config
           let daemon_client = cli::daemon::ensure_daemon(&cli.config_path).await?;
           
           // Use daemon client for all operations
           match cli.command {
               Commands::List { server } => {
                   commands::list_tools(daemon_client, server).await
               }
               Commands::Execute { server, tool, args } => {
                   commands::execute_tool(daemon_client, server, tool, args).await
               }
               // ... other commands
           }
       }
       ```
    2. Update Cli struct to accept --config-path argument
    3. Add fallback: if daemon spawn fails, log warning and use direct connections
    4. Ensure proper error handling and context messages
    
    The daemon_client is an IpcClient that communicates with the daemon process.
    All commands go through the daemon instead of creating direct connections.
  </action>
  <verify>cargo check passes, main.rs integrates with daemon</verify>
  <done>src/main.rs calls ensure_daemon() and passes client to commands</done>
</task>

<task type="auto">
  <name>Update CLI commands to use daemon client</name>
  <files>src/cli/commands.rs</files>
  <action>
    Update src/cli/commands.rs to work with daemon instead of direct connections:
    
    1. Modify command function signatures to accept daemon client:
       ```rust
       pub async fn list_tools(
           mut daemon: Box<dyn IpcClient>,
           server: Option<String>,
       ) -> Result<()>
       ```
    2. Implement list_tools via daemon:
       - If no server specified: send ListServers request
       - For each server: send ListTools request
       - Format and display results
    3. Implement execute_tool via daemon:
       - Parse arguments JSON
       - Send ExecuteTool request
       - Display result or error
    4. Add helper `execute_via_daemon(client, request) -> Result<DaemonResponse>`:
       - Send request via IPC
       - Receive response
       - Handle DaemonResponse::Error variant
       - Return success response
    5. Keep fallback direct connection functions for when daemon unavailable
    
    Commands now communicate with daemon via IPC instead of creating transports directly.
  </action>
  <verify>cargo check passes, commands use daemon protocol</verify>
  <done>src/cli/commands.rs updated with daemon-based command implementations</done>
</task>

<task type="auto">
  <name>Create IPC communication tests</name>
  <files>tests/ipc_tests.rs</files>
  <action>
    Create tests/ipc_tests.rs for cross-platform IPC validation:
    
    1. Test basic IPC roundtrip:
       ```rust
       #[tokio::test]
       async fn test_ipc_roundtrip() {
           // Create server
           let socket_path = temp_dir().join("test.sock");
           let mut server = create_ipc_server(&socket_path).await.unwrap();
           
           // Spawn client in background task
           let client_handle = tokio::spawn(async move {
               let mut client = create_ipc_client(&socket_path).await.unwrap();
               send_request(&mut client, &DaemonRequest::Ping).await.unwrap();
               receive_response(&mut client).await.unwrap()
           });
           
           // Accept and handle
           let (mut stream, _) = server.accept().await.unwrap();
           let request = receive_request(&mut stream).await.unwrap();
           send_response(&mut stream, &DaemonResponse::Pong).await.unwrap();
           
           // Verify
           let response = client_handle.await.unwrap();
           assert!(matches!(response, DaemonResponse::Pong));
       }
       ```
    2. Test concurrent connections:
       - Spawn multiple clients simultaneously
       - Verify server handles all connections
    3. Test large message transfer:
       - Send large JSON payload
       - Verify correct serialization/deserialization
    4. Add platform-specific path tests:
       - Unix: verify socket file created in expected location
       - Windows: verify named pipe created with correct name
    
    These tests validate the IPC layer works correctly on both platforms.
  </action>
  <verify>cargo test --test ipc_tests passes</verify>
  <done>tests/ipc_tests.rs with roundtrip, concurrent, and platform-specific tests</done>
</task>

<task type="auto">
  <name>Create daemon lifecycle tests</name>
  <files>tests/daemon_tests.rs</files>
  <action>
    Create tests/daemon_tests.rs for daemon lifecycle validation:
    
    1. Test daemon spawn and shutdown:
       ```rust
       #[tokio::test]
       async fn test_daemon_lifecycle() {
           let config = create_test_config();
           let socket_path = temp_dir().join("daemon_test.sock");
           
           // Spawn daemon
           let daemon_handle = tokio::spawn(async move {
               run_daemon(config, socket_path).await
           });
           
           // Wait for startup
           tokio::time::sleep(Duration::from_millis(100)).await;
           
           // Connect and verify
           let mut client = create_ipc_client(&socket_path).await.unwrap();
           send_request(&mut client, &DaemonRequest::Ping).await.unwrap();
           let response = receive_response(&mut client).await.unwrap();
           assert!(matches!(response, DaemonResponse::Pong));
           
           // Shutdown
           send_request(&mut client, &DaemonRequest::Shutdown).await.unwrap();
           let _ = daemon_handle.await;
       }
       ```
    2. Test idle timeout:
       - Start daemon with short timeout (1s)
       - Don't send any requests
       - Verify daemon exits after timeout
    3. Test config change detection:
       - Start daemon with config A
       - Change config file
       - Verify new fingerprint detected
       - Verify old daemon shuts down
    4. Test orphan cleanup:
       - Create stale PID file pointing to non-existent process
       - Call cleanup_orphaned_daemon()
       - Verify PID file removed
    5. Test connection pooling:
       - Execute tool twice on same server
       - Verify same connection reused (check logs or add instrumentation)
    
    These tests validate CONN-06, CONN-07, CONN-08 requirements.
  </action>
  <verify>cargo test --test daemon_tests passes</verify>
  <done>tests/daemon_tests.rs with lifecycle, timeout, config change, orphan tests</done>
</task>

<task type="checkpoint:human-verify">
  <name>Verify performance improvement and cross-platform behavior</name>
  <what-built>
    Complete daemon-IPC system with:
    - Cross-platform IPC (Unix sockets + Windows named pipes)
    - Connection daemon with idle timeout (60s)
    - Connection pooling with health checks
    - Config change detection and orphan cleanup
    - CLI integration with fallback to direct connections
    - Comprehensive tests
  </what-built>
  <how-to-verify>
    1. Build and run initial test:
       ```bash
       cargo build --release
       ./target/release/mcp-cli list
       ```
       - Verify daemon spawns (check process list)
       - Verify tools listed successfully
    
    2. Test performance improvement:
       ```bash
       # First call (spawns daemon)
       time ./target/release/mcp-cli exec server tool '{}'
       
       # Second call (uses cached connection)
       time ./target/release/mcp-cli exec server tool '{}'
       ```
       - Verify second call is 50%+ faster than first
       - Both calls should succeed
    
    3. Test idle timeout:
       - Wait 60+ seconds
       - Verify daemon process terminates
       - Next CLI invocation should spawn new daemon
    
    4. (Windows users) Verify named pipes:
       ```powershell
       Get-ChildItem \\.\pipe\ | Where-Object { $_.Name -like "*mcp-cli*" }
       ```
    
    5. (Unix users) Verify Unix sockets:
       ```bash
       ls -la /run/user/$UID/mcp-cli/ 2>/dev/null || ls -la /tmp/mcp-cli-$UID/
       ```
    
    6. Run all tests:
       ```bash
       cargo test
       ```
       - All IPC tests should pass
       - All daemon tests should pass
  </how-to-verify>
  <resume-signal>
    Type "approved" if all verification steps pass and performance improvement is observed.
    Describe any issues if tests fail or performance doesn't meet 50% target.
  </resume-signal>
</task>

</tasks>

<verification>
1. `cargo build` produces both mcp-cli and mcp-daemon binaries
2. `cargo test` passes all IPC and daemon tests
3. CLI main uses ensure_daemon() for all operations
4. Commands work via daemon protocol
5. Fallback to direct connections if daemon fails
6. Tests cover: IPC roundtrip, concurrent connections, daemon lifecycle, idle timeout, config change, orphan cleanup
</verification>

<success_criteria>
- CLI transparently uses daemon via IPC for all operations
- First execution spawns daemon, subsequent calls reuse cached connections
- 50%+ performance improvement measured on repeated tool calls
- Daemon self-terminates after 60s idle timeout
- Config changes trigger daemon restart with fresh connections
- Orphaned processes and sockets cleaned up on startup
- All tests pass on both Unix and Windows platforms
- Graceful fallback to direct connections if daemon unavailable
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection-daemon-ipc/02-06-SUMMARY.md`
</output>
