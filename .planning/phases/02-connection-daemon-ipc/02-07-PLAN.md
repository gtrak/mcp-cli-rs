---
phase: 02-connection-daemon-ipc
plan: 07
type: execute
wave: 1
depends_on: [02-01, 02-02, 02-03, 02-04, 02-05]
files_modified:
  - src/ipc/mod.rs
  - src/ipc/unix.rs
  - src/ipc/windows.rs
  - src/cli/daemon.rs
  - src/cli/commands.rs
  - src/daemon/protocol.rs (if ProtocolClient used there)
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "CLI code compiles without lifetime errors"
    - "ensure_daemon() returns Box<dyn ProtocolClient> without lifetime parameter"
    - "Commands can access config through Arc<Config>"
    - "Multiple daemon operations work in sequence"
    - "Daemon can be spawned and used from CLI"
  artifacts:
    - path: src/ipc/mod.rs
      provides: ProtocolClient trait without lifetime parameter
      exports: ["create_ipc_client", "ProtocolClient"]
      must_not_contain: "ProtocolClient<'config>"
    - path: src/cli/daemon.rs
      provides: ensure_daemon returning lifetime-free ProtocolClient
      exports: ["ensure_daemon"]
      signature: "pub async fn ensure_daemon(config: Arc<Config>) -> Result<Box<dyn ProtocolClient>>"
    - path: src/cli/commands.rs
      provides: Command functions accepting Arc-based ProtocolClient
      signature: "Box<dyn ProtocolClient>"
    - path: src/daemon/protocol.rs (if modified)
      provides: Updated protocol types for Arc usage
  key_links:
    - from: "src/cli/daemon.rs::ensure_daemon"
      to: "src/ipc/mod.rs::create_ipc_client"
      via: "Arc<Config> argument"
      pattern: "create_ipc_client\\(&Arc::clone\\(&config\\)|config\\))"
    - from: "src/cli/commands.rs"
      to: "src/ipc/mod.rs::ProtocolClient::config"
      via: "Arc access"
      pattern: "daemon\\.config\\(\\)\\."
---

<objective>
Fix the ProtocolClient lifetime issue that prevents CLI compilation by converting from borrowed Config to Arc<Config>.

Purpose: The current ProtocolClient trait uses a lifetime parameter `<'config>` which borrows the config. This creates a lifetime error because the config in main.rs's run() function goes out of scope when run() returns, but the returned ProtocolClient trait object needs the borrow to last longer. By converting to Arc<Config>, we eliminate the lifetime issue entirely.

Output: CLI code that compiles and can spawn/use daemon without lifetime errors.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/02-connection-daemon-ipc/02-06-SUMMARY.md

## Gap Context

**Issue from 02-06-SUMMARY.md:**
```
### 1. Lifetime Issue with ProtocolClient and Config (BLOCKING)

**Error:**
error[E0597]: `daemon_config` does not live long enough

**Cause:**
The `ensure_daemon()` function returns `Box<dyn ProtocolClient<'config>>` which borrows the config. However, the config is created in `run()` and dropped at the end of the function, but the ProtocolClient needs the borrow to last for `'static`.

**Impact:**
CLI code cannot compile. The daemon system is fully implemented but cannot be used from the CLI due to this lifetime issue.

**Fix Options:**
1. Change ensure_daemon to return a client with 'static bounds (requires cloning config into client)
2. Restructure CLI to not pass daemon_client into commands (different pattern)
3. Use Arc<Config> instead of &Config for ProtocolClient
```

**Current Architecture:**
- `ProtocolClient<'config>` trait has `fn config(&self) -> &'config Config`
- `IpcClientWrapper<'config, T>` stores `config: Option<&'config Config>`
- `ensure_daemon(&config)` returns `Box<dyn ProtocolClient<'config> + 'config>`
- Commands receive `Box<dyn ProtocolClient<'_>>`

**Recommended Fix (Option 3 - Arc<Config>):**
This is the cleanest approach:
- Eliminates lifetime parameter from ProtocolClient
- Arc provides thread-safe ownership
- Minimal refactoring (trait changes + wrapper changes)
- Commands don't need extensive changes (already use `<'_>`)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update ProtocolClient trait to use Arc<Config></name>
  <files>src/ipc/mod.rs</files>
  <action>
Modify src/ipc/mod.rs to remove lifetime parameter from ProtocolClient:

1. Change the trait definition from:
   ```rust
   pub trait ProtocolClient<'config>: Send + Sync {
       fn config(&self) -> &'config Config;
       async fn list_servers(&mut self) -> Result<Vec<String>, McpError>;
       async fn list_tools(&mut self, server_name: &str) -> Result<Vec<ToolInfo>, McpError>;
       async fn execute_tool(&mut self, server_name: &str, tool_name: &str, arguments: serde_json::Value) -> Result<serde_json::Value, McpError>;
   }
   ```
   To:
   ```rust
   pub trait ProtocolClient: Send + Sync {
       fn config(&self) -> Arc<Config>;
       async fn list_servers(&mut self) -> Result<Vec<String>, McpError>;
       async fn list_tools(&mut self, server_name: &str) -> Result<Vec<ToolInfo>, McpError>;
       async fn execute_tool(&mut self, server_name: &str, tool_name: &str, arguments: serde_json::Value) -> Result<serde_json::Value>, McpError>;
   }
   ```
   Note: Add `use std::sync::Arc;` at the top.

2. Update IpcClientWrapper struct:
   ```rust
   #[derive(Clone)]
   pub struct IpcClientWrapper<T: Clone> {
       client: T,
       config: Arc<Config>,
   }
   ```

3. Update IpcClientWrapper impl block:
   - Remove lifetime parameter: `impl<T: Clone + IpcClient> IpcClientWrapper<T>`
   - Update constructor: `pub fn new(client: T, config: Arc<Config>) -> Self`
   - Update with_config: `pub fn with_config(client: T, config: Arc<Config>) -> Self`
   - Remove set_config method (no longer needed)
   - Update config method: `fn config(&self) -> Arc<Config> { Arc::clone(&self.config) }`

4. Update ProtocolClient implementation for IpcClientWrapper:
   ```rust
   #[async_trait]
   impl<T: IpcClient + Send + Sync + Clone> ProtocolClient for IpcClientWrapper<T> {
       fn config(&self) -> Arc<Config> {
           Arc::clone(&self.config)
       }
       // ... other methods unchanged
   }
   ```

5. Update create_ipc_client factory functions (remove lifetime parameter):
   - Unix: `pub fn create_ipc_client(config: Arc<Config>) -> Result<Box<dyn ProtocolClient>, McpError>`
   - Windows: `pub fn create_ipc_client(config: Arc<Config>) -> Result<Box<dyn ProtocolClient>, McpError>`

IMPORTANT: Ensure all methods return Arc<Config> not &Config.
  </action>
  <verify>
Run `cargo build --bin mcp` to verify no compilation errors in src/ipc/mod.rs
  </verify>
  <done>ProtocolClient trait no longer has lifetime parameter, uses Arc<Config> throughout</done>
</task>

<task type="auto">
  <name>Task 2: Update platform-specific IPC implementations</name>
  <files>src/ipc/unix.rs, src/ipc/windows.rs (if it exists)</files>
  <action>
Update platform-specific IPC implementations to work with Arc<Config>:

For src/ipc/unix.rs:
1. Update UnixIpcClient struct initialization to accept Arc<Config>:
   ```rust
   pub struct UnixIpcClient {
       config: Arc<Config>,
   }
   ```

2. Update UnixIpcClient::new to accept Arc<Config>:
   ```rust
   pub fn new(config: Arc<Config>) -> Self {
       Self { config }
   }
   ```

3. Update IpcClient trait implementation for UnixIpcClient:
   - Change `fn config(&self) -> &Config` to `fn config(&self) -> Arc<Config>`
   - Implement as: `fn config(&self) -> Arc<Config> { Arc::clone(&self.config) }`

For src/ipc/windows.rs (if exists):
Make the same changes as unix.rs - struct field, new() method, and config() method.

Note: The IpcClient trait should use the updated signature after Task 1 complete.
  </action>
  <verify>
Run `cargo build --bin mcp` to verify platform-specific implementations compile
  </verify>
  <done>All platform IPC implementations use Arc<Config></done>
</task>

<task type="auto">
  <name>Task 3: Update ensure_daemon to use Arc<Config></name>
  <files>src/cli/daemon.rs</files>
  <action>
Update src/cli/daemon.rs::ensure_daemon to use Arc<Config>:

1. Change function signature:
   ```rust
   pub async fn ensure_daemon(config: Arc<Config>) -> Result<Box<dyn ProtocolClient>> {
   ```
   Note: Removed lifetime parameter, changed '&Config' to 'Arc<Config>', removed '<config>' from return type.

2. Update function body to use Arc::clone when passing config:
   - In connect_to_daemon call: `connect_to_daemon(Arc::clone(&config), &socket_path).await`
   - In spawn_daemon_and_wait call: `spawn_daemon_and_wait(Arc::clone(&config), &fingerprint).await`
   - In wait_for_daemon_startup call: `wait_for_daemon_startup(Arc::clone(&config), &socket_path, timeout).await`

3. Update connect_to_daemon signature:
   ```rust
   async fn connect_to_daemon(config: Arc<Config>, socket_path: &Path) -> Result<Box<dyn ProtocolClient>> {
       let client = crate::ipc::create_ipc_client(config)?;
       Ok(client)
   }
   ```

4. Update wait_for_daemon_startup signature:
   ```rust
   async fn wait_for_daemon_startup(config: Arc<Config>, socket_path: &Path, timeout: Duration) -> Result<Box<dyn ProtocolClient>> {
   ```
   And update the recursive call: `connect_to_daemon(Arc::clone(&config), socket_path).await`

5. Update cleanup_orphaned_daemon call to use Arc::clone if needed:
   ```rust
   cleanup_orphaned_daemon(Arc::clone(&config), &socket_path).await
   ```

6. Cleanup orphaned_daemon function signature (if it needs to change):
   Check if its first parameter uses &Config or Arc<Config>, and update to Arc<Config> if needed.

7. Update shutdown_daemon signature similarly:
   ```rust
   pub async fn shutdown_daemon(config: Arc<Config>) -> Result<()> {
   ```

IMPORTANT: Verify cleanup_orphaned_daemon and calculate_fingerprint signatures - if they take &Config, keep them as is (they don't return ProtocolClient).
  </action>
  <verify>
Run `cargo build --bin mcp` to verify src/cli/daemon.rs compiles
  </verify>
  <done>ensure_daemon returns Box<dyn ProtocolClient> with Arc<Config></done>
</task>

<task type="auto">
  <name>Task 4: Update main.rs to use Arc<Config></name>
  <files>src/main.rs</files>
  <action>
Update src/main.rs to wrap config in Arc and pass to ensure_daemon:

1. Add Arc import at top if not present:
   ```rust
   use std::sync::Arc;
   ```

2. Wrap the config in Arc after loading:
   Change:
   ```rust
   let daemon_config = if let Some(path) = &cli.config {
       load_config(path).await?
   } else {
       find_and_load(None).await?
   };
   let daemon_client = ensure_daemon(&daemon_config).await
   ```
   To:
   ```rust
   let config = if let Some(path) = &cli.config {
       load_config(path).await?
   } else {
       find_and_load(None).await?
   };
   let daemon_config = Arc::new(config);
   let daemon_client = ensure_daemon(daemon_config.clone()).await
   ```
   Or alternatively:
   ```rust
   let daemon_config = Arc::new(if let Some(path) = &cli.config {
       load_config(path).await?
   } else {
       find_and_load(None).await?
   });
   let daemon_client = ensure_daemon(Arc::clone(&daemon_config)).await
   ```

3. Verify all matches pass daemon_client to commands (no changes needed to command calls, they already accept Box<dyn ProtocolClient<'_>> which will now be Box<dyn ProtocolClient>).

IMPORTANT: Ensure Arc::clone is used where daemon_config is passed, not &daemon_config.
  </action>
  <verify>
Run `cargo build --bin mcp` to verify the CLI binary compiles without errors
  </verify>
  <done>main.rs compiles and creates Arc<Config> for daemon</done>
</task>

<task type="auto">
  <name>Task 5: Update command functions for Arc<Config> access</name>
  <files>src/cli/commands.rs</files>
  <action>
Update src/cli/commands.rs to work with Arc-based ProtocolClient:

1. Ensure Arc import is present:
   ```rust
   use std::sync::Arc;
   ```

2. Update command function signatures if needed:
   The commands currently accept `Box<dyn crate::ipc::ProtocolClient<'_>>`.
   After Task 1, ProtocolClient no longer has lifetime parameter, so the signatures become:
   ```rust
   pub async fn cmd_list_servers(mut daemon: Box<dyn crate::ipc::ProtocolClient>, with_descriptions: bool) -> Result<()>
   pub async fn cmd_server_info(daemon: Box<dyn crate::ipc::ProtocolClient>, server_name: &str) -> Result<()>
   // etc.
   ```

3. Update places where daemon.config() is used to handle Arc<Config>:
   - Change `daemon.config().is_empty()` to `daemon.config().is_empty()` (works with Arc, returns &Config)
   - Change `daemon.config().servers_by_name()` to `daemon.config().servers_by_name()` (works, auto-derefs)
   - Change `&daemon.config().servers` to `&daemon.config().servers` (works, auto-derefs)
   - Change `daemon.config().get_server(...)` to `daemon.config().get_server(...)` (works, auto-derefs)

   These don't need changes because Arc<T> implements Deref to &T, so all existing method calls work automatically.

4. If there are any `&daemon.config()` borrows that cause issues with multiple calls, change to:
   ```rust
   let config = daemon.config(); // Arc<Config>
   // then use config.field
   ```

IMPORTANT: Most code should work unchanged due to Arc's Deref implementation. Only need to fix if there are specific borrowing issues.
  </action>
  <verify>
Run `cargo build --bin mcp --lib` to verify commands module compiles
  </verify>
  <done>All command functions work with Arc-based ProtocolClient</done>
</task>

<task type="auto">
  <name>Task 6: Verify full build and run tests</name>
  <files>Cargo.toml (no changes, just verification)</files>
  <action>
Verify the entire project compiles and tests pass:

1. Build the CLI binary:
   ```bash
   cargo build --bin mcp
   ```
   Verify no compilation errors, especially no lifetime errors in main.rs.

2. Build the daemon binary:
   ```bash
   cargo build --bin mcp-daemon
   ```
   Verify daemon binary still compiles (it shouldn't be affected by ProtocolClient changes).

3. Run unit tests:
   ```bash
   cargo test --lib
   ```
   Verify all tests pass, especially daemon_tests.rs.

4. Run integration tests if any:
   ```bash
   cargo test --test '*'
   ```

5. Check for warnings:
   ```bash
   cargo build 2>&1 | grep -i warning
   ```
   Address any warnings that appeared due to the changes.

If there are any remaining compilation errors:
- Check that all ProtocolClient references have no lifetime parameters
- Verify Arc::clone is used when passing Arc values
- Ensure Arc<T> is used where &T was used before
  </action>
  <verify>
cargo build --bin mcp --bin mcp-daemon && cargo test --lib
  </verify>
  <done>Full project builds successfully, all tests pass, no lifetime errors</done>
</task>

</tasks>

<verification>
## Verification Steps

1. **Compilation Check**: Run `cargo build --bin mcp` and verify no lifetime errors
2. **Daemon Binary**: Run `cargo build --bin mcp-daemon` and verify it still builds
3. **Tests**: Run `cargo test --lib` and verify all tests pass
4. **Manual Test**: Spawn daemon and run a simple CLI command to confirm it works

## Success Criteria
- [ ] main.rs compiles without `error[E0597]: \`daemon_config\` does not live long enough`
- [ ] All commands (list, info, tool, call, search) compile
- [ ] Daemon binary compiles and is unaffected by changes
- [ ] Unit tests pass (especially daemon_tests.rs)
- [ ] No new warnings introduced
</verification>

<success_criteria>
The Phase 2 blocking lifetime issue is resolved. The CLI compiles and can spawn/use the daemon without lifetime errors. All daemon functionality from plans 02-01 through 02-05 is now accessible from the CLI.
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection-daemon-ipc/02-07-SUMMARY.md`
</output>
