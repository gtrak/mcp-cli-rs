---
phase: 02-connection-daemon-ipc
plan: 09
type: execute
wave: 2
depends_on: [02-08]
files_modified:
  - src/daemon/mod.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "ExecuteTool handler uses connection pool to get transport, sends tool execution request, returns tool result"
    - "ListTools handler uses connection pool to get transport, sends tools/list request, returns tool list"
    - "ListServers handler returns list of configured server names from config"
    - "All handlers use MCP protocol via Transport trait (not direct HTTP calls)"
    - "Handlers return proper DaemonResponse variants (not Error stubs)"
  artifacts:
    - path: src/daemon/mod.rs
      provides: Implemented request handlers in handle_request() function
      contains: "DaemonRequest::ExecuteTool", "DaemonRequest::ListTools", "DaemonRequest::ListServers"
      implementation: "Uses connection_pool, transport.send MCP request, parses response, returns DaemonResponse"
  key_links:
    - from: "src/daemon/mod.rs::handle_request"
      to: "src/daemon/pool.rs::get"
      via: "connection_pool.lock().unwrap().get(&server_name)"
      pattern: "connection_pool.*get\\("
    - from: "src/daemon/mod.rs::handle_request"
      to: "src/transport/transport_trait.rs::Transport"
      via: "transport.send()"
      pattern: "transport\\.send\\(request\\)"
    - from: "src/daemon/mod.rs::handle_request"
      to: "src/daemon/protocol.rs::DaemonResponse"
      via: "Return ToolResult, ToolList, or ServerList variants"
      pattern: "DaemonResponse::(ToolResult|ToolList|ServerList)"
---

<objective>
Implement daemon request handlers for ExecuteTool, ListTools, and ListServers operations.

Purpose: Daemon request handlers are currently stub implementations that return "not yet implemented" errors. Even though the connection pool and transport layer are complete, the daemon cannot perform any useful operations.

Output: Functional request handlers that use the connection pool to get transport connections and execute MCP protocol operations.

Gap: Lines 212-237 in src/daemon/mod.rs contain stub handlers that return Error responses. These need to be replaced with implementations that:
1. Get transport from connection_pool.get(&server_name)
2. Send MCP protocol requests via transport.send()
3. Parse responses and return proper DaemonResponse variants

</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-connection-daemon-ipc/02-VERIFICATION.md

# Connection pool interface (how to get transport)
@U:\dev\mcp-cli-rs\src\daemon\pool.rs

# MCP protocol definitions (what requests/responses look like)
@U:\dev\mcp-cli-rs\src\protocol/mod.rs

# Current stub handlers (what to replace)
@U:\dev\mcp-cli-rs\src\daemon\mod.rs

# Daemon state (includes config and connection pool)
@U:\dev\mcp-cli-rs\src\daemon\mod.rs
</context>

<tasks>

<task type="auto">
  <name>Implement ExecuteTool request handler</name>
  <files>src/daemon/mod.rs</files>
  <action>
  Replace stub handler (lines 212-219) with implementation:

  ```rust
  crate::daemon::protocol::DaemonRequest::ExecuteTool { server_name, tool_name, arguments } => {
      tracing::info!("ExecuteTool: server={}, tool={}", server_name, tool_name);

      // Get transport from connection pool
      let transport = match state.connection_pool.lock().unwrap().get(&server_name) {
          Ok(t) => t,
          Err(e) => {
              tracing::error!("Failed to get transport for {}: {}", server_name, e);
              return crate::daemon::protocol::DaemonResponse::Error {
                  code: 2,
                  message: format!("Server not found or connection failed: {}", e),
              };
          }
      };

      // Build MCP tools/call request
      use crate::protocol::McpRequest;
      let mcp_request = McpRequest::CallTool {
          name: tool_name.clone(),
          arguments: Some(arguments.clone()),
      };

      // Send request and get response
      match transport.send(&mcp_request).await {
          Ok(mcp_response) => {
              // Parse Tool response
              match mcp_response.content {
                  Some(content) => {
                      // Convert text content to JSON value if needed
                      if content.is_text() {
                          // For text content, wrap in JSON object
                          serde_json::json!({
                              "content": content.as_text().unwrap_or(""),
                              "isError": false
                          })
                      } else {
                          // For already-structured content, return as-is
                          content.into_value()
                      }
                  }
                  None => serde_json::Value::Null,
              }
          }
          Err(e) => {
              tracing::error!("Tool execution failed: {}", e);
              return crate::daemon::protocol::DaemonResponse::Error {
                  code: 3,
                  message: format!("Tool execution failed: {}", e),
              };
          }
      };

      crate::daemon::protocol::DaemonResponse::ToolResult(result)
  }
  ```

  Reference McpRequest::CallTool structure from src/protocol/mod.rs. Handle errors gracefully with appropriate error codes.

  DO NOT:
  - Use hardcoded error returns
  - Skip error handling (transport.get() and transport.send() can fail)
  - Return unstructured errors - use specific codes (1=client, 2=server, 3=network)
  </action>
  <verify>Check src/daemon/mod.rs handle_request():
  - ExecuteTool arm calls connection_pool.lock().unwrap().get(&server_name)
  - Handle creates McpRequest::CallTool with name and arguments
  - Call transport.send(&mcp_request).await
  - Parse response.content and return DaemonResponse::ToolResult(result)
  - Error handling with appropriate error codes (2 for server error, 3 for network error)</verify>
  <done>ExecuteTool handler gets transport from pool, sends MCP tool call request, returns tool result as ToolResult</done>
</task>

<task type="auto">
  <name>Implement ListTools request handler</name>
  <files>src/daemon/mod.rs</files>
  <action>
  Replace stub handler (lines 221-228) with implementation:

  ```rust
  crate::daemon::protocol::DaemonRequest::ListTools { server_name } => {
      tracing::info!("ListTools: server={}", server_name);

      // Get transport from connection pool
      let transport = match state.connection_pool.lock().unwrap().get(&server_name) {
          Ok(t) => t,
          Err(e) => {
              tracing::error!("Failed to get transport for {}: {}", server_name, e);
              return crate::daemon::protocol::DaemonResponse::Error {
                  code: 2,
                  message: format!("Server not found or connection failed: {}", e),
              };
          }
      };

      // Build MCP tools/list request
      use crate::protocol::McpRequest;
      let mcp_request = McpRequest::ListTools;

      // Send request and get response
      match transport.send(&mcp_request).await {
          Ok(mcp_response) => {
              // Parse tools list from response
              let tools = match mcp_response.content {
                  Some(content) => {
                      // Extract tools from content based on MCP response structure
                      // MCP tools/list returns: { "tools": [ ... ] }
                      if let Some(tools_array) = content.into_value().get("tools") {
                          if let Some(tools) = tools_array.as_array() {
                              tools.iter().map(|tool| {
                                  crate::daemon::protocol::ToolInfo {
                                      name: tool.get("name")
                                          .and_then(|n| n.as_str())
                                          .unwrap_or("unknown")
                                          .to_string(),
                                      description: tool.get("description")
                                          .and_then(|d| d.as_str())
                                          .unwrap_or("")
                                          .to_string(),
                                      input_schema: tool.get("inputSchema")
                                          .cloned()
                                          .unwrap_or(serde_json::Value::Object(serde_json::Map::new())),
                                  }
                              }).collect()
                          } else {
                              Vec::new()
                          }
                      } else {
                          Vec::new()
                      }
                  }
                  None => Vec::new(),
              };

              crate::daemon::protocol::DaemonResponse::ToolList(tools)
          }
          Err(e) => {
              tracing::error!("List tools failed: {}", e);
              crate::daemon::protocol::DaemonResponse::Error {
                  code: 3,
                  message: format!("List tools failed: {}", e),
              }
          }
      }
  }
  ```

  Parse the MCP tools/list response format which includes a "tools" array.

  DO NOT:
  - Return empty list on all errors - distinguish between "no tools" and "fetch failed"
  - Skip validation (server may not exist in config)
  </action>
  <verify>Check src/daemon/mod.rs handle_request():
  - ListTools arm calls connection_pool.lock().unwrap().get(&server_name)
  - Creates McpRequest::ListTools
  - Calls transport.send(&mcp_request).await
  - Parses tools from response.content.get("tools")
  - Returns DaemonResponse::ToolList(Vec<ToolInfo>)
  - Error handling with error codes</verify>
  <done>ListTools handler gets transport from pool, sends MCP tools/list request, returns tool list as ToolList</done>
</task>

<task type="auto">
  <name>Implement ListServers request handler</name>
  <files>src/daemon/mod.rs</files>
  <action>
  Replace stub handler (lines 230-237) with implementation:

  ```rust
  crate::daemon::protocol::DaemonRequest::ListServers => {
      tracing::info!("ListServers requested");

      // Get list of configured server names from config
      let servers: Vec<String> = state.config.get_server_names().cloned().collect();

      crate::daemon::protocol::DaemonResponse::ServerList(servers)
  }
  ```

  This is the simplest handler - just return server names from config. Verify Config has a get_server_names() or similar method. If not, access config.servers.keys() directly (assuming config.servers is a HashMap).

  DO NOT:
  - Make network calls (servers are in config)
  - Return hardcoded list (read from actual config)
  </action>
  <verify>Check src/daemon/mod.rs handle_request():
  - ListServers arm accesses state.config
  - Extracts server names (config.servers.keys() or config.get_server_names())
  - Returns DaemonResponse::ServerList(Vec<String>)</verify>
  <done>ListServers handler returns configured server names from config as ServerList</done>
</task>

</tasks>

<verification>
Build verification:
```bash
cargo build --release
cargo check
```

No compilation errors - code follows existing daemon patterns.

Code verification:
- All three handlers return proper DaemonResponse variants (not Error)
- ExecuteTool uses connection_pool, sends McpRequest::CallTool, returns ToolResult
- ListTools uses connection_pool, sends McpRequest::ListTools, returns ToolList
- ListServers reads from config, returns ServerList
- All handlers have error handling with appropriate error codes
</verification>

<success_criteria>
1. ExecuteTool handler executes tools via MCP protocol and returns results
2. ListTools handler lists available tools from server
3. ListServers handler returns configured server names
4. All handlers use connection pool for transport management
5. Error handling with specific error codes
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection-daemon-ipc/02-09-SUMMARY.md`
</output>
