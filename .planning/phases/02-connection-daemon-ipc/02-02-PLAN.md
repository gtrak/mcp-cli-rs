---
phase: 02-connection-daemon-ipc
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/ipc/mod.rs
  - src/ipc/windows.rs
  - src/error.rs
autonomous: true

must_haves:
  truths:
    - "Named pipes work on Windows for IPC communication"
    - "Named pipe security defaults prevent privilege escalation"
    - "Windows implementation uses same trait interface as Unix"
  artifacts:
    - path: "src/ipc/windows.rs"
      provides: "Windows named pipe implementation"
      exports: ["NamedPipeIpcServer", "NamedPipeIpcClient"]
    - path: "src/ipc/mod.rs"
      provides: "Windows re-exports"
      contains: "cfg.*windows"
  key_links:
    - from: "src/ipc/mod.rs"
      to: "src/ipc/windows.rs"
      via: "pub use windows::*"
      pattern: "cfg.*windows"
    - from: "src/ipc/windows.rs"
      to: "interprocess"
      via: "LocalSocketListener"
      pattern: "interprocess::local_socket"
---

<objective>
Implement Windows named pipe backend for IPC abstraction with security best practices.

Purpose: Enable daemon-CLI communication using Windows named pipes while maintaining security (preventing privilege escalation) and using the same trait interface as Unix.

Output: Working Windows named pipe implementation that integrates with the IPC trait abstraction.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/phases/02-connection-daemon-ipc/02-RESEARCH.md
@src/ipc/mod.rs
@src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Implement Windows named pipe backend</name>
  <files>src/ipc/windows.rs</files>
  <action>
    Create src/ipc/windows.rs with Windows named pipe implementation using interprocess crate:
    
    1. Define `NamedPipeIpcServer` struct wrapping interprocess::local_socket::LocalSocketListener
    2. Implement `new(name: &str) -> Result<Self>` that:
       - Creates LocalSocketListener with name format: \\.\pipe\mcp-cli-{username}-daemon
       - Uses ListenerOptions::new().name(name).create()? (interprocess handles security)
    3. Implement IpcServer trait:
       - accept() awaits listener.accept(), returns (Box<dyn IpcStream>, addr_string)
    4. Define `NamedPipeIpcClient` struct
    5. Implement IpcClient trait:
       - connect() uses LocalSocketStream::connect(name)?
    6. Implement IpcStream for LocalSocketStream (AsyncRead/AsyncWrite via tokio traits)
    
    CRITICAL: interprocess v2.3+ sets SECURITY_IDENTIFICATION by default - do NOT override this.
    If using tokio directly, you'd need security_qos_flags(SECURITY_IDENTIFICATION).
    
    Follow pattern in RESEARCH.md "Windows Implementation" section.
  </action>
  <verify>cargo check passes (use --target x86_64-pc-windows-msvc if on non-Windows)</verify>
  <done>src/ipc/windows.rs implements NamedPipeIpcServer, NamedPipeIpcClient with LocalSocketListener</done>
</task>

<task type="auto">
  <name>Update IPC module with Windows re-exports</name>
  <files>src/ipc/mod.rs</files>
  <action>
    Update src/ipc/mod.rs to add Windows platform support:
    
    1. Add Windows-specific module import:
       ```rust
       #[cfg(windows)]
       pub mod windows;
       #[cfg(windows)]
       pub use windows::{NamedPipeIpcServer, NamedPipeIpcClient};
       ```
    2. Update `create_ipc_server()` factory function to use NamedPipeIpcServer on Windows:
       ```rust
       #[cfg(windows)]
       pub async fn create_ipc_server() -> Result<Box<dyn IpcServer>> {
           let name = format!(r"\\.\pipe\mcp-cli-{}-daemon", whoami::username());
           Ok(Box::new(NamedPipeIpcServer::new(&name)?))
       }
       ```
    3. Update `create_ipc_client()` similarly for Windows
    4. Add platform-specific socket path function:
       - Windows: returns pipe name string \\.\pipe\mcp-cli-{username}-daemon
       - Unix: already implemented in 02-01
    
    Ensure the factory function automatically selects correct implementation based on cfg.
  </action>
  <verify>cargo check passes on both platforms (or with --target flags)</verify>
  <done>ipc/mod.rs has Windows cfg blocks and NamedPipeIpcServer re-exports</done>
</task>

<task type="auto">
  <name>Add Windows-specific error handling</name>
  <files>src/error.rs</files>
  <action>
    Add Windows-specific IPC error variants to src/error.rs:
    
    1. Add `PipeCreationError { name: String, source: std::io::Error }` variant
    2. Add `PipeBusy` variant for when pipe instance is busy
    3. Update error messages to mention both "socket" (Unix) and "pipe" (Windows) where appropriate
    
    Keep existing Unix error variants - they'll be compiled out on Windows via cfg.
    Use conditional compilation if needed: #[cfg(unix)] vs #[cfg(windows)] on error variants.
  </action>
  <verify>cargo check passes, no duplicate error definitions</verify>
  <done>error.rs has Windows-specific error variants alongside Unix variants</done>
</task>

</tasks>

<verification>
1. `cargo check --target x86_64-pc-windows-msvc` passes (or native Windows build)
2. `cargo check` passes on Unix (previous plan still works)
3. src/ipc/windows.rs exists with NamedPipeIpcServer
4. Factory function automatically selects platform implementation
5. Security: using interprocess defaults (SECURITY_IDENTIFICATION)
</verification>

<success_criteria>
- Windows named pipe implementation complete in src/ipc/windows.rs
- Uses interprocess LocalSocketListener (secure defaults)
- Factory function auto-selects platform via cfg flags
- Same trait interface as Unix implementation
- No scattered #[cfg] conditionals in business logic
- Compiles on Windows platform
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection-daemon-ipc/02-02-SUMMARY.md`
</output>
