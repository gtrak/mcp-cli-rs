---
phase: 02-connection-daemon-ipc
plan: 10
type: execute
wave: 2
depends_on: [02-01, 02-02, 02-05]
files_modified:
  - src/cli/daemon.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "ensure_daemon() requests fingerprint from existing daemon and compares with calculated fingerprint"
    - "ensure_daemon() shuts down stale daemon (mismatched fingerprints) and spawns new daemon"
    - "shutdown_daemon() sends DaemonRequest::Shutdown to daemon and waits for ShutdownAck"
    - "shutdown_daemon() gracefully terminates daemon instead of just disconnecting"
    - "Config changes trigger daemon restart with fresh connections"
  artifacts:
    - path: src/cli/daemon.rs
      provides: Completed ensure_daemon() with fingerprint comparison
      contains: "ensure_daemon()", "send DaemonRequest::GetConfigFingerprint", "compare fingerprints"
      implementation: "Requests fingerprint from existing daemon, compares with calculated, triggers shutdown if stale"
    - path: src/cli/daemon.rs
      provides: Completed shutdown_daemon() with graceful shutdown
      contains: "shutdown_daemon()", "send DaemonRequest::Shutdown", "await ShutdownAck"
      implementation: "Connects to daemon, sends Shutdown request, receives ShutdownAck"
  key_links:
    - from: "src/cli/daemon.rs::ensure_daemon"
      to: "src/ipc/mod.rs::ProtocolClient::send_request"
      via: "client.send_request(&DaemonRequest::GetConfigFingerprint)"
      pattern: "send_request\\(&DaemonRequest::GetConfigFingerprint\\)"
    - from: "src/cli/daemon.rs::shutdown_daemon"
      to: "src/ipc/mod.rs::ProtocolClient::send_request"
      via: "client.send_request(&DaemonRequest::Shutdown)"
      pattern: "send_request\\(&DaemonRequest::Shutdown\\)"
    - from: "src/cli/daemon.rs::ensure_daemon"
      to: "src/daemon/fingerprint.rs::calculate_fingerprint"
      via: "calculate_fingerprint(&config)"
      pattern: "calculate_fingerprint\\("
---

<objective>
Implement config fingerprint comparison in ensure_daemon() and graceful shutdown in shutdown_daemon().

Purpose: Config fingerprinting infrastructure exists (calculate_fingerprint, fingerprint files), but the comparison logic is incomplete. ensure_daemon() has a TODO at line 46 and doesn't validate existing daemon's fingerprint. shutdown_daemon() at line 163 doesn't actually send a shutdown request, just disconnects.

Output: Working fingerprint comparison that detects config changes and graceful daemon shutdown on request.

Gap: Two TODO comments indicate incomplete implementations:
1. Line 46 in src/cli/daemon.rs: "TODO: Request fingerprint from daemon and compare"
2. Line 163 in src/cli/daemon.rs: "TODO: Send DaemonRequest::Shutdown through client"

These need to be completed using the already-implemented NDJSON protocol (after plan 02-08) and fingerprint infrastructure.

</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-connection-daemon-ipc/02-VERIFICATION.md

# Daemon request/response protocol (GetConfigFingerprint, Shutdown)
@U:\dev\mcp-cli-rs\src\daemon\protocol.rs

# Config fingerprint calculation
@U:\dev\mcp-cli-rs\src\daemon\fingerprint.rs

# Current incomplete implementations (TODOs)
@U:\dev\mcp-cli-rs\src\cli\daemon.rs
</context>

<tasks>

<task type="auto">
  <name>Implement fingerprint comparison in ensure_daemon()</name>
  <files>src/cli/daemon.rs</files>
  <action>
  Replace stub implementation (lines 41-57) with fingerprint comparison:

  ```rust
  // Try to connect to existing daemon
  tracing::debug!("Attempting to connect to daemon...");
  match connect_to_daemon(daemon_config.clone(), &socket_path).await {
      Ok(mut client) => {
          tracing::info!("Daemon already running, checking config...");

          // Request fingerprint from existing daemon
          let request = crate::daemon::protocol::DaemonRequest::GetConfigFingerprint;
          match client.send_request(&request).await {
              Ok(crate::daemon::protocol::DaemonResponse::ConfigFingerprint(daemon_fingerprint)) => {
                  tracing::debug!("Daemon fingerprint: {}", daemon_fingerprint);
                  tracing::debug!("Local fingerprint: {}", fingerprint);

                  // Compare fingerprints
                  if daemon_fingerprint == fingerprint {
                      tracing::info!("Config fingerprints match - reusing existing daemon");
                      Ok(Box::new(client))
                  } else {
                      tracing::info!("Config fingerprints differ - restarting daemon");
                      // Shutdown stale daemon first
                      if let Err(e) = shutdown_daemon(daemon_config.clone()).await {
                          tracing::warn!("Failed to shutdown stale daemon: {}", e);
                      }
                      // Spawn new daemon and wait for startup
                      let new_client = spawn_daemon_and_wait(daemon_config.clone(), &fingerprint).await?;
                      // Connect to newly spawned daemon
                      connect_to_daemon(daemon_config, &socket_path).await
                  }
              }
              Ok(other_response) => {
                  tracing::warn!("Unexpected response from daemon: {:?}", other_response);
                  // Treat as stale, spawn new daemon
                  let new_client = spawn_daemon_and_wait(daemon_config.clone(), &fingerprint).await?;
                  connect_to_daemon(daemon_config, &socket_path).await
              }
              Err(e) => {
                  tracing::warn!("Failed to get fingerprint from daemon: {}, spawning new daemon", e);
                  // Treat as stale, spawn new daemon
                  let new_client = spawn_daemon_and_wait(daemon_config.clone(), &fingerprint).await?;
                  connect_to_daemon(daemon_config, &socket_path).await
              }
          }
      }
      Err(_) => {
          tracing::info!("Daemon not running, spawning new daemon...");
          // Spawn new daemon and wait for startup
          let new_client = spawn_daemon_and_wait(daemon_config.clone(), &fingerprint).await?;
          // Connect to newly spawned daemon
          connect_to_daemon(daemon_config, &socket_path).await
      }
  }
  ```

  Note: client.send_request() requires &mut self on Windows (NamedPipeIpcClient). Make client mutable when connecting.

  DO NOT:
  - Skip fingerprint comparison (always compare, never assume existing daemon is good)
  - Treat fingerprint mismatch as error - always restart daemon
  - Forget to call shutdown_daemon() before spawning new when fingerprints mismatch
  - Panic on unexpected daemon responses - handle gracefully by spawning new daemon
  </action>
  <verify>Check src/cli/daemon.rs ensure_daemon():
  - Line 43: client connection stored as "mut client" (for Windows compatibility)
  - Line 46-47: Send DaemonRequest::GetConfigFingerprint via client.send_request()
  - Lines 50-51: Compare daemon_fingerprint with local fingerprint
  - Lines 54-56: If mismatch, call shutdown_daemon(), then spawn_daemon_and_wait()
  - Line 57: If match, return Ok(Box::new(client)) 
  - Error handling for all failure cases</verify>
  <done>ensure_daemon() requests fingerprint from existing daemon, compares with calculated fingerprint, shuts down stale daemon on mismatch, returns existing client if fingerprint matches</done>
</task>

<task type="auto">
  <name>Implement graceful shutdown in shutdown_daemon()</name>
  <files>src/cli/daemon.rs</files>
  <action>
  Replace stub implementation (lines 152-167) with graceful shutdown:

  ```rust
  ///
  /// Connects to daemon and sends a shutdown request.
  /// Waits for acknowledgment before returning.
  pub async fn shutdown_daemon(daemon_config: Arc<Config>) -> Result<()> {
      let socket_path = crate::ipc::get_socket_path();

      // Connect to daemon
      let mut client = connect_to_daemon(daemon_config.clone(), &socket_path).await?;

      // Send shutdown request
      tracing::info!("Sending shutdown request to daemon");
      let request = crate::daemon::protocol::DaemonRequest::Shutdown;
      match client.send_request(&request).await {
          Ok(crate::daemon::protocol::DaemonResponse::ShutdownAck) => {
              tracing::info!("Daemon acknowledged shutdown");
              Ok(())
          }
          Ok(other_response) => {
              tracing::warn!("Unexpected response to shutdown: {:?}", other_response);
              // Treat as success - daemon will likely shut down on its own
              Ok(())
          }
          Err(e) => {
              // If daemon is already dead or connection fails, that's okay
              tracing::warn!("Failed to send shutdown request (daemon may already be gone): {}", e);
              Ok(())
          }
      }
  }
  ```

  The daemon will shut down when it receives Shutdown request (sets shutdown flag in lifecycle).

  DO NOT:
  - Panic if daemon doesn't respond (it may already be dead)
  - Use tokio::time::sleep unnecessarily (daemon responds immediately to Shutdown)
  - Forget to handle ShutdownAck response (confirm graceful shutdown)
  </action>
  <verify>Check src/cli/daemon.rs shutdown_daemon():
  - Line 158: client connection stored as "mut client"
  - Lines 161-162: Create DaemonRequest::Shutdown, send via client.send_request()
  - Line 163: Match on DaemonResponse::ShutdownAck to confirm graceful shutdown
  - Line 167: Handle errors gracefully (daemon may already be gone)
  - No TODO comments remaining</verify>
  <done>shutdown_daemon() connects to daemon, sends DaemonRequest::Shutdown, waits for ShutdownAck confirmation, handles errors gracefully</done>
</task>

</tasks>

<verification>
Build verification:
```bash
cargo build --release
cargo check
```

No compilation errors.

Code verification:
- ensure_daemon() sends GetConfigFingerprint request, compares fingerprints
- ensure_daemon() calls shutdown_daemon() if fingerprints mismatch
- shutdown_daemon() sends Shutdown request, awaits ShutdownAck
- Both functions handle errors gracefully (daemon may be gone)
- No TODO comments remaining in either function
</verification>

<success_criteria>
1. Config changes detected via fingerprint comparison
2. Stale daemon automatically shut down when config changes
3. New daemon spawned with fresh connections after config change
4. Daemon shuts down gracefully on request (not just timeout)
5. All error paths handled (daemon may be dead, unexpected responses)
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection-daemon-ipc/02-10-SUMMARY.md`
</output>
