---
phase: 02-connection-daemon-ipc
plan: 04
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/daemon/pool.rs
  - src/daemon/mod.rs
  - src/transport.rs
autonomous: true

must_haves:
  truths:
    - "Connection pool caches transport connections by server name"
    - "Health checks validate connections before reuse via MCP ping"
    - "Failed health checks trigger connection recreation"
    - "Pool is thread-safe for concurrent access from multiple handlers"
  artifacts:
    - path: "src/daemon/pool.rs"
      provides: "Connection pool implementation"
      exports: ["ConnectionPool", "PooledConnection"]
    - path: "src/daemon/mod.rs"
      provides: "Pool integration with daemon state"
      contains: "connection_pool"
  key_links:
    - from: "src/daemon/pool.rs"
      to: "src/transport.rs"
      via: "dyn Transport trait"
      pattern: "Box<dyn Transport>"
    - from: "src/daemon/mod.rs"
      to: "src/daemon/pool.rs"
      via: "ConnectionPool usage"
      pattern: "pool.get(server_name)"
---

<objective>
Implement connection pooling with health checks for persistent MCP server connections.

Purpose: Cache transport connections in the daemon to avoid repeated process spawning and HTTP handshakes, significantly improving performance on repeated tool calls.

Output: Working connection pool that maintains persistent connections, validates health before reuse, and recreates failed connections automatically.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/phases/02-connection-daemon-ipc/02-RESEARCH.md
@src/transport.rs
@src/daemon/mod.rs
@src/config/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Create connection pool data structures</name>
  <files>src/daemon/pool.rs</files>
  <action>
    Create src/daemon/pool.rs with connection pool structures:
    
    1. Define `PooledConnection` struct:
       - transport: Box<dyn Transport>
       - server_name: String
       - created_at: Instant
       - last_used: Instant
       - health_check_failures: u32
    2. Define `ConnectionPool` struct:
       - connections: Arc<Mutex<HashMap<String, PooledConnection>>>
       - config: Arc<Config>
       - max_health_failures: u32 (default 3)
    3. Implement `ConnectionPool::new(config: Arc<Config>) -> Self`
    4. Add helper methods to PooledConnection:
       - is_healthy() -> bool: checks health_check_failures < max
       - touch() -> updates last_used
       - age() -> Duration: time since creation
    
    Use std::collections::HashMap for the connection map. Arc<Mutex<...>> for thread-safe sharing.
    The pool will be shared across multiple client connection handlers.
  </action>
  <verify>cargo check passes, pool structures compile</verify>
  <done>src/daemon/pool.rs has ConnectionPool and PooledConnection structs</done>
</task>

<task type="auto">
  <name>Implement connection health checks</name>
  <files>src/daemon/pool.rs</files>
  <action>
    Add health check functionality to connection pool:
    
    1. Implement `PooledConnection::health_check(&mut self) -> Result<()>`:
       - Send MCP ping request via transport:
         ```json
         {"jsonrpc": "2.0", "method": "ping", "id": "health-check"}
         ```
       - Use tokio::time::timeout(Duration::from_secs(5), transport.send(ping))
       - If success: reset health_check_failures to 0
       - If timeout or error: increment health_check_failures
       - Return Ok(()) if healthy, Err otherwise
    2. Implement `ConnectionPool::validate_connection(&self, server_name: &str) -> Result<()>`:
       - Lock connections mutex
       - Get mutable reference to pooled connection
       - Call health_check() on it
       - Return result
    3. Add `is_connection_healthy(&self, server_name: &str) -> bool` convenience method
    
    Health checks use the MCP standard ping method. 5 second timeout prevents hanging on dead connections.
    See RESEARCH.md "Pitfall 4: Stale Connection Reuse" section.
  </action>
  <verify>cargo check passes, health check code compiles with transport integration</verify>
  <done>Health check using MCP ping with 5s timeout implemented in pool.rs</done>
</task>

<task type="auto">
  <name>Implement pool get/put operations</name>
  <files>src/daemon/pool.rs</files>
  <action>
    Add core pool operations for acquiring and releasing connections:
    
    1. Implement `ConnectionPool::get(&self, server_name: &str) -> Result<Box<dyn Transport>>`:
       - Lock connections mutex
       - Check if connection exists in map
       - If exists: 
         * Run health_check()
         * If healthy: update last_used, return cloned transport
         * If unhealthy: remove from map, will recreate
       - If not exists or was removed:
         * Get server config from self.config
         * Create new transport using create_transport_for_server()
         * Create PooledConnection, insert into map
         * Return transport
    2. Implement `ConnectionPool::remove(&self, server_name: &str)`:
       - Remove connection from map (called when health check fails permanently)
    3. Implement `ConnectionPool::clear(&self)`:
       - Clear all connections (called on daemon shutdown)
    4. Add helper `create_transport_for_server(config, server_name) -> Result<Box<dyn Transport>>`:
       - Look up ServerConfig by name
       - Use transport factory to create appropriate transport (stdio/http)
       - Return Box<dyn Transport>
    
    The get() method is the primary interface - it handles caching, health checks, and creation.
  </action>
  <verify>cargo check passes, pool operations compile</verify>
  <done>ConnectionPool::get() with health check validation implemented</done>
</task>

<task type="auto">
  <name>Integrate pool with daemon request handlers</name>
  <files>src/daemon/mod.rs</files>
  <action>
    Update src/daemon/mod.rs to use connection pool:
    
    1. Update DaemonState to include connection pool:
       ```rust
       pub struct DaemonState {
           pub config: Arc<Config>,
           pub config_fingerprint: String,
           pub lifecycle: DaemonLifecycle,
           pub connection_pool: Arc<ConnectionPool>,
       }
       ```
    2. Update run_daemon() to initialize pool:
       ```rust
       let pool = Arc::new(ConnectionPool::new(config.clone()));
       let state = DaemonState { ..., connection_pool: pool };
       ```
    3. Implement handle_execute_tool():
       - Get transport from pool: state.connection_pool.get(&server_name)
       - Use transport to send tool execution request
       - Return tool result
    4. Implement handle_list_tools():
       - Get transport from pool
       - Send tools/list request
       - Return tool list
    5. Update other handlers to accept &DaemonState parameter
    
    The handlers now use the pool instead of creating transports directly.
    Pool is shared via Arc so multiple concurrent handlers can use it.
  </action>
  <verify>cargo check passes, daemon integrates with pool</verify>
  <done>Daemon uses connection pool in ExecuteTool and ListTools handlers</done>
</task>

</tasks>

<verification>
1. `cargo check` passes with pool integration
2. ConnectionPool struct has all required methods
3. Health check uses MCP ping with timeout
4. get() method handles cache hit, health check, and creation
5. DaemonState includes Arc<ConnectionPool>
6. Request handlers use pool instead of direct transport creation
</verification>

<success_criteria>
- ConnectionPool maintains HashMap of server_name â†’ PooledConnection
- PooledConnection wraps Box<dyn Transport> with metadata (created_at, last_used, failures)
- Health check sends MCP ping with 5s timeout before returning cached connection
- Failed health checks remove connection and create new one
- get() method is atomic (mutex-protected) and handles all caching logic
- Pool integrated with daemon request handlers for ExecuteTool and ListTools
- Thread-safe: Arc<Mutex<...>> allows concurrent access from multiple client handlers
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection-daemon-ipc/02-04-SUMMARY.md`
</output>
