---
phase: 02-connection-daemon-ipc
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/bin/daemon.rs
  - src/daemon/mod.rs
  - src/daemon/lifecycle.rs
  - src/daemon/protocol.rs
  - Cargo.toml
autonomous: true

must_haves:
  truths:
    - "Daemon binary exists as separate executable"
    - "Daemon accepts IPC connections and handles JSON-RPC requests"
    - "Daemon self-terminates after 60 seconds of idle time"
    - "Daemon can be gracefully shut down via IPC command"
  artifacts:
    - path: "src/bin/daemon.rs"
      provides: "Daemon binary entry point"
      exports: ["main"]
    - path: "src/daemon/mod.rs"
      provides: "Daemon library exports"
      exports: ["run_daemon"]
    - path: "src/daemon/lifecycle.rs"
      provides: "Idle timeout and lifecycle management"
      exports: ["DaemonLifecycle"]
    - path: "src/daemon/protocol.rs"
      provides: "CLI-daemon communication protocol"
      exports: ["DaemonRequest", "DaemonResponse"]
  key_links:
    - from: "src/daemon/lifecycle.rs"
      to: "src/ipc/mod.rs"
      via: "IpcServer::accept"
      pattern: "ipc::create_ipc_server"
    - from: "src/daemon/protocol.rs"
      to: "src/daemon/mod.rs"
      via: "Request/Response handling"
      pattern: "handle_request"
---

<objective>
Create daemon binary with idle timeout, lifecycle management, and CLI-daemon communication protocol.

Purpose: Implement the long-running daemon process that maintains persistent connections and can be spawned lazily by CLI with automatic cleanup after idle period.

Output: Working daemon binary (mcp-daemon) that accepts IPC connections, handles JSON-RPC requests, and self-terminates after 60s of inactivity.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
</execution_context>

<context>
@.planning/phases/02-connection-daemon-ipc/02-RESEARCH.md
@src/ipc/mod.rs
@src/config/mod.rs
</context>

<tasks>

<task type="auto">
  <name>Create daemon protocol types</name>
  <files>src/daemon/protocol.rs</files>
  <action>
    Create src/daemon/protocol.rs with CLI-daemon communication protocol:
    
    1. Define `DaemonRequest` enum with variants:
       - Ping
       - GetConfigFingerprint
       - ExecuteTool { server_name, tool_name, arguments }
       - ListTools { server_name }
       - ListServers
       - Shutdown
    2. Define `DaemonResponse` enum with variants:
       - Pong
       - ConfigFingerprint(String)
       - ToolResult(serde_json::Value)
       - ToolList(Vec<ToolInfo>)
       - ServerList(Vec<String>)
       - ShutdownAck
       - Error { code: u32, message: String }
    3. Add helper functions:
       - `send_request<W: AsyncWrite>(writer, request) -> Result<()>` - writes NDJSON
       - `receive_request<R: AsyncBufRead>(reader) -> Result<DaemonRequest>` - reads NDJSON
       - Same for responses
    
    Use serde for serialization. Follow NDJSON format (one JSON object per line, newline delimited).
    See RESEARCH.md "Daemon-CLI Communication Protocol" section.
  </action>
  <verify>cargo check passes, protocol types compile</verify>
  <done>src/daemon/protocol.rs exists with DaemonRequest/DaemonResponse enums and NDJSON helpers</done>
</task>

<task type="auto">
  <name>Implement daemon lifecycle management</name>
  <files>src/daemon/lifecycle.rs</files>
  <action>
    Create src/daemon/lifecycle.rs with idle timeout and lifecycle logic:
    
    1. Define `DaemonLifecycle` struct with:
       - last_activity: Arc<Mutex<Instant>>
       - idle_timeout: Duration (default 60s)
       - running: Arc<AtomicBool>
    2. Implement `new(idle_timeout_secs: u64) -> Self`
    3. Implement `update_activity(&self)` - updates last_activity timestamp
    4. Implement `should_shutdown(&self) -> bool` - checks if idle timeout exceeded
    5. Implement `shutdown(&self)` - sets running to false
    6. Create `run_idle_timer(lifecycle: DaemonLifecycle)` async function:
       - Loop with tokio::time::sleep(Duration::from_secs(1))
       - Check should_shutdown(), break if true
       - This runs concurrently with connection accept loop
    
    The lifecycle manager tracks activity and signals when daemon should exit.
    Use tokio::sync::Mutex for last_activity (needs to be held across await points).
  </action>
  <verify>cargo check passes, lifecycle code compiles</verify>
  <done>src/daemon/lifecycle.rs has DaemonLifecycle with idle timeout tracking</done>
</task>

<task type="auto">
  <name>Create daemon library module</name>
  <files>src/daemon/mod.rs</files>
  <action>
    Create src/daemon/mod.rs with main daemon run loop:
    
    1. Define `DaemonState` struct holding:
       - config: Arc<Config>
       - config_fingerprint: String
       - lifecycle: DaemonLifecycle
       - connection_pool: Arc<Mutex<ConnectionPool>> (stub for now, full impl in 02-04)
    2. Implement `run_daemon(config: Config, socket_path: PathBuf) -> Result<()>`:
       - Create IPC server using ipc::create_ipc_server(&socket_path)
       - Calculate config fingerprint (hash of config file content)
       - Initialize DaemonLifecycle with 60s timeout
       - Spawn idle timer task
       - Enter main loop with tokio::select!:
         * accept connection -> spawn handle_client task, update activity
         * idle timer signals shutdown -> break loop
       - Cleanup: remove socket file on exit
    3. Implement `handle_client(stream, state)` async function:
       - Read DaemonRequest from stream
       - Match on request type and call appropriate handler
       - Write DaemonResponse back
       - Update lifecycle activity
    4. Add request handlers (stubs for now):
       - handle_ping() -> Pong
       - handle_get_config_fingerprint(state) -> ConfigFingerprint
       - handle_shutdown(state) -> ShutdownAck, trigger shutdown
       - Others return Error::NotImplemented
    
    See RESEARCH.md "Pattern 2: Daemon Process Lifecycle" for main loop structure.
  </action>
  <verify>cargo check passes, daemon module compiles</verify>
  <done>src/daemon/mod.rs has run_daemon() function with main loop and request handlers</done>
</task>

<task type="auto">
  <name>Create daemon binary entry point</name>
  <files>src/bin/daemon.rs, Cargo.toml</files>
  <action>
    Create daemon binary and update Cargo.toml:
    
    1. Create src/bin/daemon.rs:
       ```rust
       use mcp_cli_rs::daemon::run_daemon;
       use mcp_cli_rs::config::load_config;
       
       #[tokio::main]
       async fn main() -> anyhow::Result<()> {
           tracing_subscriber::init();
           
           let config = load_config().await?;
           let socket_path = get_daemon_socket_path();
           
           run_daemon(config, socket_path).await
       }
       ```
    2. Update Cargo.toml to include daemon binary:
       ```toml
       [[bin]]
       name = "mcp-daemon"
       path = "src/bin/daemon.rs"
       ```
    3. Add helper function to get socket path (use ipc::get_socket_path())
    4. Ensure the binary properly initializes logging
    
    The daemon binary is a thin wrapper around the library's run_daemon function.
  </action>
  <verify>cargo build compiles both mcp-cli and mcp-daemon binaries</verify>
  <done>src/bin/daemon.rs exists, Cargo.toml has [[bin]] entry for mcp-daemon</done>
</task>

</tasks>

<verification>
1. `cargo build` produces mcp-daemon binary
2. Protocol types serialize/deserialize correctly
3. Daemon compiles with IPC integration
4. Idle timeout logic compiles
5. Binary can be invoked (test with --help if clap args added)
</verification>

<success_criteria>
- mcp-daemon binary builds successfully
- Daemon protocol types (DaemonRequest, DaemonResponse) defined
- Daemon lifecycle with 60s idle timeout implemented
- Main run_daemon() loop with tokio::select! for accept/timeout
- Request handler stubs for Ping, ConfigFingerprint, Shutdown
- Cleanup on exit (socket file removal)
- Uses IPC abstraction (no platform-specific code in daemon logic)
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection-daemon-ipc/02-03-SUMMARY.md`
</output>
