---
phase: 02-connection-daemon-ipc
plan: 08
type: execute
wave: 1
depends_on: [02-01, 02-02, 02-07]
files_modified:
  - src/ipc/unix.rs
  - src/ipc/windows.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "UnixIpcClient::send_request() sends NDJSON-formatted request to daemon and receives response"
    - "NamedPipeIpcClient::send_request() sends NDJSON-formatted request to daemon and receives response"
    - "IPC protocol uses newline-delimited JSON (one JSON object per line)"
    - "Messages are serialized using serde_json, written with newline terminator, flushed"
    - "Response is read line-by-line, trimmed, deserialized from JSON"
  artifacts:
    - path: src/ipc/unix.rs
      provides: Implemented UnixIpcClient::send_request() method
      contains: "send_request (&self, request: &DaemonRequest) -> Result<DaemonResponse, McpError>"
      implementation: "Uses tokioio::split, BufWriter, protocol::send_request, protocol::receive_response"
    - path: src/ipc/windows.rs
      provides: Implemented NamedPipeIpcClient::send_request() method
      contains: "send_request (&mut self, request: &DaemonRequest) -> Result<DaemonResponse, McpError>"
      implementation: "Uses tokioio::split, BufWriter, protocol::send_request, protocol::receive_response"
  key_links:
    - from: "src/ipc/unix.rs::send_request"
      to: "src/daemon/protocol.rs::send_request"
      via: "Call with writer split from stream"
      pattern: "protocol::send_request\\(&mut writer, request\\)"
    - from: "src/ipc/unix.rs::send_request"
      to: "src/daemon/protocol.rs::receive_response"
      via: "Call with BufReader split from stream"
      pattern: "protocol::receive_response\\(&mut buf_reader\\)"
    - from: "src/ipc/windows.rs::send_request"
      to: "src/daemon/protocol.rs::send_request"
      via: "Call with writer split from named pipe stream"
      pattern: "protocol::send_request\\(&mut writer, request\\)"
    - from: "src/ipc/windows.rs::send_request"
      to: "src/daemon/protocol.rs::receive_response"
      via: "Call with BufReader split from named pipe stream"
      pattern: "protocol::receive_response\\(&mut buf_reader\\)"
---

<objective>
Implement NDJSON protocol for IPC client communication in both Unix and Windows implementations.

Purpose: The IPC client `send_request()` methods are currently stubs that return errors. This prevents any CLI-daemon communication, making the entire daemon system non-functional despite complete infrastructure.

Output: Fully functional IPC request/response communication using the NDJSON protocol helpers already implemented in `src/daemon/protocol.rs`.

Gap: Lines 91-102 and 105-114 in src/ipc/unix.rs contain duplicate stub implementations. Lines 97-108 in src/ipc/windows.rs contain a stub implementation. All need to be replaced with actual NDJSON protocol logic using the existing `protocol::send_request()` and `protocol::receive_response()` helpers.

</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-connection-daemon-ipc/02-VERIFICATION.md

# Reference implementation from daemon server (src/daemon/mod.rs::handle_client)
@U:\dev\mcp-cli-rs\src\daemon\mod.rs

# NDJSON protocol helpers already available
@U:\dev\mcp-cli-rs\src\daemon\protocol.rs

# Current IPC stub implementations (what to replace)
@U:\dev\mcp-cli-rs\src\ipc\unix.rs
@U:\dev\mcp-cli-rs\src\ipc\windows.rs
</context>

<tasks>

<task type="auto">
  <name>Implement UnixIpcClient::send_request with NDJSON protocol</name>
  <files>src/ipc/unix.rs</files>
  <action>
  Replace the duplicate stub implementations (lines 91-114) with a single working implementation:

  ```rust
  async fn send_request(&self, request: &crate::daemon::protocol::DaemonRequest) -> Result<crate::daemon::protocol::DaemonResponse, McpError> {
      // Connect to daemon
      let mut stream = self.connect(&self.socket_path).await?;

      // Split stream for reading and writing
      use tokio::io::{BufReader, AsyncBufReadExt, AsyncWriteExt};
      let (reader, mut writer) = tokio::io::split(stream);
      let mut buf_reader = BufReader::new(reader);

      // Send request using NDJSON protocol
      crate::daemon::protocol::send_request(&mut writer, request).await
          .map_err(|e| McpError::IpcError {
              message: format!("Failed to send IPC request: {}", e),
          })?;

      // Receive response using NDJSON protocol
      crate::daemon::protocol::receive_response(&mut buf_reader).await
          .map_err(|e| McpError::IpcError {
              message: format!("Failed to receive IPC response: {}", e),
          })
  }
  ```

  The daemon server implementation in src/daemon/mod.rs::handle_client (lines 161-190) already uses this exact pattern - mirror it for the client.

  DO NOT:
  - Remove other methods (config, connect - they work correctly)
  - Keep any "TODO" or stub comments
  - Use separate write/read logic - always use the protocol helpers
  </action>
  <verify>Check src/ipc/unix.rs:
  - Line 91 should start the send_request method (no duplicates)
  - Method calls connect(), splits stream, uses protocol::send_request()
  - Method calls protocol::receive_response(), returns Result<DaemonResponse, McpError>
  - No "not implemented yet" or TODO comments in send_request</verify>
  <done>UnixIpcClient::send_request() serializes request to NDJSON, writes to socket, reads response, deserializes, returns DaemonResponse</done>
</task>

<task type="auto">
  <name>Implement NamedPipeIpcClient::send_request with NDJSON protocol</name>
  <files>src/ipc/windows.rs</files>
  <action>
  Replacestub implementation (lines 96-108) with working implementation:

  ```rust
  async fn send_request(&mut self, request: &crate::daemon::protocol::DaemonRequest) -> Result<crate::daemon::protocol::DaemonResponse, McpError> {
      // Connect to daemon
      let mut stream = self.connect(&self.pipe_path).await?;

      // Split stream for reading and writing
      use tokio::io::{BufReader, AsyncBufReadExt, AsyncWriteExt};
      let (reader, mut writer) = tokio::io::split(stream);
      let mut buf_reader = BufReader::new(reader);

      // Send request using NDJSON protocol
      crate::daemon::protocol::send_request(&mut writer, request).await
          .map_err(|e| McpError::IpcError {
              message: format!("Failed to send IPC request: {}", e),
          })?;

      // Receive response using NDJSON protocol
      crate::daemon::protocol::receive_response(&mut buf_reader).await
          .map_err(|e| McpError::IpcError {
              message: format!("Failed to receive IPC response: {}", e),
          })
  }
  ```

  This is identical to the Unix implementation - the trait abstraction ensures both platforms use the same NDJSON protocol.

  DO NOT:
  - Change connect() method (it works correctly for named pipes)
  - Add platform-specific logic inside send_request (use protocol helpers only)
  - Keep stubs or TODO comments
  </action>
  <verify>Check src/ipc/windows.rs:
  - Line 96 should have send_request method (single implementation)
  - Method calls connect(), splits stream, uses protocol::send_request()
  - Method calls protocol::receive_response(), returns Result<DaemonResponse, McpError>
  - No "not implemented yet" or TODO comments</verify>
  <done>NamedPipeIpcClient::send_request() serializes request to NDJSON, writes to named pipe, reads response, deserializes, returns DaemonResponse</done>
</task>

</tasks>

<verification>
Build verification:
```bash
cargo build --release
cargo check
```

No compilation errors expected - code mirrors existing daemon server pattern.

Code verification:
- src/ipc/unix.rs: Only one send_request implementation (no duplicates)
- src/ipc/windows.rs: Single send_request implementation
- Both use protocol::send_request() and protocol::receive_response()
- No TODO or "not implemented" comments in send_request methods
</verification>

<success_criteria>
1. IPC clients can send DaemonRequest and receive DaemonResponse
2. NDJSON protocol correctly implemented (newline-delimited JSON)
3. All stub implementations removed from IPC clients
4. Code compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection-daemon-ipc/02-08-SUMMARY.md`
</output>
