---
phase: 02-connection-daemon-ipc
plan: 11
type: execute
wave: 3
depends_on: [02-08, 02-09, 02-10]
files_modified:
  - src/client/stdio.rs
  - tests/daemon_tests.rs
  - tests/ipc_tests.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "All integration tests compile without errors"
    - "cargo test --lib passes"
    - "tests/ipc_tests.rs exists with IPC communication tests"
    - "IPC roundtrip test sends request, receives response, validates content"
    - "Test compilation errors in stdio.rs and other test files are fixed"
  artifacts:
    - path: tests/ipc_tests.rs
      provides: IPC communication integration tests
      contains: "test_ipc_roundtrip", "test_concurrent_connections", "test_large_message_transfer"
      implementation: "Tests use IpcServer and IpcClient traits, send/receive NDJSON messages"
    - path: src/client/stdio.rs
      provides: Fixed test compilation (write_json no longer has await outside async)
    - path: tests/daemon_tests.rs
      provides: Fixed test compilation errors
  key_links:
    - from: "tests/ipc_tests.rs"
      to: "src/ipc/mod.rs::IpcServer", "src/ipc/mod.rs::IpcClient"
      via: "Test imports and usage"
      pattern: "use.*Ipc(Server|Client)"
    - from: "tests/ipc_tests.rs"
      to: "src/daemon/protocol.rs"
      via: "NDJSON protocol testing"
      pattern: "protocol::(send_request|receive_|send_response)"
---

<objective>
Fix test compilation errors and create missing IPC integration tests.

Purpose: Verification found two test-related gaps:
1. tests/ipc_tests.rs was specified in plan 02-06 but never created
2. cargo test --lib fails with 11 compilation errors (async/await mismatch, type errors, etc.)

Output: All tests compile and pass, with comprehensive IPC communication tests.

Gap: From verification report lines 59-75:
- tests/ipc_tests.rs does not exist (missing artifact)
- Integration test compilation failures (11 errors across multiple files)
- Specific error: src/client/stdio.rs test_write_json() at line 231 has await outside async function

</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/02-connection-daemon-ipc/02-VERIFICATION.md

# Existing test files (to fix compilation errors)
@U:\dev\mcp-cli-rs\tests\daemon_tests.rs
@U:\dev\mcp-cli-rs\src\client\stdio.rs

# IPC traits and protocol (for creating new IPC tests)
@U:\dev\mcp-cli-rs\src\ipc\mod.rs
@U:\dev\mcp-cli-rs\src\daemon\protocol.rs

# Plan 02-06 specification (what the test file should contain)
@U:\dev\mcp-cli-rs\.planning\phases\02-connection-daemon-ipc\02-06-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Fix test compilation error in stdio.rs</name>
  <files>src/client/stdio.rs</files>
  <action>
  Fix test_write_json() compilation error (line 231 - await outside async):

  1. Read the test around line 219-231 to understand the structure.
  2. If the test function is NOT marked as async, mark it async: `#[tokio::test] async fn test_write_json()`
  3. Ensure all .await calls are inside async context.

  If test_write_json() is actually a sync test that uses async code incorrectly:
  - Use a block with tokio::runtime::Runtime to execute async code in sync context
  - Or convert to async test using #[tokio::test]

  Example fix (if test is sync):
  ```rust
  #[test]
  fn test_write_json() {
      let rt = tokio::runtime::Runtime::new().unwrap();
      rt.block_on(async {
          // async test code here
          let mut writer = ...;
          writer.write_json(...).await.unwrap();
      });
  }
  ```

  Or (if test should be async):
  ```rust
  #[tokio::test]
  async fn test_write_json() {
      // async test code here
      let mut writer = ...;
      writer.write_json(...).await.unwrap();
  }
  ```

  Check for other test functions in the file with similar issues and fix them all.

  DO NOT:
  - Remove .await without making the function async (will cause other errors)
  - Add tokio::runtime if #[tokio::test] is simpler (prefer tokio::test)
  - Leave other test compilation errors unfixed in the file
  </action>
  <verify>
  Run: `cargo test --lib` and verify no errors from src/client/stdio.rs
  Check that test_write_json() compiles correctly (async/await in sync context resolved)
  </verify>
  <done>Test compilation errors in stdio.rs are fixed, test_write_json() compiles and runs correctly</done>
</task>

<task type="auto">
  <name>Fix remaining test compilation errors</name>
  <files>tests/daemon_tests.rs, src/client/stdio.rs</files>
  <action>
  Fix all remaining compilation errors from verification report:

  Run `cargo test --lib 2>&1 | head -50` to see the full list of errors.

  Common patterns to fix:
  1. E0405 (use of undeclared type) - Add missing imports at top of file
  2. E0425 (cannot find value) - Fix variable name or add missing variable
  3. E0428 (wrong number of type arguments) - Fix generic argument count
  4. E0728 (await outside async) - Mark test as #[tokio::test] or use runtime

  For each error:
  1. Identify the file and line
  2. Read context around error
  3. Apply appropriate fix (import, rename, type correction, async wrapper)
  4. Re-run cargo test to confirm error is gone

  Keep running `cargo test --lib` until all 11 errors are resolved.

  DO NOT:
  - Comment out failing tests (fix them properly)
  - Add #[ignore] without fixing (this defeats the purpose)
  - Skip type errors with unsafe workarounds - fix the actual types
  </action>
  <verify>
  Run: `cargo test --lib` and verify zero compilation errors
  Check that all tests compile successfully
  Verify specifically that the 11 errors from verification report are all fixed
  </verify>
  <done>All test compilation errors are resolved, cargo test --lib compiles successfully</done>
</task>

<task type="auto">
  <name>Create IPC integration tests (tests/ipc_tests.rs)</name>
  <files>tests/ipc_tests.rs</files>
  <action>
  Create new test file with IPC communication tests as specified in plan 02-06:

  tests/ipc_tests.rs:
  ```rust
  //! IPC communication integration tests
  //!
  //! Tests platform-specific IPC implementations (Unix sockets vs Windows named pipes)
  //! using the unified IpcServer and IpcClient traits.

  use std::path::PathBuf;
  use std::time::Duration;

  #[cfg(test)]
  mod ipc_tests {
      use super::*;
      use mcp_cli_rs::daemon::protocol::{DaemonRequest, DaemonResponse};
      use tokio::time::{timeout, sleep};

      /// Get a temporary socket/pipe path for testing
      fn get_test_socket_path() -> PathBuf {
          #[cfg(unix)]
          {
              let mut path = std::env::temp_dir();
              path.push(format!("mcp-test-{}.sock", std::process::id()));
              path
          }
          #[cfg(windows)]
          {
              let mut path = std::env::temp_dir();
              path.push(format!("\\\\.\\pipe\\mcp-test-{}", std::process::id()));
              path
          }
      }

      /// Test IPC roundtrip request/response
      #[tokio::test]
      async fn test_ipc_roundtrip() {
          let socket_path = get_test_socket_path();

          // Create IPC server
          let mut server = mcp_cli_rs::ipc::create_ipc_server(&socket_path, None)
              .expect("Failed to create IPC server");

          // Spawn server task
          let server_handle = tokio::spawn(async move {
              let (mut stream, _addr) = timeout(Duration::from_secs(5), server.accept())
                  .await
                  .expect("Server accept timed out")
                  .expect("Failed to accept connection");

              // Read request
              let request = mcp_cli_rs::daemon::protocol::receive_request(&mut stream)
                  .await
                  .expect("Failed to receive request");

              // Send response
              let response = DaemonResponse::Pong;
              mcp_cli_rs::daemon::protocol::send_response(&mut stream, &response)
                  .await
                  .expect("Failed to send response");
          });

          // Create IPC client
          let client = mcp_cli_rs::ipc::create_ipc_client(&socket_path)
              .expect("Failed to create IPC client");

          // Send request and get response
          let request = DaemonRequest::Ping;
          let response = client.send_request(&request)
              .await
              .expect("Failed to send request");

          // Verify response
          assert!(matches!(response, DaemonResponse::Pong));

          // Wait for server to complete
          timeout(Duration::from_secs(5), server_handle)
              .await
              .expect("Server task timed out")
              .expect("Server task failed")
              .expect("Server failed");

          // Clean up socket
          #[cfg(unix)]
          {
              let _ = std::fs::remove_file(&socket_path);
          }
      }

      /// Test concurrent IPC connections
      #[tokio::test]
      async fn test_concurrent_connections() {
          let socket_path = get_test_socket_path();

          // Create IPC server
          let mut server = mcp_cli_rs::ipc::create_ipc_server(&socket_path, None)
              .expect("Failed to create IPC server");

          // Spawn server task to handle multiple connections
          let server_handle = tokio::spawn(async move {
              for _ in 0..3 {
                  let (mut stream, _addr) = timeout(Duration::from_secs(5), server.accept())
                      .await
                      .expect("Server accept timed out")
                      .expect("Failed to accept connection");

                  // Read request
                  let request = mcp_cli_rs::daemon::protocol::receive_request(&mut stream)
                      .await
                      .expect("Failed to receive request");

                  // Send response
                  let response = DaemonResponse::Pong;
                  mcp_cli_rs::daemon::protocol::send_response(&mut stream, &response)
                      .await
                      .expect("Failed to send response");
              }
          });

          // Wait for server to start
          sleep(Duration::from_millis(100)).await;

          // Create 3 concurrent client connections
          let client_handles = (0..3).map(|i| {
              let socket_path = socket_path.clone();
              tokio::spawn(async move {
                  let client = mcp_cli_rs::ipc::create_ipc_client(&socket_path)
                      .expect("Failed to create IPC client");

                  let request = DaemonRequest::Ping;
                  client.send_request(&request).await
              })
          }).collect::<Vec<_>>();

          // Wait for all clients to complete
          for (i, handle) in client_handles.into_iter().enumerate() {
              let result = timeout(Duration::from_secs(5), handle)
                  .await
                  .expect(&format!("Client {} timed out", i))
                  .expect(&format!("Client {} task failed", i))
                  .expect(&format!("Client {} send_request failed", i));

              assert!(matches!(result, DaemonResponse::Pong));
          }

          // Wait for server to complete
          timeout(Duration::from_secs(5), server_handle)
              .await
              .expect("Server task timed out")
              .expect("Server task failed")
              .expect("Server failed");

          // Clean up
          #[cfg(unix)]
          {
              let _ = std::fs::remove_file(&socket_path);
          }
      }

      /// Test large message transfer over IPC
      #[tokio::test]
      async fn test_large_message_transfer() {
          let socket_path = get_test_socket_path();

          // Create IPC server
          let mut server = mcp_cli_rs::ipc::create_ipc_server(&socket_path, None)
              .expect("Failed to create IPC server");

          // Create large JSON object (simulating tool response with big content)
          let large_content = serde_json::json!({
              "text": "a".repeat(1_000_000)  // 1MB text
          });

          let server_content = large_content.clone();

          // Spawn server task
          let server_handle = tokio::spawn(async move {
              let (mut stream, _addr) = timeout(Duration::from_secs(5), server.accept())
                  .await
                  .expect("Server accept timed out")
                  .expect("Failed to accept connection");

              // Read request
              let request = mcp_cli_rs::daemon::protocol::receive_request(&mut stream)
                  .await
                  .expect("Failed to receive request");

              // Send large response
              let response = DaemonResponse::ToolResult(server_content);
              mcp_cli_rs::daemon::protocol::send_response(&mut stream, &response)
                  .await
                  .expect("Failed to send response");
          });

          // Create IPC client
          let client = mcp_cli_rs::ipc::create_ipc_client(&socket_path)
              .expect("Failed to create IPC client");

          // Send ping request
          let request = DaemonRequest::Ping;
          let response = client.send_request(&request)
              .await
              .expect("Failed to send request");

          // Verify large content was transferred correctly
          assert!(matches!(response, DaemonResponse::ToolResult(_)));
          if let DaemonResponse::ToolResult(content) = response {
              assert_eq!(content, large_content);
          }

          // Wait for server to complete
          timeout(Duration::from_secs(10), server_handle)
              .await
              .expect("Server task timed out")
              .expect("Server task failed")
              .expect("Server failed");

          // Clean up
          #[cfg(unix)]
          {
              let _ = std::fs::remove_file(&socket_path);
          }
      }
  }
  ```

  This implementation uses the unified IpcServer/IpcClient traits, tests both request/response roundtrip, concurrent connections, and large message transfer.

  DO NOT:
  - Hardcode Unix-specific paths (use cfg!)
  - Skip cleanup (remove socket files after tests)
  - Forget timeout on async operations (tests could hang)
  - Use platform-specific code without #[cfg] guards
  </action>
  <verify>
  run: `cargo test -p mcp-cli-rs --test ipc_tests`
  Check: tests/ipc_tests.rs file exists at tests/ipc_tests.rs
  Verify: test_ipc_roundtrip, test_concurrent_connections, test_large_message_transfer all pass
  </verify>
  <done>tests/ipc_tests.rs created with three integration tests: IPC roundtrip, concurrent connections, large message transfer. All tests compile and pass.</done>
</task>

</tasks>

<verification>
Complete test suite verification:
```bash
# Compile check
cargo check --tests

# Run all lib tests
cargo test --lib

# Run IPC tests specifically
cargo test -p mcp-cli-rs --test ipc_tests

# Run daemon tests
cargo test -p mcp-cli-rs --test daemon_tests
```

All should pass with no compilation errors.

Code verification:
- tests/ipc_tests.rs exists and has 3 tests
- stdio.rs test_write_json compiles correctly
- All 11 test compilation errors are fixed
- No #[ignore] tests (all tests run)
</verification>

<success_criteria>
1. All tests compile without errors (cargo test --lib)
2. tests/ipc_tests.rs exists with comprehensive IPC tests
3. IPC roundtrip test verifies Ping/Pong communication
4. Concurrent connections test handles multiple simultaneous connections
5. Large message transfer test validates protocol with 1MB+ messages
6. All tests pass (no #[ignore] or failing tests)
</success_criteria>

<output>
After completion, create `.planning/phases/02-connection-daemon-ipc/02-11-SUMMARY.md`
</output>
