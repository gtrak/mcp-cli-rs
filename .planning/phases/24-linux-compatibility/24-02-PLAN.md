---
phase: 24-linux-compatibility
plan: 02
type: execute
wave: 1
depends_on: [24-01]
files_modified:
  - src/lib.rs
  - src/ipc/mod.rs
autonomous: true

must_haves:
  truths:
    - "create_ipc_server is properly exported for all platforms"
    - "Linux build compiles without 'unresolved import' errors"
    - "Tests can use create_ipc_server on Unix platforms"
  artifacts:
    - path: "src/ipc/mod.rs"
      provides: "Unix implementation of create_ipc_server"
      contains: "#[cfg(unix)]\npub fn create_ipc_server"
    - path: "src/lib.rs"
      provides: "Platform-agnostic export"
      contains: "pub use ipc::{create_ipc_server"
  key_links:
    - from: "src/lib.rs"
      to: "src/ipc/mod.rs"
      via: "pub use ipc::create_ipc_server"
      pattern: "create_ipc_server"
---

<objective>
Fix create_ipc_server platform compatibility by adding Unix implementation.

Purpose: The `create_ipc_server` function is currently only defined for Windows (#[cfg(windows)]), but it's exported unconditionally in lib.rs. This causes compilation failures on Linux. Add a Unix implementation using UnixIpcServer.

Output: Unix implementation of create_ipc_server in src/ipc/mod.rs.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@src/lib.rs
@src/ipc/mod.rs

## Current State
- lib.rs line 28: `pub use ipc::{create_ipc_server, get_socket_path};` - unconditional export
- ipc/mod.rs lines 247-252: `create_ipc_server` only defined for Windows with `#[cfg(windows)]`
- UnixIpcServer exists in ipc/unix.rs and can be instantiated

## Requirements Coverage
- LINUX-05: Windows-only exports properly gated with cfg attributes
- LINUX-06: IPC method signatures compatible across platforms
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Unix implementation of create_ipc_server</name>
  <files>src/ipc/mod.rs</files>
  <action>
Add a Unix implementation of `create_ipc_server` right after the Windows implementation (around line 252).

Add this code:
```rust
/// Factory function to create platform-specific IPC server
///
/// Returns `Box<dyn IpcServer>` with platform-specific implementation
#[cfg(unix)]
pub fn create_ipc_server(path: &Path) -> Result<Box<dyn IpcServer>, McpError> {
    Ok(Box::new(crate::ipc::unix::UnixIpcServer::new(path)?))
}
```

Note: The UnixIpcServer::new is async, so we need to handle this differently. Check the actual signature in src/ipc/unix.rs line 24 - it's `pub async fn new`. Since create_ipc_server is not async, we may need to either:
1. Make create_ipc_server async (breaking change), or
2. Use tokio::runtime::Handle::current().block_on() (not ideal), or
3. Check if there's a blocking alternative

Actually, looking at the code more carefully:
- Windows NamedPipeIpcServer::new is synchronous
- Unix UnixIpcServer::new is async

We should check if we can make them consistent or handle the async case. For now, let's see if there's a way to call the async function synchronously or if we need to change the signature.

The cleanest fix is to check if UnixIpcServer::new can be called in a blocking context using tokio::runtime::Handle, but this requires runtime availability. Alternatively, we could make create_ipc_server async, but that would be a larger change.

For the minimal fix, let's use block_on if we're in a tokio context, or document that this requires a runtime. Actually, the better approach is to check how it's currently being used in tests.
  </action>
  <verify>grep -A5 "#\[cfg(unix)\]" src/ipc/mod.rs | grep "create_ipc_server"</verify>
  <done>Unix implementation of create_ipc_server exists in ipc/mod.rs</done>
</task>

<task type="auto">
  <name>Task 2: Fix UnixIpcServer::new async compatibility</name>
  <files>src/ipc/mod.rs</files>
  <action>
The UnixIpcServer::new is async, but create_ipc_server is synchronous. We need to handle this mismatch.

Option 1: Use tokio::runtime::Handle::current().block_on() (requires active runtime)
Option 2: Check if we can spawn a new thread with a runtime

Looking at the test usage, create_ipc_server is called from within async test functions using tokio::test. The issue is that the function signature itself is sync, but the implementation needs async.

The cleanest solution is to use block_on if in a runtime context:

```rust
#[cfg(unix)]
pub fn create_ipc_server(path: &Path) -> Result<Box<dyn IpcServer>, McpError> {
    use tokio::runtime::Handle;
    
    let server = Handle::try_current()
        .map_err(|e| McpError::IpcError {
            message: format!("No Tokio runtime available for IPC server creation: {}", e),
        })?
        .block_on(crate::ipc::unix::UnixIpcServer::new(path))?;
    
    Ok(Box::new(server))
}
```

However, this feels hacky. Let me reconsider - the real issue is that the Windows and Unix implementations have different signatures. The proper fix might be to make UnixIpcServer::new synchronous, or to make create_ipc_server async.

For now, let's implement the block_on approach as it's the minimal change that preserves the existing API.
  </action>
  <verify>cargo check --lib 2>&1 | head -20</verify>
  <done>create_ipc_server compiles on Unix with async runtime handling</done>
</task>

<task type="auto">
  <name>Task 3: Verify lib.rs export compiles</name>
  <files>src/lib.rs</files>
  <action>
Verify that the unconditional export in lib.rs now works because create_ipc_server is defined for both platforms.

Run `cargo check --lib` to ensure the export compiles correctly.
  </action>
  <verify>cargo check --lib</verify>
  <done>lib.rs exports compile without unresolved import errors</done>
</task>

</tasks>

<verification>
After this plan completes:
1. `cargo check --lib` should succeed
2. No "unresolved import" errors for create_ipc_server
3. Both Windows and Unix implementations exist
</verification>

<success_criteria>
- [ ] Unix implementation of create_ipc_server exists
- [ ] Handles async UnixIpcServer::new appropriately
- [ ] cargo check --lib passes
- [ ] LINUX-05 and LINUX-06 requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/24-linux-compatibility/24-02-SUMMARY.md` documenting:
- Platform implementations added
- Async/sync compatibility handling
- Compilation verification results
</output>
