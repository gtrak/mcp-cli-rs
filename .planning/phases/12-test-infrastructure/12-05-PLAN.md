---
phase: 12-test-infrastructure
plan: 05
type: execute
wave: 5
depends_on: [12-03]
files_modified: [tests/cross_platform_daemon_tests.rs, tests/unix/mod.rs, tests/unix/tests.rs, tests/unix/common_tests.rs, tests/windows/mod.rs, tests/windows/tests.rs, tests/windows/common_tests.rs, tests/common/mod.rs]
autonomous: false

must_haves:
  truths:
    - "cross_platform_daemon_tests.rs split into tests/unix/*.rs, tests/windows/*.rs, tests/common/*.rs"
    - "7 Unix tests organized in tests/unix/"
    - "9 Windows tests organized in tests/windows/"
    - "Common test patterns shared via tests/common/"
    - "All 16 tests pass with identical behavior after reorganization"
    - "Test coverage maintained (same tests, just organized differently)"
  artifacts:
    - path: "tests/unix/mod.rs"
      provides: "Unix-specific test module"
      min_lines: 10
    - path: "tests/unix/tests.rs"
      provides: "Unix socket tests"
      min_lines: 100
    - path: "tests/windows/mod.rs"
      provides: "Windows-specific test module"
      min_lines: 10
    - path: "tests/windows/tests.rs"
      provides: "Windows named pipe tests"
      min_lines: 150
    - path: "tests/common/mod.rs"
      provides: "Common test patterns shared across platforms"
      min_lines: 50
  key_links:
    - from: "tests/unix/mod.rs"
      to: "tests/unix/tests.rs"
      via: "mod statements"
      pattern: "mod tests;"
    - from: "tests/windows/mod.rs"
      to: "tests/windows/tests.rs"
      via: "mod statements"
      pattern: "mod tests;"
    - from: "tests/common/mod.rs"
      to: "tests/unix/tests.rs"
      via: "use crate::common::"
      pattern: "use crate::common::"
    - from: "tests/common/mod.rs"
      to: "tests/windows/tests.rs"
      via: "use crate::common::"
      pattern: "use crate::common::"
</context>

---

<objective>
Split cross_platform_daemon_tests.rs into platform-organized test modules

Purpose: Organize 785-line file into tests/unix/*.rs, tests/windows/*.rs, tests/common/*.rs for better maintainability (TEST-06, TEST-07)
Output: Well-organized test structure with clear platform separation
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
@.planning/phases/12-test-infrastructure/12-03-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference: Original file after refactoring (plan 12-03)
@tests/cross_platform_daemon_tests.rs (now ~580-620 lines after helper refactor)

# Helpers available
@tests/helpers.rs
</context>

<tasks>

<task type="auto">
  <name>Create tests/unix/mod.rs and organize Unix tests</name>
  <files>tests/unix/mod.rs, tests/unix/tests.rs</files>
  <action>
Create Unix test module structure:

1. Create tests/unix/mod.rs:
```rust
//! Unix-specific IPC tests
//!
//! Tests Unix socket communication on Linux and macOS

#[cfg(test)]
pub mod tests;
```

2. Create tests/unix/tests.rs:

Extract all Unix-specific tests from cross_platform_daemon_tests.rs:
- get_unix_test_socket_path (if still exists, else use helper)
- test_unix_socket_creation
- test_unix_socket_client_server_roundtrip
- test_unix_socket_multiple_concurrent_connections
- test_unix_socket_large_message_transfer
- Any other #[cfg(unix)] tests

Header for tests/unix/tests.rs:
```rust
//! Unix socket communication tests
//!
//! XP-04: Validates Unix socket (Linux/macOS) IPC implementation

use mcp_cli_rs::daemon::protocol::{DaemonRequest, DaemonResponse};
use mcp_cli_rs::ipc;
use std::path::PathBuf;

#[cfg(test)]
mod helpers;
```

Each test should use crate::helpers:: for path generation and other helpers.

Expected: ~250-300 lines in tests/unix/tests.rs (7 Unix tests)
</action>
  <verify>ls -la tests/unix/ && cat tests/unix/mod.rs && cargo test unix::test_unix --lib 2>&1 | tail -20</verify>
  <done>Created tests/unix/ module with 7 Unix tests</done>
</task>

<task type="auto">
  <name>Create tests/windows/mod.rs and organize Windows tests</name>
  <files>tests/windows/mod.rs, tests/windows/tests.rs</files>
  <action>
Create Windows test module structure:

1. Create tests/windows/mod.rs:
```rust
//! Windows-specific IPC tests
//!
//! Tests named pipe communication on Windows

#[cfg(test)]
pub mod tests;
```

2. Create tests/windows/tests.rs:

Extract all Windows-specific tests from cross_platform_daemon_tests.rs:
- get_windows_test_pipe_name (if still exists, else use helper)
- test_windows_named_pipe_creation
- test_windows_named_pipe_client_server_roundtrip
- test_windows_named_pipe_multiple_concurrent_connections
- test_windows_named_pipe_large_message_transfer
- Any other #[cfg(windows)] tests

Header for tests/windows/tests.rs:
```rust
//! Windows named pipe communication tests
//!
//! XP-04: Validates named pipe (Windows) IPC implementation

use mcp_cli_rs::daemon::protocol::{DaemonRequest, DaemonResponse};
use mcp_cli_rs::ipc;
use std::path::PathBuf;

#[cfg(test)]
mod helpers;
```

Each test should use crate::helpers:: for path generation and other helpers.

Expected: ~350-400 lines in tests/windows/tests.rs (9 Windows tests)
</action>
  <verify>ls -la tests/windows/ && cat tests/windows/mod.rs && cargo test windows::test_windows --lib 2>&1 | tail -20</verify>
  <done>Created tests/windows/ module with 9 Windows tests</done>
</task>

<task type="auto">
  <name>Create tests/common/mod.rs for shared test patterns</name>
  <files>tests/common/mod.rs</files>
  <action>
Create common test patterns module:

1. Create tests/common/mod.rs:
```rust
//! Common test patterns shared across platforms
//!
//! Provides utilities and patterns used by both Unix and Windows tests

use mcp_cli_rs::daemon::protocol::{DaemonRequest, DaemonResponse};
use mcp_cli_rs::ipc;
use std::path::PathBuf;

#[cfg(test)]
mod helpers;

/// Test helper: IPC roundtrip with timeout
///
/// Common pattern used across platform-specific tests
pub async fn test_ipc_roundtrip_with_timeout(
    socket_path: PathBuf,
    request: DaemonRequest,
    expected_response: DaemonResponse,
) -> anyhow::Result<()> {
    // Implementation using helpers and common patterns
    let mut server = ipc::create_ipc_server(&socket_path)?;
    let server_handle = tokio::spawn(async move {
        let (mut stream, _addr) = tokio::time::timeout(
            tokio::time::Duration::from_secs(5),
            server.accept()
        ).await??;

        let mut buf_reader = tokio::io::BufReader::new(stream);
        let req = mcp_cli_rs::daemon::protocol::receive_request(&mut buf_reader)
            .await
            .expect("Failed to receive request");

        assert!(matches!(req, request));

        mcp_cli_rs::daemon::protocol::send_response(&mut buf_reader, &expected_response)
            .await
            .expect("Failed to send response");
    });

    tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;

    let config = std::sync::Arc::new(mcp_cli_rs::config::Config::with_socket_path(socket_path.clone()));
    let mut client = ipc::create_ipc_client(config)?;

    let response = client.send_request(&request).await?;
    assert!(
        std::mem::discriminant(&response) == std::mem::discriminant(&expected_response)
    );

    server_handle.await?;

    #[cfg(unix)]
    {
        let _ = std::fs::remove_file(&socket_path);
    }

    Ok(())
}

/// Additional common test patterns as needed
```

This module extracts patterns that are truly common between Unix and Windows tests.

Expected: ~100-150 lines in tests/common/mod.rs
</action>
  <verify>cat tests/common/mod.rs && cargo check --tests 2>&1 | head -20</verify>
  <done>Created tests/common/ module with shared patterns</done>
</task>

<task type="auto">
  <name>Update cross_platform_daemon_tests.rs to include platform modules</name>
  <files>tests/cross_platform_daemon_tests.rs</files>
  <action>
Update tests/cross_platform_daemon_tests.rs to be a thin orchestrator:

1. Replace entire file content with:
```rust
//! Cross-platform IPC validation tests for daemon communication.
//!
//! XP-04: Validates daemon works on Linux, macOS, Windows
//!
//! This module orchestrates platform-specific tests organized in:
//! - tests/unix/tests.rs (Unix socket tests for Linux/macOS)
//! - tests/windows/tests.rs (Named pipe tests for Windows)
//! - tests/common/mod.rs (Shared test patterns)

#[cfg(test)]
mod unix;
#[cfg(test)]
mod windows;
#[cfg(test)]
mod common;

// Tests are defined in platform-specific modules
// Unix tests run on Linux/macOS automatically via #[cfg(unix)]
// Windows tests run on Windows automatically via #[cfg(windows)]
```

2. Verify that all test symbols are now exported from the platform modules

Expected: cross_platform_daemon_tests.rs reduced to ~20-30 lines (just module declarations and docs)
</action>
  <verify>wc -l tests/cross_platform_daemon_tests.rs && cargo test cross_platform_daemon_tests --lib 2>&1 | tail -20</verify>
  <done>cross_platform_daemon_tests.rs updated to platform module orchestrator</done>
</task>

<task type="auto">
  <name>Verify all 16 tests pass after reorganization</name>
  <files>tests/unix/tests.rs, tests/windows/tests.rs, tests/cross_platform_daemon_tests.rs</files>
  <action>
Run comprehensive test suite to verify behavior unchanged:

```bash
# Run all cross-platform daemon tests
cargo test cross_platform_daemon_tests --lib -- --show-output

# Run Unix-specific tests
cargo test unix::test_unix --lib

# Run Windows-specific tests (only on Windows)
cargo test windows::test_windows --lib

# Verify total test count is 16
cargo test cross_platform_daemon_tests --lib 2>&1 | grep "test result"
```

Expected results:
- test result: ok. 16 passed
- 7 Unix tests run on Linux/macOS
- 9 Windows tests run on Windows
- Test behavior identical to original file

Count test organization:
```bash
echo "Unix tests: $(grep -c "^async fn test_unix" tests/unix/tests.rs)"
echo "Windows tests: $(grep -c "^async fn test_windows" tests/windows/tests.rs)"
```

Expected: Unix: 7, Windows: 9
</action>
  <verify>cargo test cross_platform_daemon_tests --lib 2>&1 | grep -E "(test result|running)" && echo "Unix: $(grep -c "^async fn test_unix" tests/unix/tests.rs), Windows: $(grep -c "^async fn test_windows" tests/windows/tests.rs)"</verify>
  <done>All 16 tests pass, test organized by platform</done>
</task>

</tasks>

<verification>
After completion:
```bash
# Verify folder structure
ls -la tests/unix/ tests/windows/ tests/common/

# Verify file sizes
echo "cross_platform_daemon_tests.rs: $(wc -l < tests/cross_platform_daemon_tests.rs) lines (originally 785)"
echo "unix/tests.rs: $(wc -l < tests/unix/tests.rs) lines"
echo "windows/tests.rs: $(wc -l < tests/windows/tests.rs) lines"
echo "common/mod.rs: $(wc -l < tests/common/mod.rs) lines"

# Verify all tests pass
cargo test cross_platform_daemon_tests --lib 2>&1 | grep "test result"
```

Expected: test result: ok. 16 passed
</verification>

<success_criteria>
- cross_platform_daemon_tests.rs reduced to ~20-30 lines (module orchestrator)
- tests/unix/tests.rs contains 7 Unix tests (~250-300 lines)
- tests/windows/tests.rs contains 9 Windows tests (~350-400 lines)
- tests/common/mod.rs contains shared patterns (~100-150 lines)
- All 16 tests pass with identical behavior
- Test coverage maintained (same tests, just organized)
- Code is now more maintainable with clear platform separation
- Unix tests only run on Linux/macOS (#[cfg(unix)])
- Windows tests only run on Windows (#[cfg(windows)])
</success_criteria>

<output>
After completion, create `.planning/phases/12-test-infrastructure/12-05-SUMMARY.md`
</output>
