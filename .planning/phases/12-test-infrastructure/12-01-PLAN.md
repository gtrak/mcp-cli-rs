---
phase: 12-test-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [tests/helpers.rs]
autonomous: true

must_haves:
  truths:
    - "TestEnvironment struct manages temporary directories for tests"
    - "Platform-specific socket/pipe path generators available with unified interface"
    - "IPC roundtrip helper functions exist for server/client patterns"
    - "Test config factory functions provide common server/tool configurations"
  artifacts:
    - path: "tests/helpers.rs"
      provides: "Test helper functions and structs"
      min_lines: 200
      exports: ["TestEnvironment", "get_test_socket_path", "run_ipc_roundtrip", "create_test_config"]
  key_links:
    - from: "tests/helpers.rs"
      to: "tempfile::TempDir"
      via: "struct TestEnvironment"
      pattern: "pub struct TestEnvironment"
    - from: "tests/helpers.rs"
      to: "tests/*.rs"
      via: "use statements in test files"
      pattern: "use crate::helpers::"
---

<objective>
Create comprehensive test helpers module to eliminate duplication across test files

Purpose: Extract common test setup patterns into reusable helpers, reducing ~200-300 lines of duplicated code
Output: tests/helpers.rs with TestEnvironment struct, path generators, IPC helpers, and config factories
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Reference: Existing duplication patterns
@tests/cross_platform_daemon_tests.rs  (lines 12-31: path generators)
@tests/ipc_tests.rs                    (lines 16-29: path generators)
@tests/cross_platform_daemon_tests.rs  (lines 95-127: IPC roundtrip pattern)
@tests/ipc_tests.rs                    (lines 46-73: IPC roundtrip pattern)
@tests/orphan_cleanup_tests.rs         (lines 24-30: TempDir pattern)
</context>

<tasks>

<task type="auto">
  <name>Create tests/helpers.rs module structure</name>
  <files>tests/helpers.rs</files>
  <action>
Create tests/helpers.rs with the following structure:

```rust
//! Test helpers for MCP CLI integration tests
//!
//! Provides common patterns for:
//! - Temporary directory management (TestEnvironment)
//! - Platform-specific socket/pipe path generation
//! - IPC server/client roundtrip patterns
//! - Test configuration factories

use std::path::PathBuf;
use std::sync::Arc;
use tempfile::TempDir;

use mcp_cli_rs::config::Config;
use mcp_cli_rs::daemon::protocol::{DaemonRequest, DaemonResponse};
use mcp_cli_rs::ipc;

/// Test environment with temporary directory cleanup
pub struct TestEnvironment {
    pub temp_dir: TempDir,
}

impl TestEnvironment {
    pub fn new() -> Self {
        Self {
            temp_dir: TempDir::new().expect("Failed to create temp directory"),
        }
    }

    pub fn path(&self) -> &std::path::Path {
        self.temp_dir.path()
    }
}

// Add remaining helper functions in subsequent tasks
```

Do NOT include path generators, IPC helpers, or config factories in this task - those will be added in subsequent tasks.
</action>
  <verify>grep -n "pub struct TestEnvironment" tests/helpers.rs && rustc --edition 2021 tests/helpers.rs --crate-type lib --allow warnings 2>&1 | head -20</verify>
  <done>tests/helpers.rs created with TestEnvironment struct</done>
</task>

<task type="auto">
  <name>Add platform-specific socket/pipe path generators</name>
  <files>tests/helpers.rs</files>
  <action>
Add unified path generation functions to tests/helpers.rs:

```rust
/// Get a platform-specific test socket/pipe path for testing
///
/// Returns Unix socket path on Linux/macOS (e.g., /tmp/mcp-test-12345.sock)
/// Returns Windows named pipe path on Windows (e.g., \\.\pipe\mcp-test-12345)
pub fn get_test_socket_path() -> PathBuf {
    #[cfg(unix)]
    {
        let mut path = std::env::temp_dir();
        path.push(format!("mcp-test-{}.sock", std::process::id()));
        path
    }
    #[cfg(windows)]
    {
        let mut path = std::env::temp_dir();
        path.push(format!(r"\\.\pipe\mcp-test-{}", std::process::id()));
        path
    }
}

/// Get a unique test socket/pipe path with custom suffix
///
/// Useful for creating multiple distinct test endpoints
pub fn get_test_socket_path_with_suffix(suffix: &str) -> PathBuf {
    #[cfg(unix)]
    {
        let mut path = std::env::temp_dir();
        path.push(format!("mcp-test-{}-{}.sock", std::process::id(), suffix));
        path
    }
    #[cfg(windows)]
    {
        let mut path = std::env::temp_dir();
        path.push(format!(
            r"\\.\pipe\mcp-test-{}-{}",
            std::process::id(),
            suffix
        ));
        path
    }
}
```

These replacements eliminate 3+ duplicate implementations across test files.
</action>
  <verify>grep -n "pub fn get_test_socket_path" tests/helpers.rs && grep -n "pub fn get_test_socket_path_with_suffix" tests/helpers.rs</verify>
  <done>Platform-specific path generators added with unified interface</done>
</task>

<task type="auto">
  <name>Add IPC roundtrip helper functions</name>
  <files>tests/helpers.rs</files>
  <action>
Add IPC roundtrip helpers to tests/helpers.rs:

```rust
use std::time::Duration;
use tokio::time::timeout;
use tokio::io::BufReader;

/// Run a simple IPC roundtrip test (Ping -> Pong)
///
/// Creates server, spawns task, sends Ping request, awaits Pong response.
/// This pattern is repeated across 10+ tests in the codebase.
pub async fn run_ping_pong_roundtrip(socket_path: PathBuf) -> anyhow::Result<()> {
    // Create IPC server
    let mut server = ipc::create_ipc_server(&socket_path)?;

    // Spawn server task
    let server_handle = tokio::spawn(async move {
        let (mut stream, _addr) =
            match timeout(Duration::from_secs(5), server.accept()).await {
                Ok(Ok(stream)) => stream,
                Ok(Err(e)) => panic!("Server accept failed: {}", e),
                Err(e) => panic!("Server accept timed out: {}", e),
            };

        // Read request
        let mut buf_reader = BufReader::new(stream);
        let request = mcp_cli_rs::daemon::protocol::receive_request(&mut buf_reader)
            .await
            .expect("Failed to receive request");

        // Verify Ping request
        assert!(matches!(request, DaemonRequest::Ping));

        // Send Pong response
        let response = DaemonResponse::Pong;
        mcp_cli_rs::daemon::protocol::send_response(&mut buf_reader, &response)
            .await
            .expect("Failed to send response");
    });

    // Give server time to start
    tokio::time::sleep(Duration::from_millis(500)).await;

    // Create IPC client
    let config = Arc::new(Config::with_socket_path(socket_path.clone()));
    let mut client = ipc::create_ipc_client(Arc::clone(&config))?;

    // Send Ping request
    let request = DaemonRequest::Ping;
    let response = client.send_request(&request).await?;

    // Verify Pong response
    assert!(matches!(response, DaemonResponse::Pong));

    // Wait for server to complete
    server_handle.await?;

    // Clean up socket (Unix only)
    #[cfg(unix)]
    {
        let _ = std::fs::remove_file(&socket_path);
    }

    Ok(())
}

/// Create an IPC server that handles a single request-response cycle
///
/// Returns a join handle for the server task
pub async fn spawn_single_response_server(
    socket_path: PathBuf,
    expected_request: DaemonRequest,
    response: DaemonResponse,
) -> tokio::task::JoinHandle<()> {
    let mut server = ipc::create_ipc_server(&socket_path)
        .expect("Failed to create IPC server");

    tokio::spawn(async move {
        let (mut stream, _addr) =
            match timeout(Duration::from_secs(5), server.accept()).await {
                Ok(Ok(stream)) => stream,
                Ok(Err(e)) => panic!("Server accept failed: {}", e),
                Err(e) => panic!("Server accept timed out: {}", e),
            };

        let mut buf_reader = BufReader::new(stream);
        let request = mcp_cli_rs::daemon::protocol::receive_request(&mut buf_reader)
            .await
            .expect("Failed to receive request");

        assert!(
            std::mem::discriminant(&request) == std::mem::discriminant(&expected_request),
            "Request type mismatch"
        );

        mcp_cli_rs::daemon::protocol::send_response(&mut buf_reader, &response)
            .await
            .expect("Failed to send response");
    })
}
```

This eliminates 10+ duplicate roundtrip implementations across test files.
</action>
  <verify>grep -n "pub async fn run_ping_pong_roundtrip" tests/helpers.rs && grep -n "pub async fn spawn_single_response_server" tests/helpers.rs</verify>
  <done>IPC roundtrip helper functions added covering 10+ duplicated patterns</done>
</task>

<task type="auto">
  <name>Add test configuration factory functions</name>
  <files>tests/helpers.rs</files>
  <action>
Add configuration factory functions to tests/helpers.rs:

```rust
/// Create a default test configuration
///
/// Provides a standard config for tests that don't need custom settings
pub fn create_test_config() -> Arc<Config> {
    Arc::new(Config::default())
}

/// Create a test configuration with custom socket path
///
/// Useful for tests that need to specify their own IPC endpoint
pub fn create_test_config_with_socket(socket_path: PathBuf) -> Arc<Config> {
    Arc::new(Config::with_socket_path(socket_path))
}

/// Create a test configuration with enabled tool
///
/// Useful for tool execution tests
pub fn create_test_config_with_tool(tool_name: &str) -> Arc<Config> {
    let mut config = Config::default();
    if let Some(tools) = &mut config.tools {
        tools.push(tool_name.to_string());
    }
    Arc::new(config)
}
```

These factory functions eliminate repeated Config::default() and Config::with_socket_path() patterns across test files.
</action>
  <verify>grep -n "pub fn create_test_config" tests/helpers.rs</verify>
  <done>Test config factory functions added</done>
</task>

</tasks>

<verification>
After completion, run:
```bash
cargo check --tests 2>&1 | head -30
```

Expected: No compilation errors in tests/helpers.rs

Verify helpers are usable in test context:
```bash
cargo test --help | grep "test"
```
</verification>

<success_criteria>
- tests/helpers.rs created with ~200-250 lines of helper code
- TestEnvironment struct for temp directory management
- get_test_socket_path() and get_test_socket_path_with_suffix() for platform-specific paths
- run_ping_pong_roundtrip() and spawn_single_response_server() for IPC patterns
- create_test_config(), create_test_config_with_socket(), create_test_config_with_tool() for config factories
- All helpers compile without errors when checked with cargo check --tests
</success_criteria>

<output>
After completion, create `.planning/phases/12-test-infrastructure/12-01-SUMMARY.md`
</output>
