---
phase: 05-unified-daemon-architecture
plan: 02
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - src/main.rs
  - src/cli/mod.rs
  - src/cli/daemon.rs
autonomous: true

must_haves:
  truths:
    - "`mcp daemon` command starts standalone persistent daemon"
    - "`mcp --auto-daemon list` spawns daemon if needed, executes command"
    - "`mcp --require-daemon list` fails if daemon not running"
    - "Default behavior (no flags) auto-spawns daemon as before"
  artifacts:
    - path: "src/main.rs"
      provides: "CLI with daemon subcommand and operational mode flags"
      exports: ["daemon command", "auto_daemon flag", "require_daemon flag"]
    - path: "src/cli/daemon.rs"
      provides: "Operational mode logic"
      exports: ["run_standalone_daemon", "run_auto_daemon_mode", "run_require_daemon_mode"]
  key_links:
    - from: "src/main.rs::Commands::Daemon"
      to: "src/daemon/mod.rs::run_daemon"
      via: "daemon command handler"
    - from: "src/main.rs::run()"
      to: "src/cli/daemon.rs"
      via: "operational mode dispatch"
---

<objective>
Implement three operational modes for the unified daemon architecture: standalone, auto-spawn, and require-daemon.

Purpose: Provide flexible operational modes for different use cases (DAEMON-02 through DAEMON-09)
Output: CLI with daemon subcommand and operational mode flags
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-unified-daemon-architecture/05-01-SUMMARY.md
@src/main.rs
@src/cli/daemon.rs

Current state:
- main.rs has --no-daemon flag for direct mode
- Daemon is auto-spawned via ensure_daemon() when not in direct mode
- Need to add explicit operational modes:
  1. Standalone: `mcp daemon` - starts daemon, runs until TTL/ctrl+c
  2. Auto-spawn: `mcp --auto-daemon <cmd>` - spawns if needed, auto-shutdown after TTL
  3. Require-daemon: `mcp --require-daemon <cmd>` - fails if daemon not running
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add operational mode flags to CLI</name>
  <files>src/main.rs</files>
  <action>
Add new global flags to the Cli struct in src/main.rs:

```rust
#[derive(Parser)]
#[command(name = "mcp")]
struct Cli {
    #[arg(short, long, global = true)]
    config: Option<std::path::PathBuf>,

    /// Run without daemon (direct mode)
    #[arg(long, global = true)]
    no_daemon: bool,

    /// Auto-spawn daemon if not running (default behavior)
    #[arg(long, global = true, conflicts_with = "no_daemon")]
    auto_daemon: bool,

    /// Require daemon to be already running (fail if not running)
    #[arg(long, global = true, conflicts_with_all = ["no_daemon", "auto_daemon"])]
    require_daemon: bool,

    #[command(subcommand)]
    command: Option<Commands>,
}
```

Note: Default behavior (no flags) should remain as auto-spawn (backward compatible).

Update the Commands enum to add the Daemon subcommand:
```rust
#[derive(Clone, Subcommand)]
enum Commands {
    /// Start the connection daemon
    Daemon {
        /// Daemon idle timeout in seconds
        #[arg(short, long, default_value = "60")]
        ttl: u64,
    },
    // ... existing commands
}
```
  </action>
  <verify>
grep -A5 "require_daemon" src/main.rs
grep -A3 "Commands::Daemon" src/main.rs
  </verify>
  <done>
Cli struct has auto_daemon and require_daemon flags, Commands enum has Daemon variant with ttl argument
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement standalone daemon command</name>
  <files>src/main.rs</files>
  <action>
Add handler for the Daemon command in the run() function:

```rust
async fn run(cli: Cli) -> Result<()> {
    // Handle daemon subcommand first (standalone mode)
    if let Some(Commands::Daemon { ttl }) = &cli.command {
        return run_standalone_daemon(*ttl).await;
    }

    // ... rest of existing run() logic
}
```

Implement run_standalone_daemon() function:
```rust
async fn run_standalone_daemon(ttl: u64) -> Result<()> {
    use mcp_cli_rs::config::loader::find_and_load;
    use mcp_cli_rs::ipc::get_socket_path;
    use mcp_cli_rs::daemon::run_daemon;

    tracing::info!("Starting standalone daemon with TTL: {}s", ttl);

    // Load configuration
    let config = find_and_load(None)
        .await
        .map_err(|e| mcp_cli_rs::error::McpError::ConfigError {
            message: format!("Failed to load configuration: {}", e),
        })?;

    // Get socket path
    let socket_path = get_socket_path();
    tracing::info!("Using socket path: {:?}", socket_path);

    // Remove existing socket file if present
    if let Err(e) = std::fs::remove_file(&socket_path) {
        if e.kind() != std::io::ErrorKind::NotFound {
            tracing::warn!("Could not remove existing socket file: {}", e);
        }
    }

    // Create daemon lifecycle with specified TTL
    let lifecycle = mcp_cli_rs::daemon::lifecycle::DaemonLifecycle::new(ttl);

    // Run daemon (this blocks until shutdown)
    tracing::info!("Daemon starting...");
    match run_daemon(config, socket_path, lifecycle).await {
        Ok(()) => {
            tracing::info!("Daemon exited normally");
            Ok(())
        }
        Err(e) => {
            tracing::error!("Daemon error: {}", e);
            Err(mcp_cli_rs::error::McpError::IOError {
                source: std::io::Error::new(std::io::ErrorKind::Other, e),
            })
        }
    }
}
```

Note: This requires modifying run_daemon() to accept a lifecycle parameter. If the current signature doesn't support this, adapt accordingly.
  </action>
  <verify>
grep -A20 "run_standalone_daemon" src/main.rs | head -25
  </verify>
  <done>
run_standalone_daemon function implemented, handles config loading and daemon startup with configurable TTL
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement operational mode dispatch</name>
  <files>src/main.rs, src/cli/daemon.rs</files>
  <action>
Update the run() function to handle the three operational modes:

```rust
async fn run(cli: Cli) -> Result<()> {
    // Handle daemon subcommand (standalone mode)
    if let Some(Commands::Daemon { ttl }) = &cli.command {
        return run_standalone_daemon(*ttl).await;
    }

    // Load configuration
    let config = if let Some(path) = &cli.config {
        load_config(path).await?
    } else {
        find_and_load(None).await?
    };

    let daemon_config = Arc::new(config);
    let shutdown = GracefulShutdown::new();
    shutdown.spawn_signal_listener();
    let shutdown_rx = shutdown.subscribe();

    // Determine operational mode
    let result = if cli.no_daemon {
        // Direct mode (existing behavior)
        run_with_graceful_shutdown(
            || run_direct_mode(&cli, Arc::clone(&daemon_config)),
            shutdown_rx,
        ).await?
    } else if cli.require_daemon {
        // Require-daemon mode: fail if daemon not running
        run_with_graceful_shutdown(
            || run_require_daemon_mode(&cli, Arc::clone(&daemon_config)),
            shutdown_rx,
        ).await?
    } else {
        // Auto-daemon mode (default): spawn if needed, use TTL
        // This replaces the old ensure_daemon behavior with TTL support
        run_with_graceful_shutdown(
            || run_auto_daemon_mode(&cli, Arc::clone(&daemon_config)),
            shutdown_rx,
        ).await?
    };

    Ok(result)
}
```

Add the new mode functions in src/cli/daemon.rs:

```rust
/// Run in auto-daemon mode: spawn if needed, execute command, daemon auto-shutdowns after TTL
pub async fn run_auto_daemon_mode(
    cli: &crate::main::Cli,
    config: Arc<Config>,
) -> Result<()> {
    // Check if daemon is running
    let socket_path = crate::ipc::get_socket_path();
    
    match try_connect_to_daemon(config.clone(), &socket_path).await {
        Ok(client) => {
            // Daemon is running, use it
            tracing::info!("Using existing daemon");
            execute_command(cli, client).await
        }
        Err(_) => {
            // Daemon not running, spawn it
            tracing::info!("Daemon not running, spawning...");
            
            // Get TTL from env var or use default (60s)
            let ttl = std::env::var("MCP_DAEMON_TTL")
                .ok()
                .and_then(|v| v.parse().ok())
                .unwrap_or(60);
            
            // Spawn daemon as background task
            let config_clone = Arc::clone(&config);
            tokio::spawn(async move {
                if let Err(e) = spawn_standalone_daemon(config_clone, ttl).await {
                    tracing::error!("Failed to spawn daemon: {}", e);
                }
            });
            
            // Wait for daemon to start
            tokio::time::sleep(Duration::from_millis(500)).await;
            
            // Connect and execute
            let client = try_connect_to_daemon(config, &socket_path).await
                .map_err(|e| McpError::io_error(
                    std::io::Error::new(std::io::ErrorKind::Other, e)
                ))?;
            
            execute_command(cli, client).await
        }
    }
}

/// Run in require-daemon mode: fail if daemon not running
pub async fn run_require_daemon_mode(
    cli: &crate::main::Cli,
    config: Arc<Config>,
) -> Result<()> {
    let socket_path = crate::ipc::get_socket_path();
    
    match try_connect_to_daemon(config.clone(), &socket_path).await {
        Ok(client) => {
            tracing::info!("Using existing daemon");
            execute_command(cli, client).await
        }
        Err(_) => {
            Err(McpError::DaemonNotRunning {
                message: "Daemon is not running. Start it with 'mcp daemon' or use --auto-daemon".to_string(),
            })
        }
    }
}

async fn try_connect_to_daemon(config: Arc<Config>, socket_path: &Path) -> Result<Box<dyn ProtocolClient>> {
    crate::ipc::create_ipc_client(config)
}

async fn spawn_standalone_daemon(config: Arc<Config>, ttl: u64) -> Result<()> {
    // Similar to run_standalone_daemon but for background spawning
    // This would need to be implemented based on daemon/mod.rs capabilities
    todo!("Implement background daemon spawning")
}
```

Note: The actual implementation will need to adapt to the existing codebase structure. The key is to:
1. Support --auto-daemon (spawn if needed)
2. Support --require-daemon (fail if not running)
3. Support `mcp daemon` (start standalone)
  </action>
  <verify>
grep -A10 "run_auto_daemon_mode\|run_require_daemon_mode" src/cli/daemon.rs | head -20
grep "DaemonNotRunning" src/error.rs
  </verify>
  <done>
Three operational modes implemented:
- Auto-daemon mode spawns daemon if needed
- Require-daemon mode fails with clear error if daemon not running
- Standalone mode available via `mcp daemon` command
  </done>
</task>

<task type="auto">
  <name>Task 4: Add DaemonNotRunning error variant</name>
  <files>src/error.rs</files>
  <action>
Add a new error variant for when daemon is required but not running:

```rust
#[derive(Error, Debug)]
pub enum McpError {
    // ... existing variants

    /// Daemon is required but not running
    #[error("Daemon not running: {message}")]
    DaemonNotRunning { message: String },
}
```

Update exit_code function to return appropriate exit code (e.g., 2 for server errors):

```rust
pub fn exit_code(error: &McpError) -> i32 {
    match error {
        // ... existing cases
        McpError::DaemonNotRunning { .. } => 2, // Server error (daemon is a server component)
    }
}
```
  </action>
  <verify>
grep -A2 "DaemonNotRunning" src/error.rs
  </verify>
  <done>
DaemonNotRunning error variant added with appropriate exit code (2)
  </done>
</task>

</tasks>

<verification>
- [ ] `mcp daemon --ttl 120` starts standalone daemon
- [ ] `mcp --require-daemon list` fails with clear error if daemon not running
- [ ] `mcp --auto-daemon list` spawns daemon if needed and executes command
- [ ] `mcp list` (no flags) maintains backward compatible auto-spawn behavior
- [ ] All tests pass: `cargo test`
</verification>

<success_criteria>
Three operational modes working:
- Standalone: `mcp daemon [--ttl N]` starts persistent daemon
- Auto-spawn: `--auto-daemon` spawns daemon if needed (or default behavior)
- Require-daemon: `--require-daemon` fails gracefully if daemon not running
- Clear error messages for daemon dependency failures
</success_criteria>

<output>
After completion, create `.planning/phases/05-unified-daemon-architecture/05-02-SUMMARY.md`
</output>
