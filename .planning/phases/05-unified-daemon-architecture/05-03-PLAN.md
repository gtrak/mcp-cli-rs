---
phase: 05-unified-daemon-architecture
plan: 03
type: execute
wave: 2
depends_on:
  - 05-01
  - 05-02
files_modified:
  - src/config/mod.rs
  - src/daemon/lifecycle.rs
  - src/daemon/mod.rs
  - src/main.rs
autonomous: true

must_haves:
  truths:
    - "TTL configurable via --ttl flag (DAEMON-03)"
    - "TTL configurable via MCP_DAEMON_TTL env var (DAEMON-10)"
    - "TTL configurable via config file daemon_ttl field (DAEMON-11)"
    - "Default TTL is 60 seconds"
  artifacts:
    - path: "src/config/mod.rs"
      provides: "daemon_ttl configuration field"
      must_contain: "daemon_ttl: u64"
    - path: "src/main.rs"
      provides: "TTL flag handling for daemon command"
      must_contain: "ttl: u64"
    - path: "src/daemon/lifecycle.rs"
      provides: "Configurable TTL in lifecycle"
      must_contain: "timeout_secs: u64"
  key_links:
    - from: "Config::daemon_ttl"
      to: "DaemonLifecycle"
      via: "TTL passed to lifecycle initialization"
    - from: "MCP_DAEMON_TTL env var"
      to: "run_standalone_daemon"
      via: "std::env::var"
---

<objective>
Add configurable TTL (time-to-live) for daemon idle timeout via flag, environment variable, and config file.

Purpose: Allow users to customize daemon lifetime (DAEMON-03, DAEMON-10, DAEMON-11)
Output: TTL configuration support across all configuration layers
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/05-unified-daemon-architecture/05-01-SUMMARY.md
@.planning/phases/05-unified-daemon-architecture/05-02-SUMMARY.md
@src/config/mod.rs
@src/daemon/lifecycle.rs
@src/daemon/mod.rs

Current state:
- Daemon lifecycle has hardcoded 60s timeout
- Config struct has no daemon_ttl field
- Need to add TTL configuration at multiple layers
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add daemon_ttl to Config struct</name>
  <files>src/config/mod.rs</files>
  <action>
Add daemon_ttl field to the Config struct:

```rust
#[derive(Debug, Clone, Deserialize, Serialize, Default)]
pub struct Config {
    /// List of MCP servers to configure.
    pub servers: Vec<ServerConfig>,

    /// Maximum number of concurrent server operations.
    #[serde(default = "default_concurrency_limit")]
    pub concurrency_limit: usize,

    /// Maximum number of retry attempts for failed operations.
    #[serde(default = "default_retry_max")]
    pub retry_max: u32,

    /// Initial delay between retries in milliseconds.
    #[serde(default = "default_retry_delay_ms")]
    pub retry_delay_ms: u64,

    /// Timeout for server operations in seconds.
    #[serde(default = "default_timeout_secs")]
    pub timeout_secs: u64,

    /// Daemon idle timeout in seconds (TTL).
    /// After this period of inactivity, the daemon will shut down.
    #[serde(default = "default_daemon_ttl")]
    pub daemon_ttl: u64,
}
```

Add the default function:

```rust
fn default_daemon_ttl() -> u64 {
    60
}
```
  </action>
  <verify>
grep -A2 "daemon_ttl" src/config/mod.rs
grep "default_daemon_ttl" src/config/mod.rs
  </verify>
  <done>
Config struct has daemon_ttl field with default of 60 seconds
  </done>
</task>

<task type="auto">
  <name>Task 2: Update DaemonLifecycle to use configurable TTL</name>
  <files>src/daemon/lifecycle.rs</files>
  <action>
Check current DaemonLifecycle implementation and ensure it accepts configurable timeout.

Current lifecycle.rs likely has a hardcoded timeout. Update to accept timeout_secs parameter:

```rust
impl DaemonLifecycle {
    pub fn new(timeout_secs: u64) -> Self {
        // ... existing initialization
        Self {
            // ... other fields
            timeout_secs,
            // ...
        }
    }
}
```

Ensure the idle timer uses this configurable timeout instead of hardcoded value.
  </action>
  <verify>
grep -A5 "pub fn new" src/daemon/lifecycle.rs
grep "timeout_secs" src/daemon/lifecycle.rs
  </verify>
  <done>
DaemonLifecycle::new() accepts timeout_secs parameter and uses it for idle timeout
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire TTL from config to daemon initialization</name>
  <files>src/daemon/mod.rs, src/main.rs</files>
  <action>
Update daemon initialization to use config.daemon_ttl:

In src/daemon/mod.rs run_daemon() or where lifecycle is created:
```rust
// Use configurable TTL from config
let ttl = config.daemon_ttl;
let lifecycle = DaemonLifecycle::new(ttl);
```

In src/main.rs run_standalone_daemon():
```rust
async fn run_standalone_daemon(cli_ttl: Option<u64>) -> Result<()> {
    // ... config loading ...
    
    // Determine TTL: CLI flag > env var > config > default
    let ttl = cli_ttl
        .or_else(|| std::env::var("MCP_DAEMON_TTL").ok().and_then(|v| v.parse().ok()))
        .unwrap_or(config.daemon_ttl);
    
    tracing::info!("Using daemon TTL: {}s", ttl);
    
    // Create lifecycle with TTL
    let lifecycle = mcp_cli_rs::daemon::lifecycle::DaemonLifecycle::new(ttl);
    
    // ... rest of daemon startup ...
}
```

Update the Commands::Daemon variant to accept optional TTL:
```rust
Daemon {
    /// Daemon idle timeout in seconds (overrides config and env)
    #[arg(short, long)]
    ttl: Option<u64>,
},
```
  </action>
  <verify>
grep -B2 -A10 "run_standalone_daemon" src/main.rs | grep -E "(ttl|MCP_DAEMON_TTL|daemon_ttl)"
  </verify>
  <done>
TTL resolution order implemented: CLI flag > env var > config file > default (60s)
  </done>
</task>

<task type="auto">
  <name>Task 4: Update auto-daemon mode to use config TTL</name>
  <files>src/cli/daemon.rs</files>
  <action>
Update run_auto_daemon_mode() to use config TTL:

```rust
pub async fn run_auto_daemon_mode(
    cli: &crate::main::Cli,
    config: Arc<Config>,
) -> Result<()> {
    // ... existing code ...
    
    match try_connect_to_daemon(config.clone(), &socket_path).await {
        Ok(client) => {
            tracing::info!("Using existing daemon");
            execute_command(cli, client).await
        }
        Err(_) => {
            tracing::info!("Daemon not running, spawning...");
            
            // Use config.daemon_ttl (already includes env var fallback via config loading)
            let ttl = config.daemon_ttl;
            
            tracing::info!("Spawning daemon with TTL: {}s", ttl);
            
            // Spawn daemon with TTL...
        }
    }
}
```

Note: The config loader should handle env var overrides. Check src/config/loader.rs to ensure MCP_DAEMON_TTL is respected when loading config.
  </action>
  <verify>
grep -A5 "daemon_ttl" src/cli/daemon.rs || echo "Check config usage in daemon mode"
  </verify>
  <done>
Auto-daemon mode uses config.daemon_ttl for spawned daemon
  </done>
</task>

<task type="auto">
  <name>Task 5: Add tests for TTL configuration</name>
  <files>src/config/mod.rs, src/daemon/lifecycle.rs</files>
  <action>
Add unit tests for TTL configuration:

In src/config/mod.rs tests:
```rust
#[test]
fn test_default_daemon_ttl() {
    let config = Config::default();
    assert_eq!(config.daemon_ttl, 60);
}

#[test]
fn test_daemon_ttl_from_toml() {
    let toml = r#"
        daemon_ttl = 120
        [[servers]]
        name = "test"
        type = "stdio"
        command = "echo"
    "#;
    
    let config: Config = toml::from_str(toml).unwrap();
    assert_eq!(config.daemon_ttl, 120);
}
```

In src/daemon/lifecycle.rs tests:
```rust
#[test]
fn test_lifecycle_with_custom_ttl() {
    let lifecycle = DaemonLifecycle::new(300);
    // Verify timeout is set correctly
    assert_eq!(lifecycle.timeout_secs(), 300);
}
```

Run tests to verify:
```bash
cargo test daemon_ttl
cargo test lifecycle
```
  </action>
  <verify>
cargo test daemon_ttl 2>&1 | tail -5
cargo test lifecycle 2>&1 | tail -5
  </verify>
  <done>
TTL configuration tests pass, verifying default values and custom TTL parsing
  </done>
</task>

</tasks>

<verification>
- [ ] Config struct has daemon_ttl field with default 60s
- [ ] DaemonLifecycle accepts configurable timeout
- [ ] `mcp daemon --ttl 120` uses 120 second TTL
- [ ] `MCP_DAEMON_TTL=90 mcp daemon` uses 90 second TTL
- [ ] Config file with `daemon_ttl = 180` is respected
- [ ] TTL priority: CLI flag > env var > config > default
- [ ] All tests pass: `cargo test`
</verification>

<success_criteria>
TTL configuration fully implemented:
- --ttl flag works for standalone daemon
- MCP_DAEMON_TTL env var supported
- daemon_ttl config field supported
- Default of 60 seconds maintained
- Priority order correctly implemented
</success_criteria>

<output>
After completion, create `.planning/phases/05-unified-daemon-architecture/05-03-SUMMARY.md`
</output>
