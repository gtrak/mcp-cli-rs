---
phase: 06-output-formatting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/format/mod.rs
  - src/format/schema.rs
  - src/format/params.rs
  - src/lib.rs
autonomous: true
must_haves:
  truths:
    - "Parameter types are extracted from JSON Schema"
    - "Required vs optional parameters are clearly distinguished"
    - "Standard CLI conventions are used (<required> [optional])"
    - "Formatting utilities are reusable across all commands"
  artifacts:
    - path: "src/format/mod.rs"
      provides: "Formatting module exports"
      min_lines: 30
    - path: "src/format/schema.rs"
      provides: "JSON Schema parsing for parameters"
      exports: ["extract_params_from_schema", "ParameterInfo"]
    - path: "src/format/params.rs"
      provides: "Parameter formatting utilities"
      exports: ["format_param_list", "format_param_help"]
  key_links:
    - from: "src/format/schema.rs"
      to: "src/format/params.rs"
      via: "ParameterInfo struct"
      pattern: "pub struct ParameterInfo"
---

<objective>
Create formatting infrastructure for help-style parameter display and progressive detail levels.

Purpose: Establish reusable utilities for extracting and formatting parameter information from JSON Schema, enabling consistent help-style output across all CLI commands.
Output: `src/format/` module with schema parsing and parameter formatting capabilities.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@src/output.rs
@src/client/mod.rs

**Phase 6 Goal:** Users can navigate CLI output easily with clear visual hierarchy, prominent tool descriptions, and consistent formatting across all commands.

**Requirements to implement:**
- OUTP-01: Parameter overview (names, types, required/optional) in help-style format
- OUTP-06: Standard CLI conventions (`name <type>` required, `name [type]` optional)
- OUTP-02: Progressive detail levels infrastructure (default → -d → -v)

**Existing code:**
- `src/output.rs` has colored printing utilities (print_error, print_warning, etc.)
- `ToolInfo` struct in `src/client/mod.rs` has `input_schema: Value` field
- Commands are in `src/cli/commands.rs` and need formatting integration
</context>

<tasks>

<task type="auto">
  <name>Create format module structure</name>
  <files>src/format/mod.rs, src/lib.rs</files>
  <action>
Create `src/format/mod.rs` as the formatting module entry point:

1. Add module declaration and exports:
   - `pub mod schema;` - JSON Schema parsing
   - `pub mod params;` - Parameter formatting
   
2. Re-export commonly used items:
   - `pub use schema::{extract_params_from_schema, ParameterInfo};`
   - `pub use params::{format_param_list, format_param_help};`

3. Add module-level documentation explaining:
   - Purpose: Help-style output formatting for MCP tool parameters
   - Integration with existing output.rs for colors
   - Usage examples

4. Update `src/lib.rs` to add:
   - `pub mod format;` alongside existing modules
   - Ensure module is publicly accessible for CLI commands

Do NOT implement the logic yet - just create the module structure and exports.
  </action>
  <verify>
cargo check 2>&1 | head -20
  </verify>
  <done>
Module structure compiles, src/format/mod.rs exists with proper exports, src/lib.rs updated with pub mod format.
  </done>
</task>

<task type="auto">
  <name>Implement JSON Schema parameter extraction</name>
  <files>src/format/schema.rs</files>
  <action>
Create `src/format/schema.rs` to parse JSON Schema and extract parameter information:

1. Define `ParameterInfo` struct:
   ```rust
   pub struct ParameterInfo {
       pub name: String,
       pub param_type: String,  // "string", "number", "boolean", "object", "array"
       pub description: Option<String>,
       pub required: bool,
   }
   ```

2. Implement `extract_params_from_schema(schema: &Value) -> Vec<ParameterInfo>`:
   - Parse JSON Schema "properties" object
   - Extract parameter name from property key
   - Extract type from "type" field (default to "any" if missing)
   - Extract description from "description" field
   - Check if parameter is in "required" array
   - Return Vec<ParameterInfo> sorted by required first, then name

3. Handle edge cases:
   - Empty schema returns empty vec
   - Missing properties field returns empty vec
   - Invalid type values default to "any"
   - Nested objects: show as "object" type (don't recurse for now)

4. Add comprehensive unit tests:
   - Test with complete schema (all fields)
   - Test with minimal schema (just properties)
   - Test with mixed required/optional
   - Test with empty schema
   - Test with various types (string, number, boolean, array, object)

Use serde_json::Value for schema parsing. Do NOT use external JSON Schema libraries - parse manually for simplicity and control.
  </action>
  <verify>
cargo test format::schema 2>&1 | tail -30
  </verify>
  <done>
All tests pass, extract_params_from_schema correctly parses JSON Schema and returns ParameterInfo with required/optional status, types, and descriptions.
  </done>
</task>

<task type="auto">
  <name>Implement parameter formatting utilities</name>
  <files>src/format/params.rs</files>
  <action>
Create `src/format/params.rs` for help-style parameter formatting:

1. Implement `format_param_list(params: &[ParameterInfo], style: DetailLevel) -> String`:
   - Takes slice of ParameterInfo and DetailLevel enum
   - DetailLevel: Summary, WithDescriptions, Verbose
   - Returns formatted string suitable for CLI output

2. For Summary level (default):
   - Show only parameter names with type indicators
   - Required: `name <type>`
   - Optional: `name [type]`
   - Example: `query <string> limit [number] enabled [boolean]`
   - Truncate if too long (>80 chars): show first 3 + "..."

3. For WithDescriptions level (-d flag):
   - Multi-line format with descriptions
   - Format: `  name <type>  Description text here`
   - Wrap descriptions at 60 chars, indent continuation
   - Required params first, then optional

4. For Verbose level (-v flag):
   - Full schema details
   - Include all of WithDescriptions
   - Add: default values, enum values, examples if present
   - Show nested object properties (one level deep)

5. Implement helper functions:
   - `format_single_param(param: &ParameterInfo, style: DetailLevel) -> String`
   - `type_to_display(type_str: &str) -> &str` - map JSON types to display names
   - `wrap_description(text: &str, width: usize, indent: usize) -> String`

6. Add unit tests:
   - Test all three detail levels
   - Test truncation
   - Test description wrapping
   - Test with mixed required/optional

Do NOT integrate with commands yet - this is pure formatting logic.
  </action>
  <verify>
cargo test format::params 2>&1 | tail -30
  </verify>
  <done>
All tests pass, format_param_list produces correct output for all detail levels with proper CLI conventions (<required> [optional]).
  </done>
</task>

</tasks>

<verification>
1. Module compiles: `cargo check` passes
2. All tests pass: `cargo test format::` passes
3. Public API exports: `ParameterInfo`, `extract_params_from_schema`, `format_param_list` are accessible
4. Integration ready: Module can be imported in commands.rs
</verification>

<success_criteria>
- src/format/mod.rs exists with proper exports
- src/format/schema.rs implements JSON Schema parsing with tests
- src/format/params.rs implements parameter formatting with tests
- All formatting utilities compile and pass tests
- Module integrated into src/lib.rs
</success_criteria>

<output>
After completion, create `.planning/phases/06-output-formatting/06-01-SUMMARY.md`
</output>
