---
phase: 19-error-paths-and-regression-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/invalid_json_args_test.rs
  - tests/server_timeout_test.rs
  - tests/server_disconnection_test.rs
  - tests/fixtures/mock_slow_server.rs (optional)
  - tests/fixtures/mock_disconnect_server.rs (optional)
autonomous: true
must_haves:
  truths:
    - "Invalid JSON arguments produce helpful error message"
    - "Server timeout triggers client-side timeout with clear error"
    - "Server disconnection during tool call returns graceful error"
  artifacts:
    - path: "tests/invalid_json_args_test.rs"
      provides: "TEST-12 - Invalid JSON error handling"
      min_lines: 80
      exports: ["test_invalid_json_arguments"]
    - path: "tests/server_timeout_test.rs"
      provides: "TEST-13 - Server timeout handling"
      min_lines: 80
      exports: ["test_server_timeout"]
    - path: "tests/server_disconnection_test.rs"
      provides: "TEST-14 - Server disconnection handling"
      min_lines: 80
      exports: ["test_server_disconnection"]
  key_links:
    - from: "tests/*_test.rs"
      to: "tests/fixtures/mock_mcp_server.rs"
      via: "mock server spawning"
      pattern: "spawn_mock_server.*with.*config"
---

<objective>
Add error path integration tests covering invalid JSON arguments, server timeouts, and server disconnection scenarios.

Purpose: Verify graceful error handling in failure scenarios that users may encounter.
Output: Three test files with 3 passing tests (TEST-12, TEST-13, TEST-14).
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@tests/fixtures/mock_mcp_server.rs
@tests/tool_call_error_tests.rs

## Reference Patterns

### Mock Server Spawning (from tool_call_error_tests.rs):
```rust
async fn spawn_mock_server_with_errors(
    tools: Vec<ToolDefinition>,
    responses: HashMap<String, MockResponse>,
    errors: HashMap<String, String>,
) -> anyhow::Result<(Child, ChildStdin, BufReader<ChildStdout>)>
```

### Test Transport Implementation:
```rust
struct TestStdioTransport {
    stdin: ChildStdin,
    stdout: BufReader<ChildStdout>,
}

#[async_trait::async_trait]
impl Transport for TestStdioTransport {
    async fn send(&mut self, request: Value) -> mcp_cli_rs::error::Result<Value> { ... }
}
```

### Timeout Pattern (from daemon_ipc_tests.rs):
```rust
use tokio::time::{timeout, Duration};
match timeout(Duration::from_secs(10), client.send_request(&request)).await {
    Ok(Ok(response)) => { /* success */ }
    Ok(Err(e)) => { /* IPC error */ }
    Err(_) => { /* timeout */ }
}
```

### Mock Server Configuration:
- MOCK_TOOLS: JSON array of ToolDefinition
- MOCK_RESPONSES: JSON object mapping tool_name -> response
- MOCK_ERRORS: JSON object mapping tool_name -> error message
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add invalid JSON arguments test (TEST-12)</name>
  <files>tests/invalid_json_args_test.rs</files>
  <action>
Create tests/invalid_json_args_test.rs with TEST-12:

1. Create test that passes malformed JSON as tool arguments:
   - Spawn mock MCP server with echo tool
   - Attempt to call tool with invalid JSON: "{not valid json}" or incomplete object
   - Verify error is returned (not panic)
   - Verify error message is helpful and mentions JSON/parse issue

2. Use the established patterns from tool_call_error_tests.rs:
   - ToolDefinition, MockResponse types
   - spawn_mock_server helper
   - TestStdioTransport implementation
   - McpClient::new + initialize + call_tool flow

3. Test cases:
   - Malformed JSON string as arguments
   - Type mismatch (number instead of string for string field)
   - Missing required field (already partially covered, extend)

4. Error verification:
   - assert!(result.is_err())
   - Check error message contains "json", "parse", "invalid", or "schema"

5. Include proper cleanup: let _ = child.kill().await;
  </action>
  <verify>cargo test test_invalid_json_arguments --test invalid_json_args_test -- --nocapture</verify>
  <done>Test passes, verifies helpful error message for invalid JSON args</done>
</task>

<task type="auto">
  <name>Task 2: Add server timeout test (TEST-13)</name>
  <files>tests/server_timeout_test.rs</files>
  <action>
Create tests/server_timeout_test.rs with TEST-13:

1. Create test that simulates slow server response:
   - Option A: Extend mock_mcp_server with MOCK_DELAY env var support
   - Option B: Use tokio::time::timeout wrapper around client call
   - Use timeout pattern from daemon_ipc_tests.rs

2. Test implementation:
   - Spawn mock server (use existing mock_mcp_server)
   - Create McpClient with stdio transport
   - Use tokio::time::timeout(Duration::from_millis(100), client.call_tool(...))
   - Server configured to delay response (if using Option A) or use slow tool
   - Verify timeout occurs with clear error

3. If extending mock server (Option A):
   - Add MOCK_DELAY_MS env var support to mock_mcp_server.rs
   - Insert tokio::time::sleep in handle_tools_call before response

4. Error verification:
   - assert!(result.is_err() or timeout triggered)
   - Error should indicate timeout or deadline exceeded

5. Test both:
   - Timeout on tool call
   - Timeout on tools/list (optional)

6. Include proper cleanup
  </action>
  <verify>cargo test test_server_timeout --test server_timeout_test -- --nocapture</verify>
  <done>Test passes, verifies timeout handling with clear error message</done>
</task>

<task type="auto">
  <name>Task 3: Add server disconnection test (TEST-14)</name>
  <files>tests/server_disconnection_test.rs</files>
  <action>
Create tests/server_disconnection_test.rs with TEST-14:

1. Create test that kills server mid-operation:
   - Spawn mock MCP server
   - Initialize connection
   - Start a long-running or slow tool call (or just kill immediately after request sent)
   - Kill the server process while request is in-flight
   - Verify graceful error handling

2. Pattern from tool_call_error_tests.rs test_transport_error_handling:
   - Already tests server death scenario
   - Extend to specifically test DURING tool call (not just after init)

3. Implementation:
   - Spawn mock server with slow tool (if MOCK_DELAY support added)
   - Start tool call in background/task
   - Kill server immediately after sending request
   - Await result and verify error

4. Alternative approach (if no delay support):
   - Send request then immediately kill server
   - Transport should detect closed pipe/socket
   - Error should indicate connection lost

5. Error verification:
   - assert!(result.is_err())
   - Error message should mention connection, closed, or pipe

6. Ensure no panic - graceful error only

7. Include proper cleanup (may need to handle already-killed process)
  </action>
  <verify>cargo test test_server_disconnection --test server_disconnection_test -- --nocapture</verify>
  <done>Test passes, verifies graceful error when server disconnects mid-call</done>
</task>

</tasks>

<verification>
1. All 3 tests pass: cargo test --test invalid_json_args_test --test server_timeout_test --test server_disconnection_test
2. Tests are independent (can run with --test-threads=8)
3. Each test cleans up mock server processes
4. Error messages are helpful and actionable
</verification>

<success_criteria>
- TEST-12: Invalid JSON args produces helpful error mentioning JSON/parse/schema
- TEST-13: Server timeout test passes with clear timeout indication
- TEST-14: Server disconnection test passes with graceful connection error
- All tests run successfully: cargo test test_invalid_json_arguments test_server_timeout test_server_disconnection
- No test process leaks (all mock servers cleaned up)
</success_criteria>

<output>
After completion, create `.planning/phases/19-error-paths-and-regression-tests/19-01-SUMMARY.md`
</output>
