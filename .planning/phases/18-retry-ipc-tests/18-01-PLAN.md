---
phase: 18-retry-ipc-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/retry_logic_tests.rs
  - tests/fixtures/mock_failing_server.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Exponential backoff retry test passes with measurable delays"
    - "Max retry limit test passes - stops after configured attempts"
    - "Different retry delays test passes - backoff increases exponentially"
  artifacts:
    - path: "tests/retry_logic_tests.rs"
      provides: "Retry logic integration tests (3 tests)"
      min_lines: 200
    - path: "tests/fixtures/mock_failing_server.rs"
      provides: "Mock server that fails N times then succeeds"
      min_lines: 150
  key_links:
    - from: "tests/retry_logic_tests.rs"
      to: "src/retry.rs"
      via: "retry_with_backoff function import"
      pattern: "retry_with_backoff.*RetryConfig"
    - from: "tests/fixtures/mock_failing_server.rs"
      to: "tests/retry_logic_tests.rs"
      via: "spawn_mock_failing_server helper"
      pattern: "mock_failing_server::spawn"
---

<objective>
Create integration tests for retry logic with exponential backoff (TEST-06, TEST-07, TEST-08)

Purpose: Verify retry logic works correctly - exponential backoff timing, max retry limits, and proper delay calculation
Output: tests/retry_logic_tests.rs with 3 passing tests + mock failing server fixture
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

## Phase 17 Context
Phase 17 created mock servers and tool call tests. Reuse that infrastructure.

## Retry Logic Implementation
src/retry.rs contains:
- `RetryConfig` struct with max_attempts, base_delay_ms, max_delay_ms
- `retry_with_backoff()` - async retry with exponential backoff
- `is_transient_error()` - determines if error should be retried

## Key Functions to Test
```rust
pub async fn retry_with_backoff<F, T>(
    operation: F,
    config: &RetryConfig,
) -> Result<T, McpError>

pub struct RetryConfig {
    pub max_attempts: u32,    // e.g., 3
    pub base_delay_ms: u64,   // e.g., 100
    pub max_delay_ms: u64,    // e.g., 5000
}
```

## Mock Server Pattern (from Phase 17)
Tests/fixtures/mock_http_server.rs shows parameterized config pattern:
```rust
pub struct MockServerConfig {
    pub tools: Vec<ToolDefinition>,
    pub responses: HashMap<String, MockResponse>,
    pub fail_first_n: Option<usize>,  // NEW: fail first N requests
}
```
</context>

<tasks>

<task type="auto">
  <name>Create mock failing server fixture</name>
  <files>tests/fixtures/mock_failing_server.rs</files>
  <action>
    Create a mock HTTP server that fails the first N requests, then succeeds.
    
    Use the same pattern as tests/fixtures/mock_http_server.rs but add:
    - fail_first_n: AtomicUsize counter for tracking failures
    - When counter < fail_first_n: return 503 Service Unavailable (transient error)
    - When counter >= fail_first_n: return normal success response
    
    Export:
    - spawn_failing_server(fail_first_n: usize) -> (MockFailingServer, String)
    - MockFailingServer::shutdown() method
    
    The server should return McpError::ConnectionError equivalent (HTTP 503) 
    for failures to trigger retry logic (is_transient_error returns true).
    
    Keep under 150 lines by reusing patterns from mock_http_server.rs.
  </action>
  <verify>cargo check --tests passes with no errors</verify>
  <done>File exists with spawn_failing_server function exported</done>
</task>

<task type="auto">
  <name>Create retry logic integration tests</name>
  <files>tests/retry_logic_tests.rs</files>
  <action>
    Create 3 integration tests for retry logic:

    **Test 1: test_exponential_backoff (TEST-06)**
    - Create RetryConfig { max_attempts: 3, base_delay_ms: 50, max_delay_ms: 500 }
    - Use mock server with fail_first_n: 2
    - Record timestamps of each retry attempt
    - Verify delays follow exponential pattern: ~50ms, ~100ms between attempts
    - Assert final attempt succeeds

    **Test 2: test_max_retry_limit (TEST-07)**
    - Create RetryConfig { max_attempts: 2, base_delay_ms: 10, max_delay_ms: 100 }
    - Use mock server with fail_first_n: 5 (always fails more than max)
    - Execute operation with retry
    - Assert result is Err(McpError::MaxRetriesExceeded { attempts: 2 })
    - Verify exactly 2 attempts were made

    **Test 3: test_retry_delay_increases (TEST-08)**
    - Create RetryConfig with base_delay_ms: 100
    - Execute operation that fails then succeeds
    - Measure actual delays between attempts
    - Verify second delay > first delay (exponential growth)
    - Verify delays don't exceed max_delay_ms cap

    Use tokio::time::Instant for timing measurements.
    Use std::sync::atomic for request counting.
    All tests must pass with cargo test --test retry_logic_tests.
  </action>
  <verify>cargo test --test retry_logic_tests passes (3/3 tests)</verify>
  <done>All 3 tests pass with clear timing verification</done>
</task>

</tasks>

<verification>
- [ ] tests/fixtures/mock_failing_server.rs compiles without errors
- [ ] tests/retry_logic_tests.rs compiles without errors  
- [ ] All 3 tests pass: test_exponential_backoff, test_max_retry_limit, test_retry_delay_increases
- [ ] Tests use RetryConfig from src/retry.rs
- [ ] Tests verify actual timing (not just success/failure)
- [ ] Mock server correctly returns transient errors (503/ConnectionError)
</verification>

<success_criteria>
Observable truths that prove completion:
1. `cargo test --test retry_logic_tests` shows 3 passing tests
2. Test output shows exponential backoff timing (50ms → 100ms → 200ms pattern)
3. Max retry limit test shows exactly configured attempts before giving up
4. No compiler warnings in test files
</success_criteria>

<output>
After completion, create `.planning/phases/18-retry-ipc-tests/18-01-SUMMARY.md`
</output>
