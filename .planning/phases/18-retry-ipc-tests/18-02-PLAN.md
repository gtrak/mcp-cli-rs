---
phase: 18-retry-ipc-tests
plan: 02
type: execute
wave: 2
depends_on: [18-01]
files_modified:
  - tests/daemon_ipc_tests.rs
  - tests/fixtures/daemon_test_helper.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Daemon protocol roundtrip test passes (Ping/Pong, ExecuteTool/ToolResult)"
    - "Concurrent tool calls through daemon test passes (multiple parallel requests)"
    - "Connection cleanup test passes (resources released after disconnect)"
  artifacts:
    - path: "tests/daemon_ipc_tests.rs"
      provides: "Daemon IPC integration tests (3 tests)"
      min_lines: 250
    - path: "tests/fixtures/daemon_test_helper.rs"
      provides: "Test helpers for daemon lifecycle"
      min_lines: 180
  key_links:
    - from: "tests/daemon_ipc_tests.rs"
      to: "src/daemon/protocol.rs"
      via: "DaemonRequest/DaemonResponse types"
      pattern: "daemon::protocol::DaemonRequest"
    - from: "tests/daemon_ipc_tests.rs"
      to: "src/ipc.rs"
      via: "IpcClient trait"
      pattern: "ipc::create_ipc_client"
    - from: "tests/fixtures/daemon_test_helper.rs"
      to: "tests/daemon_ipc_tests.rs"
      via: "spawn_test_daemon helper"
      pattern: "daemon_test_helper::spawn"
---

<objective>
Create integration tests for daemon IPC communication (TEST-09, TEST-10, TEST-11)

Purpose: Verify daemon protocol roundtrip, concurrent request handling, and proper resource cleanup
Output: tests/daemon_ipc_tests.rs with 3 passing tests + daemon test helper fixture
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

## Phase 17 Context
Phase 17 created mock servers and tool call tests. Reuse patterns.

## IPC Implementation
src/ipc/mod.rs contains:
- `IpcClient` trait for cross-platform IPC
- `create_ipc_client(config)` - creates platform-appropriate client
- `create_ipc_server(path)` - creates platform-appropriate server

## Daemon Protocol
src/daemon/protocol.rs contains:
```rust
pub enum DaemonRequest {
    Ping,
    ExecuteTool { server_name, tool_name, arguments },
    ListTools { server_name },
    ListServers,
    Shutdown,
}

pub enum DaemonResponse {
    Pong,
    ToolResult(serde_json::Value),
    ToolList(Vec<ToolInfo>),
    ServerList(Vec<String>),
    ShutdownAck,
    Error { code, message },
}
```

## Existing IPC Tests (Reference)
tests/ipc_tests.rs and tests/cross_platform_daemon_tests.rs show:
- IPC roundtrip patterns
- Platform-specific test organization (tests/unix/, tests/windows/)
- Use TestEnvironment from tests/helpers.rs

## Daemon Implementation
src/daemon/mod.rs contains:
- `DaemonState` with connection_pool
- `handle_request()` - dispatches DaemonRequest to handlers
- `handle_tool_execution()` - executes tools via pool
</context>

<tasks>

<task type="auto">
  <name>Create daemon test helper fixture</name>
  <files>tests/fixtures/daemon_test_helper.rs</files>
  <action>
    Create test helpers for daemon lifecycle in tests:

    **spawn_test_daemon(config: Config) -> TestDaemon**
    - Creates IPC socket/pipe in temp directory
    - Spawns daemon in background (tokio::spawn)
    - Returns TestDaemon handle with socket_path and shutdown channel
    - Uses actual daemon code from src/daemon/mod.rs
    - Daemon configured with mock MCP server (from Phase 17 fixtures)

    **TestDaemon struct**
    ```rust
    pub struct TestDaemon {
        pub socket_path: PathBuf,
        pub config: Config,
        shutdown_tx: oneshot::Sender<()>,
    }
    
    impl TestDaemon {
        pub async fn shutdown(self) -> Result<()> {
            // Send shutdown request, wait for acknowledgment
        }
        
        pub fn client(&self) -> Result<Box<dyn IpcClient>> {
            // Create IPC client connected to this daemon
        }
    }
    ```

    **create_test_config() -> Config**
    - Creates minimal config with one mock stdio server
    - Uses MockMcpServer from tests/fixtures/mock_mcp_server.rs
    - Configures short timeouts for test speed

    Keep under 180 lines. Reuse TestEnvironment from tests/helpers.rs.
  </action>
  <verify>cargo check --tests passes with no errors</verify>
  <done>File exists with spawn_test_daemon and TestDaemon struct</done>
</task>

<task type="auto">
  <name>Create daemon IPC integration tests</name>
  <files>tests/daemon_ipc_tests.rs</files>
  <action>
    Create 3 integration tests for daemon IPC:

    **Test 1: test_daemon_protocol_roundtrip (TEST-09)**
    - Spawn test daemon with mock server
    - Create IPC client using daemon_test_helper::TestDaemon::client()
    - Send Ping request, verify Pong response
    - Send ListServers request, verify ServerList response
    - Send ExecuteTool request with mock tool, verify ToolResult response
    - Send Shutdown request, verify ShutdownAck response
    - Clean shutdown

    **Test 2: test_concurrent_tool_calls (TEST-10)**
    - Spawn test daemon with mock server configured with 2 tools
    - Create 3 concurrent IPC clients (or reuse one client with concurrent requests)
    - Spawn 5 concurrent ExecuteTool requests
    - Collect all responses
    - Verify all 5 requests succeed
    - Verify responses contain correct tool results
    - Verify no request timeouts or errors
    - Clean shutdown

    **Test 3: test_connection_cleanup (TEST-11)**
    - Spawn test daemon
    - Create IPC client, send Ping (verify works)
    - Drop client (simulate disconnect)
    - Create new IPC client, send Ping (verify still works)
    - Verify daemon still running and responsive
    - Verify no resource leaks (check with cfg(test) assertions if possible)
    - Verify socket/pipe still accessible
    - Clean shutdown

    All tests must pass with cargo test --test daemon_ipc_tests.
    
    Platform considerations:
    - Use #[cfg(unix)] and #[cfg(windows)] for platform-specific socket/pipe paths
    - Tests should work on both Unix (socket) and Windows (named pipe)
    - Reuse patterns from tests/ipc_tests.rs
  </action>
  <verify>cargo test --test daemon_ipc_tests passes (3/3 tests)</verify>
  <done>All 3 tests pass with full protocol verification</done>
</task>

</tasks>

<verification>
- [ ] tests/fixtures/daemon_test_helper.rs compiles without errors
- [ ] tests/daemon_ipc_tests.rs compiles without errors
- [ ] All 3 tests pass: test_daemon_protocol_roundtrip, test_concurrent_tool_calls, test_connection_cleanup
- [ ] Tests use DaemonRequest/DaemonResponse from src/daemon/protocol.rs
- [ ] Tests verify concurrent requests complete successfully
- [ ] Tests verify cleanup (resources released, daemon responsive after disconnect)
- [ ] Tests work on both Unix and Windows platforms
</verification>

<success_criteria>
Observable truths that prove completion:
1. `cargo test --test daemon_ipc_tests` shows 3 passing tests
2. Roundtrip test verifies all 4 request/response pairs (Ping/Pong, ExecuteTool/ToolResult, ListServers/ServerList, Shutdown/ShutdownAck)
3. Concurrent test spawns 5+ parallel requests and all complete successfully
4. Cleanup test shows daemon remains responsive after client disconnects
5. No compiler warnings in test files
</success_criteria>

<output>
After completion, create `.planning/phases/18-retry-ipc-tests/18-02-SUMMARY.md`
</output>
