---
phase: 14-duplication-elimination
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/cli/models.rs
  - src/cli/formatters.rs
  - src/cli/mod.rs
autonomous: true

must_haves:
  truths:
    - "Model types exist for all 5 command outputs: ListServers, ServerInfo, ToolInfo, CallResult, SearchResult"
    - "Each model derives Serialize and Deserialize for JSON output"
    - "Formatter functions exist for human and JSON output for all 5 command types"
    - "Models capture all fields currently used by both human and JSON formatters"
  artifacts:
    - path: "src/cli/models.rs"
      provides: "ListServersModel, ServerModel, ToolModel, ServerInfoModel, ToolInfoModel, CallResultModel, SearchResultModel structs"
      contains: "derive.*Serialize.*Deserialize"
    - path: "src/cli/formatters.rs"
      provides: "format_list_servers, format_server_info, format_tool_info, format_call_result, format_search_results functions"
      contains: "OutputMode"
    - path: "src/cli/mod.rs"
      provides: "pub mod models; pub mod formatters;"
  key_links:
    - from: "src/cli/formatters.rs"
      to: "src/cli/models.rs"
      via: "use super::models::*"
      pattern: "models::"
    - from: "src/cli/formatters.rs"
      to: "src/format/mod.rs"
      via: "use crate::format::OutputMode"
      pattern: "OutputMode"
---

<objective>
Create model types and formatter functions for the Model + Formatter architecture.

Purpose: Per locked decision, commands should return models (not formatted strings), with separate formatters converting models to human or JSON output. This plan creates the foundation types and formatters that commands will migrate to in Plan 03/04. DUP-01, DUP-02 groundwork.

Output: src/cli/models.rs with all model structs, src/cli/formatters.rs with all format functions.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/14-duplication-elimination/14-CONTEXT.md
@.planning/phases/14-duplication-elimination/14-RESEARCH.md
@src/cli/list.rs
@src/cli/info.rs
@src/cli/call.rs
@src/cli/search.rs
@src/format/mod.rs
@src/daemon/protocol.rs
@src/output.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/cli/models.rs with all command model types</name>
  <files>src/cli/models.rs, src/cli/mod.rs</files>
  <action>
Create src/cli/models.rs with model structs that capture ALL fields used by both human and JSON formatters in the existing command files. Derive Serialize, Deserialize, Debug, Clone on all models.

Models needed (examine existing code to capture all fields):

1. **ListServersModel** - from list.rs lines 112-336 (human) and 406-458 (JSON):
   - servers: Vec<ServerModel>
   - total_servers: usize
   - connected_servers: usize
   - failed_servers: usize
   - total_tools: usize
   
2. **ServerModel** - individual server in list:
   - name: String
   - status: String (connected/failed)
   - transport_type: Option<String>
   - description: Option<String>
   - tool_count: usize
   - tools: Vec<ToolModel>
   - error: Option<String>
   - has_filtered_tools: bool

3. **ToolModel** - tool within a server listing:
   - name: String
   - description: Option<String>
   - input_schema: serde_json::Value

4. **ServerInfoModel** - from info.rs cmd_server_info:
   - name: String
   - description: Option<String>
   - transport_type: String
   - transport_detail: String (command/url details)
   - environment: Option<Vec<(String, String)>>
   - disabled_tools: Vec<String>
   - allowed_tools: Vec<String>

5. **ToolInfoModel** - from info.rs cmd_tool_info:
   - server_name: String
   - tool_name: String
   - description: Option<String>
   - parameters: Vec<ParameterModel>
   - input_schema: serde_json::Value

6. **ParameterModel** - parameter within tool info:
   - name: String
   - param_type: String
   - required: bool
   - description: Option<String>

7. **CallResultModel** - from call.rs:
   - server_name: String
   - tool_name: String
   - success: bool
   - result: Option<serde_json::Value>
   - error: Option<String>
   - execution_time_ms: Option<u64>
   - retries: u32

8. **SearchResultModel** - from search.rs:
   - pattern: String
   - matches: Vec<SearchMatchModel>
   - total_matches: usize
   - servers_searched: usize

9. **SearchMatchModel** - individual search match:
   - server_name: String
   - tool_name: String
   - description: Option<String>
   - input_schema: serde_json::Value

Add `pub mod models;` to src/cli/mod.rs.

IMPORTANT: Cross-reference every field against the actual existing human and JSON formatter code to ensure nothing is missed. The models must be a superset of what both formatters need.
  </action>
  <verify>
`cargo check` passes.
All model structs compile with Serialize + Deserialize derives.
  </verify>
  <done>
src/cli/models.rs exists with all 9 model types. All derive Serialize, Deserialize. Compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create src/cli/formatters.rs with format functions</name>
  <files>src/cli/formatters.rs, src/cli/mod.rs</files>
  <action>
Create src/cli/formatters.rs with formatting functions that take model references and OutputMode.

Each function follows this pattern:
```rust
pub fn format_xxx(model: &XxxModel, output_mode: OutputMode) {
    match output_mode {
        OutputMode::Human => format_xxx_human(model),
        OutputMode::Json => print_json(model),
    }
}
```

Functions needed:

1. **format_list_servers(model: &ListServersModel, detail_level: DetailLevel, output_mode: OutputMode)**
   - Human: Port the display logic from list.rs lines 111-336 (header, server sections, tool listings by detail level, partial failure reporting, filter warnings)
   - JSON: Simply `print_json(model)` - the model serializes directly to the expected JSON schema

2. **format_server_info(model: &ServerInfoModel, output_mode: OutputMode)**
   - Human: Port from info.rs cmd_server_info lines 36-85
   - JSON: `print_json(model)`

3. **format_tool_info(model: &ToolInfoModel, detail_level: DetailLevel, output_mode: OutputMode)**
   - Human: Port from info.rs cmd_tool_info lines 183-360
   - JSON: `print_json(model)`

4. **format_call_result(model: &CallResultModel, output_mode: OutputMode)**
   - Human: Port from call.rs display logic
   - JSON: `print_json(model)`

5. **format_search_results(model: &SearchResultModel, detail_level: DetailLevel, output_mode: OutputMode)**
   - Human: Port from search.rs display logic
   - JSON: `print_json(model)`

Use `colored::Colorize` for human formatting. Import `crate::output::print_json` for JSON. Import `crate::format::{DetailLevel, extract_params_from_schema, format_param_list}` as needed.

Add `pub mod formatters;` to src/cli/mod.rs.

IMPORTANT: The human formatter output must be IDENTICAL to the current output. Copy the formatting logic verbatim from the existing command files - do not "improve" or change formatting. The only change is the data source (model fields instead of inline variables).

For the JSON formatter, the model's Serialize derive should produce output matching the existing JSON structures (ListOutput, ServerDetailOutput, ToolDetailOutput, etc. from daemon/protocol.rs). Use #[serde(rename = "...")] attributes on model fields if needed to match existing JSON field names.
  </action>
  <verify>
`cargo check` passes.
`cargo clippy --lib` produces zero warnings.
  </verify>
  <done>
src/cli/formatters.rs exists with 5 format functions. Each handles Human and Json modes. Compiles cleanly. Formatting logic matches existing output patterns.
  </done>
</task>

</tasks>

<verification>
- `cargo check` passes
- `cargo clippy --lib` passes with zero warnings
- src/cli/models.rs contains all 9 model types with Serialize + Deserialize
- src/cli/formatters.rs contains 5 format functions accepting OutputMode
- src/cli/mod.rs has `pub mod models;` and `pub mod formatters;`
</verification>

<success_criteria>
Model + Formatter architecture foundation is in place. Models capture all daemon response fields. Formatters can produce both human and JSON output from models. Code compiles cleanly (models and formatters are not yet wired to commands - that's Plan 03/04).
</success_criteria>

<output>
After completion, create `.planning/phases/14-duplication-elimination/14-02-SUMMARY.md`
</output>
