---
phase: 25-cross-platform-test-validation
plan: 07
type: execute
wave: 2
depends_on:
  - 25-05
  - 25-06
files_modified:
  - tests/fixtures/daemon_test_helper.rs
  - tests/daemon_ipc_tests.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "daemon_ipc_tests use unique socket paths per test"
    - "Daemon startup waits until socket is actually ready"
    - "3 daemon_ipc_tests pass (was 1/4)"
    - "No 'No such file or directory' socket errors"
  artifacts:
    - path: "tests/fixtures/daemon_test_helper.rs"
      provides: "Unique daemon socket paths"
      pattern: "atomic|counter|unique"
    - path: "tests/fixtures/daemon_test_helper.rs"
      provides: "Socket ready detection"
      pattern: "wait_for.*ready|socket.*exists"
    - path: "tests/daemon_ipc_tests.rs"
      provides: "Passing daemon tests"
      exports: ["test_daemon_protocol_roundtrip", "test_concurrent_tool_calls", "test_connection_cleanup"]

user_setup: []
---

<objective>
Fix daemon_ipc_tests socket handling and test isolation.

**Purpose:** daemon_ipc_tests fail with "No such file or directory" because:
1. Daemon socket path uses only process_id (same for all tests in process)
2. Fixed 300ms sleep might not be enough for daemon to start
3. Socket file isn't created atomically with daemon startup

**Gap being closed:**
- REVerification.md: "daemon_ipc_tests: 1/4 pass (socket not found)"
- REVerification.md: "Socket Conflicts" in daemon tests

**Root cause:**
1. `get_daemon_socket_path()` in daemon_test_helper.rs uses only `std::process::id()`
2. Fixed sleep time doesn't guarantee daemon is ready
3. Tests try to connect before socket file exists
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/25-cross-platform-test-validation/25-REVERIFICATION.md
@.planning/phases/25-cross-platform-test-validation/25-05-SUMMARY.md
@.planning/phases/25-cross-platform-test-validation/25-06-SUMMARY.md
@tests/fixtures/daemon_test_helper.rs
@tests/daemon_ipc_tests.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add atomic counter to daemon_test_helper.rs</name>
  <files>tests/fixtures/daemon_test_helper.rs</files>
  <action>
    Add unique identifier generation to tests/fixtures/daemon_test_helper.rs.

    At the top of the file (after imports), add:
    ```rust
    use std::sync::atomic::{AtomicU64, Ordering};

    /// Global counter for unique test daemon socket paths
    static DAEMON_SOCKET_COUNTER: AtomicU64 = AtomicU64::new(0);
    ```

    Then update `get_daemon_socket_path` on Unix (around line 395):

    ```rust
    #[cfg(unix)]
    fn get_daemon_socket_path(temp_dir: &TempDir) -> PathBuf {
        let counter = DAEMON_SOCKET_COUNTER.fetch_add(1, Ordering::SeqCst);
        temp_dir.path().join(format!("daemon-test-{}-{}.sock", 
            std::process::id(),
            counter
        ))
    }
    ```

    And for Windows (around line 399):
    ```rust
    #[cfg(windows)]
    fn get_daemon_socket_path(_temp_dir: &TempDir) -> PathBuf {
        let counter = DAEMON_SOCKET_COUNTER.fetch_add(1, Ordering::SeqCst);
        PathBuf::from(format!(r"\\.\pipe\mcp-cli-daemon-test-{}-{}", 
            std::process::id(),
            counter
        ))
    }
    ```

    This ensures each daemon test gets a unique socket path even when running in parallel.
  </action>
  <verify>
    - `cargo build --tests` compiles successfully
    - `grep -n "DAEMON_SOCKET_COUNTER" tests/fixtures/daemon_test_helper.rs` shows usage
    - `grep -n "fetch_add" tests/fixtures/daemon_test_helper.rs` shows atomic increment
  </verify>
  <done>
    Daemon socket paths include unique counter alongside process_id.
  </done>
</task>

<task type="auto">
  <name>Task 2: Improve daemon startup to wait for socket readiness</name>
  <files>tests/fixtures/daemon_test_helper.rs</files>
  <action>
    Improve spawn_test_daemon to ensure socket is actually ready before returning.

    Current code (around line 151-152):
    ```rust
    // Give daemon time to start accepting connections
    tokio::time::sleep(Duration::from_millis(300)).await;
    ```

    Replace with active waiting for socket file:
    ```rust
    // Wait for socket file to exist (daemon is ready)
    let socket_ready = tokio::time::timeout(
        Duration::from_secs(5),
        async {
            loop {
                if socket_path.exists() {
                    // Give a bit more time for daemon to start listening
                    tokio::time::sleep(Duration::from_millis(50)).await;
                    break;
                }
                tokio::time::sleep(Duration::from_millis(10)).await;
            }
        }
    ).await;

    if socket_ready.is_err() {
        return Err(anyhow::anyhow!("Daemon failed to create socket within 5 seconds"));
    }
    ```

    This ensures:
    1. We wait for the socket file to actually exist
    2. Timeout after 5 seconds if something goes wrong
    3. No arbitrary sleep - we wait exactly as long as needed
    4. Clear error message if daemon fails to start
  </action>
  <verify>
    - `cargo build --tests` compiles
    - `grep -n "socket_ready\|socket_path.exists" tests/fixtures/daemon_test_helper.rs` shows active waiting
    - No hardcoded sleep(300) remaining in spawn_test_daemon
  </verify>
  <done>
    spawn_test_daemon waits for socket file to exist before returning.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add socket cleanup to daemon test Drop</name>
  <files>tests/fixtures/daemon_test_helper.rs</files>
  <action>
    Ensure socket cleanup happens properly in TestDaemon Drop implementation.

    The current Drop impl (around line 86-94) already has socket cleanup:
    ```rust
    impl Drop for TestDaemon {
        fn drop(&mut self) {
            // Clean up socket file on drop (Unix only)
            #[cfg(unix)]
            {
                let _ = std::fs::remove_file(&self.socket_path);
            }
        }
    }
    ```

    This looks correct. Add a pre-emptive cleanup before daemon starts in spawn_test_daemon:

    ```rust
    pub async fn spawn_test_daemon(config: Config) -> Result<TestDaemon> {
        // Create unique socket path in temp directory
        let temp_dir = TempDir::new()?;
        let socket_path = get_daemon_socket_path(&temp_dir);

        // Pre-emptive cleanup: remove any stale socket file
        #[cfg(unix)]
        {
            let _ = std::fs::remove_file(&socket_path);
        }

        // Update config with socket path
        // ... rest of function
    }
    ```

    This ensures no stale socket file from a previous interrupted test run.
  </action>
  <verify>
    - Pre-emptive cleanup exists before config update
    - Drop implementation still has cleanup
    - `cargo build --tests` compiles
  </verify>
  <done>
    Stale socket files cleaned up before daemon starts.
  </done>
</task>

<task type="auto">
  <name>Task 4: Run daemon_ipc_tests and verify all pass</name>
  <files></files>
  <action>
    Run the daemon_ipc_tests to verify the fixes work.

    ```bash
    # Run daemon_ipc tests
    cargo test --test daemon_ipc_tests 2>&1
    ```

    Expected: All 4 tests should pass:
    - test_daemon_protocol_roundtrip
    - test_concurrent_tool_calls
    - test_connection_cleanup
    - (and any others)

    Run multiple times to verify consistency:
    ```bash
    for i in {1..3}; do
      echo "=== Run $i ==="
      cargo test --test daemon_ipc_tests 2>&1 | tail -20
    done
    ```

    Check for specific errors:
    - "No such file or directory" - socket file not found (should be fixed)
    - "Connection refused" - daemon not ready (should be fixed)
    - "Address already in use" - socket conflicts (should be fixed)

    If tests still fail:
    - Check if socket paths are actually unique
    - Verify daemon is creating socket file before tests try to connect
    - Look for timing issues
  </action>
  <verify>
    - `cargo test --test daemon_ipc_tests` shows 4 passed
    - No "No such file or directory" errors
    - No "Connection refused" errors
    - Tests pass 3 consecutive times
  </verify>
  <done>
    All daemon_ipc_tests pass consistently.
  </done>
</task>

<task type="auto">
  <name>Task 5: Run all integration tests together</name>
  <files></files>
  <action>
    Run all integration tests together to verify no cross-test interference.

    ```bash
    # Run all integration tests
    cargo test --tests 2>&1 | tail -50
    ```

    This runs:
    - unix_tests (6 tests)
    - daemon_ipc_tests (4 tests)
    - All other integration tests

    Expected: Most tests should pass now. Focus on:
    - unix socket tests
    - daemon_ipc tests
    - Any tests that use daemon_test_helper

    Check specific test suites:
    ```bash
    cargo test test_unix_socket -- --test-threads=4 2>&1
    cargo test test_daemon -- --test-threads=4 2>&1
    ```

    If there are still failures, identify if they're:
    1. Related to socket conflicts (need more fixes)
    2. Related to test logic (not infrastructure)
    3. Expected failures (documented limitations)
  </action>
  <verify>
    - All Unix socket tests pass
    - All daemon_ipc_tests pass
    - No socket conflict errors across test suite
  </verify>
  <done>
    Integration test suite passes without socket conflicts.
  </done>
</task>

<task type="auto">
  <name>Task 6: Commit changes and create SUMMARY</name>
  <files>
    tests/fixtures/daemon_test_helper.rs
    .planning/phases/25-cross-platform-test-validation/25-07-SUMMARY.md
  </files>
  <action>
    Commit the changes:
    1. Stage tests/fixtures/daemon_test_helper.rs
    2. Commit: "fix(25-07): fix daemon test socket paths and startup timing"
    
    Create SUMMARY.md documenting:
    - Unique socket path generation
    - Active socket readiness waiting
    - Test results after fixes
  </action>
  <verify>
    - Git log shows commit with message pattern "fix(25-07):"
    - SUMMARY.md exists in phase directory
  </verify>
  <done>
    Changes committed and SUMMARY.md created.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:
1. All 4 daemon_ipc_tests pass
2. All Unix socket tests pass
3. No "No such file or directory" socket errors
4. No socket path conflicts between tests
5. Tests pass when run in parallel
</verification>

<success_criteria>
- [ ] Daemon socket paths use unique counter
- [ ] spawn_test_daemon waits for socket to exist
- [ ] All daemon_ipc_tests pass (4/4)
- [ ] All Unix socket tests pass (6/6)
- [ ] No socket not found errors
- [ ] Tests pass when run together
</success_criteria>

<output>
After completion, create `.planning/phases/25-cross-platform-test-validation/25-07-SUMMARY.md`
</output>
