---
phase: 25-cross-platform-test-validation
plan: 03
type: execute
wave: 1
depends_on:
  - 25-01
  - 25-02
files_modified:
  - src/ipc/mod.rs
  - src/daemon/mod.rs
  - src/lib.rs
  - tests/common/mod.rs
  - tests/helpers.rs
  - tests/unix/tests.rs
  - tests/ipc_tests.rs
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "create_ipc_server() no longer uses Handle::block_on()"
    - "create_ipc_server() is now async and can be awaited"
    - "All callers of create_ipc_server() use .await"
    - "5 failing Unix tests now pass"
    - "cross_platform_daemon_tests: 9/9 pass (was 4/9)"
  artifacts:
    - path: "src/ipc/mod.rs"
      provides: "Async create_ipc_server function"
      pattern: "pub async fn create_ipc_server"
    - path: "src/daemon/mod.rs"
      provides: "Daemon awaits IPC server creation"
      pattern: "create_ipc_server.*.await"
    - path: "tests/unix/tests.rs"
      provides: "Fixed Unix socket tests"
      status: "all pass"
  key_links:
    - from: "tests/unix/tests.rs"
      to: "src/ipc/mod.rs::create_ipc_server"
      via: "async/await call"
      pattern: "create_ipc_server.*.await"
---

<objective>
Fix the critical runtime nesting bug in `create_ipc_server()` that causes test failures.

**Purpose:** The `create_ipc_server()` function uses `Handle::block_on()` which fails when called from async test contexts. This causes 5 integration tests to fail with "Cannot start a runtime from within a runtime" errors.

**Gap being closed:**
- VERIFICATION.md Gap 1: Integration test failures due to block_on usage
- VERIFICATION.md Gap 3: Misleading documentation claiming this was "test infrastructure"

**Root cause:** Line 265 of `src/ipc/mod.rs` uses `Handle::block_on()` to call an async constructor from a sync function. This is an anti-pattern that breaks when the caller is already in an async context.

**Solution:** Make `create_ipc_server()` async and update all callers to use `.await`.

**Output:**
- Async `create_ipc_server()` function
- All callers updated to await
- 5 previously failing tests now pass
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/25-cross-platform-test-validation/25-VERIFICATION.md

## The Bug (from VERIFICATION.md)

**Location:** `src/ipc/mod.rs:265`

**Current code:**
```rust
#[cfg(unix)]
pub fn create_ipc_server(path: &Path) -> Result<Box<dyn IpcServer>, McpError> {
    use tokio::runtime::Handle;
    
    let server = Handle::try_current()
        .map_err(|e| McpError::IpcError { ... })?
        .block_on(crate::ipc::unix::UnixIpcServer::new(path))?;  // <-- BUG
    
    Ok(Box::new(server))
}
```

**Problem:** Uses `Handle::block_on()` to bridge sync/async. When called from async test contexts (#[tokio::test]), this causes runtime nesting errors.

**Impact:** 5 tests fail in `tests/unix/tests.rs`:
- test_unix_socket_cleanup_on_removal
- test_unix_socket_client_server_roundtrip  
- test_unix_socket_large_message_transfer
- test_unix_socket_multiple_concurrent_connections
- test_unix_socket_stale_error_handling

## Affected Files

**Source files to modify:**
1. `src/ipc/mod.rs` - Make function async, remove block_on
2. `src/daemon/mod.rs` - Add .await when calling create_ipc_server
3. `src/lib.rs` - Update re-export if needed

**Test files to modify:**
4. `tests/common/mod.rs` - Add .await (line 23)
5. `tests/helpers.rs` - Add .await (lines 67, 128)
6. `tests/unix/tests.rs` - Add .await (lines 54, 118, 181, 191, 204)
7. `tests/ipc_tests.rs` - Add .await (lines 22, 86, 153)

**Note:** `tests/windows/tests.rs` uses the same function but has its own cfg(windows) implementation. Check if it needs similar fixes.

## Solution Approach

**Option A (Chosen):** Make create_ipc_server async
- Clean, idiomatic Rust async
- All callers are already in async contexts
- Minimal changes required

**Option B:** Use block_in_place (rejected)
- Still a workaround
- More complex
- Doesn't solve the architectural issue
</context>

<tasks>

<task type="auto">
  <name>Refactor create_ipc_server to async (Unix)</name>
  <files>src/ipc/mod.rs</files>
  <action>
Change the Unix implementation of `create_ipc_server` from sync to async.

**Current code (lines 257-268):**
```rust
#[cfg(unix)]
pub fn create_ipc_server(path: &Path) -> Result<Box<dyn IpcServer>, McpError> {
    use tokio::runtime::Handle;
    
    let server = Handle::try_current()
        .map_err(|e| McpError::IpcError {
            message: format!("No Tokio runtime available for IPC server creation: {}", e),
        })?
        .block_on(crate::ipc::unix::UnixIpcServer::new(path))?;
    
    Ok(Box::new(server))
}
```

**Change to:**
```rust
#[cfg(unix)]
pub async fn create_ipc_server(path: &Path) -> Result<Box<dyn IpcServer>, McpError> {
    let server = crate::ipc::unix::UnixIpcServer::new(path).await?;
    Ok(Box::new(server))
}
```

**Key changes:**
1. Add `async` keyword to function signature
2. Remove `use tokio::runtime::Handle` import
3. Remove `Handle::try_current()` call
4. Remove `.block_on()` call
5. Directly await `UnixIpcServer::new(path)`

**Verify:**
- Check if there's also a Windows implementation that needs similar changes
- Ensure return type changes from `Result<...>` to `impl Future<Output = Result<...>>` (async fn handles this automatically)

Run: `cargo check --lib` to verify compilation
  </action>
  <verify>cargo check --lib 2>&1 | grep -c "error\[" | grep "^0$"</verify>
  <done>create_ipc_server is now async and compiles</done>
</task>

<task type="auto">
  <name>Update daemon/mod.rs to await create_ipc_server</name>
  <files>src/daemon/mod.rs</files>
  <action>
Update the daemon to await the now-async create_ipc_server call.

**Current code (line 86):**
```rust
let ipc_server: Box<dyn IpcServer> = create_ipc_server(&socket_path)?;
```

**Change to:**
```rust
let ipc_server: Box<dyn IpcServer> = create_ipc_server(&socket_path).await?;
```

**Context:** This is inside `run_daemon()` which is already async, so adding .await is straightforward.

Run: `cargo check --lib` to verify compilation
  </action>
  <verify>cargo check --lib 2>&1 | grep -c "error\[" | grep "^0$"</verify>
  <done>Daemon awaits IPC server creation</done>
</task>

<task type="auto">
  <name>Update test files to await create_ipc_server</name>
  <files>
    tests/common/mod.rs
    tests/helpers.rs
    tests/unix/tests.rs
    tests/ipc_tests.rs
  </files>
  <action>
Update all test file callers to use .await on create_ipc_server calls.

**tests/common/mod.rs line 23:**
```rust
let server = ipc::create_ipc_server(&socket_path)?;
```
Change to:
```rust
let server = ipc::create_ipc_server(&socket_path).await?;
```

**tests/helpers.rs lines 67, 128:**
Add .await after each create_ipc_server call, before the ? operator.

**tests/unix/tests.rs lines 54, 118, 181, 191, 204:**
Add .await after each create_ipc_server call.

**tests/ipc_tests.rs lines 22, 86, 153:**
Add .await after each create_ipc_server call.

**Pattern:**
- Change: `create_ipc_server(&path)?` → `create_ipc_server(&path).await?`
- Change: `create_ipc_server(&path).expect(...)` → `create_ipc_server(&path).await.expect(...)`

**Verify:**
Run: `cargo test --test unix --no-run` to compile test
Run: `cargo test --test ipc_tests --no-run` to compile test
Run: `cargo test --test cross_platform_daemon_tests --no-run` to compile test
  </action>
  <verify>cargo test --test unix --no-run 2>&1 | grep -c "error\[" | grep "^0$"</verify>
  <done>All test files compile with async create_ipc_server</done>
</task>

<task type="auto">
  <name>Run failing tests to verify fix</name>
  <files>tests/unix/tests.rs</files>
  <action>
Run the previously failing Unix tests to verify they now pass.

**Tests to run:**
```bash
cargo test --test cross_platform_daemon_tests 2>&1 | tee /tmp/cpdt_results.txt
```

**Expected results:**
Before fix: 4 passed, 5 failed
After fix: 9 passed, 0 failed

**Specifically verify these tests pass:**
- test_unix_socket_cleanup_on_removal
- test_unix_socket_client_server_roundtrip
- test_unix_socket_large_message_transfer
- test_unix_socket_multiple_concurrent_connections
- test_unix_socket_stale_error_handling

**Full verification:**
Also run the Unix-specific tests:
```bash
cargo test --test unix 2>&1 | tee /tmp/unix_results.txt
```

Check that all tests pass without "runtime" or "block_on" errors.
  </action>
  <verify>grep "test result: ok" /tmp/cpdt_results.txt && grep "9 passed" /tmp/cpdt_results.txt</verify>
  <done>All 9 cross_platform_daemon_tests pass</done>
</task>

<task type="auto">
  <name>Verify full integration test suite</name>
  <files>.planning/REQUIREMENTS.md</files>
  <action>
Run the full integration test suite to ensure no regressions.

```bash
cargo test --lib 2>&1 | tee /tmp/lib_tests.txt
cargo test --test '*' 2>&1 | tee /tmp/integration_tests.txt
```

**Expected:**
- Library tests: 109 passed (same as before)
- Integration tests: All that should pass do pass

**Check for:**
- No runtime nesting errors
- No block_on related panics
- Tests that were passing before still pass

**Do NOT update REQUIREMENTS.md yet** - that happens in Plan 04 after we confirm all tests pass.
  </action>
  <verify>grep "test result: ok" /tmp/lib_tests.txt && grep "109 passed" /tmp/lib_tests.txt</verify>
  <done>Full test suite runs without runtime nesting errors</done>
</task>

</tasks>

<verification>
- `src/ipc/mod.rs`: create_ipc_server is async, no block_on usage
- `src/daemon/mod.rs`: Awaits create_ipc_server
- All test files: Use .await on create_ipc_server calls
- cross_platform_daemon_tests: 9/9 pass (was 4/9)
- No "runtime" or "block_on" errors in test output
</verification>

<success_criteria>
1. `create_ipc_server` function is async (has `async fn` in signature)
2. No `Handle::block_on` usage in create_ipc_server
3. All callers of create_ipc_server use .await
4. cross_platform_daemon_tests reports: 9 passed, 0 failed
5. Library tests still pass: 109 passed
6. No runtime nesting errors in any test output
</success_criteria>

<output>
After completion, create `.planning/phases/25-cross-platform-test-validation/25-03-SUMMARY.md`

Document:
- The block_on anti-pattern that was fixed
- Number of tests fixed (5 Unix tests)
- Verification that all async calls work correctly
</output>
