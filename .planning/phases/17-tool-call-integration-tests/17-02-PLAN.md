---
phase: 17-tool-call-integration-tests
plan: 02
type: execute
wave: 2
depends_on: [17-01]
files_modified:
  - tests/tool_call_stdio_tests.rs
  - tests/tool_call_error_tests.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - End-to-end stdio transport tool call test passes
    - Tool call with arguments test passes
    - Tool call error handling test passes
    - Tests spawn mock server as subprocess and verify full roundtrip
    - Error tests verify proper error propagation from mock to caller
  artifacts:
    - path: "tests/tool_call_stdio_tests.rs"
      provides: "Stdio transport tool call integration tests"
      min_lines: 120
      exports: ["test_stdio_tool_call", "test_stdio_tool_call_with_args"]
    - path: "tests/tool_call_error_tests.rs"
      provides: "Tool call error handling tests"
      min_lines: 80
      exports: ["test_tool_not_found", "test_invalid_arguments", "test_server_error"]
  key_links:
    - from: "tests/tool_call_stdio_tests.rs"
      to: "tests/fixtures/mock_mcp_server.rs"
      via: "process::Command to spawn mock"
      pattern: "Command::new.*mock-mcp-server"
    - from: "tests/tool_call_error_tests.rs"
      to: "tests/fixtures/mock_mcp_server.rs"
      via: "MOCK_ERRORS environment variable"
      pattern: "env::set_var.*MOCK_ERRORS"
---

<objective>
Add end-to-end integration tests for stdio transport tool calls (TEST-02, TEST-04, TEST-05).

Purpose: Verify that the stdio transport correctly handles tool calls from initialization through response, including argument passing and error propagation. These tests use the mock MCP server created in Plan 17-01 to provide deterministic responses.

Output: Two test files covering happy path (stdio roundtrip with arguments) and error scenarios (tool not found, invalid args, server errors).
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-tool-call-integration-tests/17-CONTEXT.md
@.planning/phases/17-tool-call-integration-tests/17-01-SUMMARY.md

@src/client/mod.rs
@src/client/stdio.rs
@src/transport.rs
@tests/helpers.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stdio transport tool call end-to-end tests</name>
  <files>tests/tool_call_stdio_tests.rs</files>
  <action>
Create comprehensive end-to-end tests for stdio transport tool calls using the mock MCP server.

Test 1: test_stdio_basic_tool_call (TEST-02)
- Purpose: Verify full roundtrip from client to mock server and back
- Setup:
  1. Spawn mock-mcp-server binary as subprocess
  2. Set MOCK_TOOLS env var with echo tool definition
  3. Set MOCK_RESPONSES with echo response: {"content": [{"type": "text", "text": "Hello"}]}
  4. Create McpClient with StdioTransport using the mock process
- Execution:
  1. Call client.initialize() - verify handshake completes
  2. Call client.call_tool("echo", {"message": "Hello"})
  3. Verify response contains expected result
- Verification:
  - Response status is "success"
  - Response content matches MOCK_RESPONSES configuration
  - No errors in transport or protocol handling

Test 2: test_stdio_tool_call_with_args (TEST-04)
- Purpose: Verify JSON arguments are passed correctly to mock server
- Setup:
  1. Create add tool: takes {"a": number, "b": number}
  2. Mock returns sum in response
- Execution:
  1. Call client.call_tool("add", {"a": 5, "b": 3})
  2. Verify response contains {"result": 8}
- Verification:
  - Arguments are correctly serialized to JSON-RPC params
  - Mock receives correct arguments and returns correct result
  - Complex nested arguments work correctly

Test 3: test_stdio_tools_list (integration)
- Purpose: Verify tools/list works end-to-end
- Setup:
  1. Configure mock with multiple tools (echo, add, search)
- Execution:
  1. Call client.list_tools()
  2. Verify returned tools match MOCK_TOOLS configuration
- Verification:
  - All tools returned with correct names
  - ToolInfo structs populated correctly
  - Input schemas preserved

Implementation Details:
1. Use tokio::process::Command to spawn mock server
2. Use std::env::set_var for mock configuration before spawning
3. Create StdioTransport using the child process
4. Create McpClient and test methods
5. Clean up: kill child process, remove socket files

Code Structure:
```rust
#[tokio::test]
async fn test_stdio_basic_tool_call() {
    // Set up mock environment
    std::env::set_var("MOCK_TOOLS", r#"[{"name": "echo", ...}]"#);
    std::env::set_var("MOCK_RESPONSES", r#"{"echo": {...}}"#);
    
    // Spawn mock server
    let mut child = Command::new(env!("CARGO_BIN_EXE_mock-mcp-server"))
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()
        .expect("Failed to spawn mock");
    
    // Create transport and client
    let stdin = child.stdin.take().unwrap();
    let stdout = child.stdout.take().unwrap();
    // ... create transport from handles
    
    // Test tool call
    let result = client.call_tool("echo", json!({"message": "Hello"})).await;
    assert!(result.is_ok());
    
    // Cleanup
    let _ = child.kill().await;
}
```

Reference existing patterns:
- @tests/helpers.rs for test utilities
- @tests/daemon_lifecycle_tests.rs for process spawning patterns
- @src/client/stdio.rs for StdioTransport usage
</action>
  <verify>cargo test --test tool_call_stdio_tests -- --nocapture</verify>
  <done>All stdio tool call tests pass (3 tests minimum)</done>
</task>

<task type="auto">
  <name>Task 2: Create tool call error handling tests</name>
  <files>tests/tool_call_error_tests.rs</files>
  <action>
Create comprehensive error handling tests for tool calls (TEST-05).

Test 1: test_tool_not_found_error
- Purpose: Verify graceful error when calling non-existent tool
- Setup:
  1. Configure mock with only "echo" tool
  2. Set MOCK_ERRORS to return error for "nonexistent" tool
- Execution:
  1. Call client.call_tool("nonexistent", {})
- Verification:
  - Returns Err(McpError)
  - Error message includes tool name
  - Error propagated correctly through transport

Test 2: test_invalid_arguments_error
- Purpose: Verify error handling for malformed arguments
- Setup:
  1. Configure echo tool expecting {"message": string}
  2. Set MOCK_ERRORS to simulate validation failure
- Execution:
  1. Call client.call_tool("echo", {"wrong_field": "value"})
- Verification:
  - Returns appropriate error
  - Error message is helpful (per QUAL-04)

Test 3: test_server_error_response
- Purpose: Verify handling of MCP server errors
- Setup:
  1. Configure mock to return JSON-RPC error response
  2. Set MOCK_ERRORS with error object: {"code": -32600, "message": "Invalid Request"}
- Execution:
  1. Call client.call_tool("fail", {})
- Verification:
  - Error correctly parsed from JSON-RPC response
  - Error propagated to caller
  - No panics or unwrap failures

Test 4: test_transport_error_handling
- Purpose: Verify graceful handling of transport failures
- Setup:
  1. Spawn mock server
  2. Kill mock server mid-request
- Execution:
  1. Start call_tool, kill server during execution
- Verification:
  - Returns connection error (not panic)
  - Error message indicates transport failure

Test 5: test_error_propagation_chain
- Purpose: Verify errors propagate through full stack
- Setup:
  1. Configure mock to return specific error
- Execution:
  1. Call through McpClient -> Transport -> Mock
- Verification:
  - Error at mock level reaches test
  - Error context preserved through layers
  - Appropriate error variant used

Implementation Notes:
1. Test each error scenario independently
2. Verify error types are specific (not just generic errors)
3. Check error messages are helpful for debugging
4. Ensure no panics - all errors return Result::Err
5. Document expected error behavior in comments

Error Type Coverage:
- McpError::InvalidProtocol - malformed responses
- McpError::ConnectionError - transport failures
- McpError::Timeout - slow responses
- Custom error from mock - tool-specific errors

Reference existing error patterns:
- @src/error.rs for McpError variants
- @src/client/mod.rs for error propagation
- @tests/orphan_cleanup_tests.rs for error handling patterns
</action>
  <verify>cargo test --test tool_call_error_tests -- --nocapture</verify>
  <done>All error handling tests pass (5 tests minimum)</done>
</task>

</tasks>

<verification>
After completing this plan:
1. Stdio tests compile: cargo test --test tool_call_stdio_tests --no-run
2. Error tests compile: cargo test --test tool_call_error_tests --no-run
3. All tests pass: cargo test --test tool_call_stdio_tests --test tool_call_error_tests
4. Tests verify protocol handshake completes
5. Tests verify arguments are passed correctly
6. Tests verify errors propagate properly
</verification>

<success_criteria>
Observable behaviors that indicate success:
- [ ] tests/tool_call_stdio_tests.rs exists with 3+ tests
- [ ] tests/tool_call_error_tests.rs exists with 5+ tests
- [ ] All stdio transport tests pass
- [ ] All error handling tests pass
- [ ] Tests spawn mock server as subprocess
- [ ] Tests verify full MCP protocol roundtrip
- [ ] Error tests verify proper error propagation
</success_criteria>

<output>
After completion, create `.planning/phases/17-tool-call-integration-tests/17-02-SUMMARY.md`
</output>
