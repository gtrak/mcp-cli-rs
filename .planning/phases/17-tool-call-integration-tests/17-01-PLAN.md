---
phase: 17-tool-call-integration-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/fixtures/mock_mcp_server.rs
  - tests/fixtures/mock_http_server.rs
  - tests/fixtures/mod.rs
  - Cargo.toml
autonomous: true
user_setup: []

must_haves:
  truths:
    - Mock MCP server exists as a test fixture binary
    - Mock server implements full MCP protocol handshake (initialize, notifications/initialized)
    - Mock server supports tools/list and tools/call methods
    - Mock HTTP server provides same MCP protocol over HTTP transport
    - Mock servers can be configured to return different responses per test
  artifacts:
    - path: "tests/fixtures/mock_mcp_server.rs"
      provides: "Stdio mock MCP server binary"
      min_lines: 150
    - path: "tests/fixtures/mock_http_server.rs"
      provides: "HTTP mock MCP server"
      min_lines: 120
    - path: "tests/fixtures/mod.rs"
      provides: "Fixture exports and shared types"
      exports: ["MockServerConfig", "start_mock_stdio", "start_mock_http"]
    - path: "tests/fixtures/"
      provides: "Directory with JSON test fixtures"
  key_links:
    - from: "tests/fixtures/mock_mcp_server.rs"
      to: "tests/fixtures/"
      via: "bin target in Cargo.toml"
      pattern: "\[\[bin\]\]"
    - from: "mock_mcp_server"
      to: "MCP protocol"
      via: "JSON-RPC request/response handling"
      pattern: "jsonrpc.*2\.0"
---

<objective>
Create mock MCP servers for testing tool execution across both stdio and HTTP transports.

Purpose: Integration tests need deterministic MCP servers that can be configured to return specific responses for happy path and error scenarios. These mocks implement the full MCP protocol initialization handshake and support tools/list, tools/call, and ping methods.

Output: Mock server binaries (stdio mock as bin target, HTTP mock as test helper), shared configuration types, and JSON fixture files for test data.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-tool-call-integration-tests/17-CONTEXT.md

@src/client/mod.rs
@src/client/stdio.rs
@src/client/http.rs
@tests/helpers.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create mock MCP stdio server binary</name>
  <files>tests/fixtures/mock_mcp_server.rs, Cargo.toml</files>
  <action>
Create a mock MCP server that communicates via stdio (stdin/stdout) for testing tool calls. This binary implements the full MCP protocol:

1. MCP Protocol Handshake:
   - Accept initialize request with protocolVersion "2024-11-05"
   - Return initialize response with server capabilities
   - Accept notifications/initialized notification
   - Send notifications/initialized to client

2. Method Support:
   - tools/list: Returns configurable list of ToolInfo objects
   - tools/call: Accepts tool name and arguments, returns configurable result
   - ping: Returns pong response for health checks

3. Response Configuration:
   - Support environment variable MOCK_TOOLS to define available tools (JSON array)
   - Support MOCK_RESPONSES to define tool call responses (JSON object mapping tool_name → response)
   - Support MOCK_ERRORS to simulate error responses (JSON object mapping tool_name → error)

4. Implementation Notes:
   - Read newline-delimited JSON from stdin
   - Write newline-delimited JSON to stdout
   - Parse jsonrpc field to validate JSON-RPC 2.0
   - Match on method field to route requests
   - Use tokio for async I/O (like real stdio transport)
   - Exit cleanly when stdin closes or receives exit signal

5. Cargo.toml:
   - Add bin target: [[bin]] name = "mock-mcp-server" path = "tests/fixtures/mock_mcp_server.rs"

6. Example tool definition:
   ```json
   {
     "name": "echo",
     "description": "Echo back the input",
     "input_schema": {
       "type": "object",
       "properties": {
         "message": {"type": "string"}
       }
     }
   }
   ```

Test the binary compiles and runs: cargo build --bin mock-mcp-server
</action>
  <verify>cargo build --bin mock-mcp-server</verify>
  <done>Mock MCP stdio server binary compiles and can be spawned as subprocess</done>
</task>

<task type="auto">
  <name>Task 2: Create mock MCP HTTP server helper</name>
  <files>tests/fixtures/mock_http_server.rs</files>
  <action>
Create an in-process HTTP mock MCP server for testing HTTP transport tool calls. Unlike the stdio mock (which is a binary), this runs in-process during tests.

1. HTTP Server Implementation:
   - Use tokio::net::TcpListener to accept connections
   - Use hyper or lightweight HTTP server (reqwest already in deps)
   - Accept POST requests at configurable endpoint (default: /mcp)
   - Parse JSON-RPC body from HTTP request
   - Return JSON-RPC response in HTTP response body

2. MCP Protocol Support:
   - Same method support as stdio mock: initialize, tools/list, tools/call, ping
   - Same configuration via environment variables (MOCK_TOOLS, MOCK_RESPONSES, MOCK_ERRORS)
   - HTTP-specific: Return proper HTTP status codes (200 for success, 500 for MCP errors)

3. Test Helper API:
   ```rust
   pub struct MockHttpServer {
       addr: SocketAddr,
       shutdown: tokio::sync::oneshot::Sender<()>,
   }
   
   impl MockHttpServer {
       pub async fn start() -> (Self, String) // Returns server and URL
       pub fn url(&self) -> String
       pub async fn shutdown(self)
   }
   ```

4. Implementation Notes:
   - Spawn HTTP server in background task
   - Return shutdown channel for clean termination
   - Bind to localhost with random port (let OS assign: 127.0.0.1:0)
   - Support Content-Type: application/json header
   - Handle malformed JSON with 400 Bad Request

5. Example usage in test:
   ```rust
   let (server, url) = MockHttpServer::start().await;
   // Use url in HTTP transport config
   server.shutdown().await;
   ```
</action>
  <verify>cargo check --tests</verify>
  <done>Mock HTTP server helper compiles and can be started/stopped in tests</done>
</task>

<task type="auto">
  <name>Task 3: Create shared fixture types and module exports</name>
  <files>tests/fixtures/mod.rs, tests/fixtures/test_tools.json, tests/fixtures/test_responses.json</files>
  <action>
Create the fixtures module with shared types and JSON test fixtures.

1. Module Structure (tests/fixtures/mod.rs):
   - Re-export mock_http_server types
   - Define shared types: ToolDefinition, MockResponse, MockError
   - Helper functions: load_test_tools(), load_test_responses()
   - Platform-aware paths for test data

2. Shared Types:
   ```rust
   #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
   pub struct ToolDefinition {
       pub name: String,
       pub description: String,
       pub input_schema: serde_json::Value,
   }
   
   #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
   pub struct MockResponse {
       pub content: Vec<serde_json::Value>,
   }
   ```

3. JSON Fixture Files:
   - tests/fixtures/tools/simple.json: Basic tool definitions
   - tests/fixtures/responses/echo.json: Echo tool response
   - tests/fixtures/responses/error.json: Error response example

4. Helper Functions:
   - pub fn get_fixture_path(name: &str) -> PathBuf
   - pub fn load_test_tools() -> Vec<ToolDefinition>
   - pub fn set_mock_env(tools: &[ToolDefinition], responses: &HashMap<String, MockResponse>)

5. Module Organization:
   ```rust
   // tests/fixtures/mod.rs
   pub mod mock_http_server;
   
   use std::path::PathBuf;
   // ... shared types and helpers
   ```

6. Implementation Notes:
   - Use CARGO_MANIFEST_DIR to locate fixtures
   - Provide default test tools (echo, add, fail)
   - Support environment variable injection for mock configuration
</action>
  <verify>cargo check --tests</verify>
  <done>Fixtures module exports types, mock HTTP server, and JSON fixtures exist</done>
</task>

</tasks>

<verification>
After completing this plan:
1. Mock stdio server compiles: cargo build --bin mock-mcp-server
2. Mock HTTP server helper compiles: cargo check --tests
3. Fixtures module compiles: cargo check --tests
4. All mock implementations support MCP protocol handshake
5. Mock servers can return configurable tool responses
</verification>

<success_criteria>
Observable behaviors that indicate success:
- [ ] tests/fixtures/mock_mcp_server.rs exists and compiles as binary
- [ ] tests/fixtures/mock_http_server.rs provides MockHttpServer struct
- [ ] tests/fixtures/mod.rs exports shared types and helpers
- [ ] tests/fixtures/*.json files exist with sample data
- [ ] Mock stdio server handles initialize/tools/list/tools/call
- [ ] Mock HTTP server handles same methods over HTTP POST
</success_criteria>

<output>
After completion, create `.planning/phases/17-tool-call-integration-tests/17-01-SUMMARY.md`
</output>
