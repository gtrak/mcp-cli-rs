---
phase: 17-tool-call-integration-tests
plan: 03
type: execute
wave: 2
depends_on: [17-01]
files_modified:
  - tests/tool_call_http_tests.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - HTTP transport tool call test passes
    - HTTP test uses in-process mock server (not subprocess)
    - Test verifies full roundtrip through HTTP transport
    - Test verifies same functionality as stdio tests via HTTP
  artifacts:
    - path: "tests/tool_call_http_tests.rs"
      provides: "HTTP transport tool call integration tests"
      min_lines: 100
      exports: ["test_http_tool_call", "test_http_initialize", "test_http_tools_list"]
  key_links:
    - from: "tests/tool_call_http_tests.rs"
      to: "tests/fixtures/mock_http_server.rs"
      via: "MockHttpServer::start()"
      pattern: "MockHttpServer::start"
    - from: "tests/tool_call_http_tests.rs"
      to: "src/client/http.rs"
      via: "HttpTransport::new()"
      pattern: "HttpTransport::new"
---

<objective>
Add end-to-end integration test for HTTP transport tool calls (TEST-03).

Purpose: Verify that the HTTP transport correctly handles tool calls over HTTP POST requests. This test uses the in-process mock HTTP server from Plan 17-01 to provide deterministic responses, allowing tests to run without external network dependencies.

Output: Test file covering HTTP transport tool calls with same scenarios as stdio tests for consistency.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-tool-call-integration-tests/17-CONTEXT.md
@.planning/phases/17-tool-call-integration-tests/17-01-SUMMARY.md
@.planning/phases/17-tool-call-integration-tests/17-02-SUMMARY.md

@src/client/mod.rs
@src/client/http.rs
@src/transport.rs
@tests/fixtures/mock_http_server.rs
@tests/helpers.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create HTTP transport tool call integration tests</name>
  <files>tests/tool_call_http_tests.rs</files>
  <action>
Create comprehensive integration tests for HTTP transport tool calls using the in-process mock HTTP server.

Test 1: test_http_basic_tool_call (TEST-03)
- Purpose: Verify HTTP transport can call tools via POST requests
- Setup:
  1. Start MockHttpServer (in-process)
  2. Configure mock with echo tool
  3. Create HttpTransport with mock URL
  4. Create McpClient with HTTP transport
- Execution:
  1. Call client.initialize() - sends initialize POST
  2. Call client.call_tool("echo", {"message": "Hello"})
  3. Verify HTTP request/response flow
- Verification:
  - HTTP POST sent to correct endpoint
  - Content-Type: application/json header present
  - Response correctly parsed from HTTP body
  - Result matches expected mock response

Test 2: test_http_tool_call_with_args (mirrors TEST-04 for HTTP)
- Purpose: Verify arguments serialized correctly over HTTP
- Setup:
  1. Start mock with add tool
  2. Configure add tool response
- Execution:
  1. Call client.call_tool("add", {"a": 10, "b": 20})
- Verification:
  - Request body contains correct JSON-RPC with params
  - Arguments preserved in serialization
  - Response parsed correctly

Test 3: test_http_tools_list
- Purpose: Verify tools/list works over HTTP
- Setup:
  1. Configure mock with multiple tools
- Execution:
  1. Call client.list_tools()
- Verification:
  - POST /mcp with tools/list method
  - Response contains all configured tools
  - ToolInfo structs correctly populated

Test 4: test_http_initialize_handshake
- Purpose: Verify MCP protocol initialization over HTTP
- Setup:
  1. Start mock server
- Execution:
  1. Call client.initialize()
- Verification:
  - Initialize request sent as JSON-RPC POST
  - Response contains protocolVersion and capabilities
  - Client ready state set correctly

Test 5: test_http_transport_error_handling
- Purpose: Verify HTTP transport error scenarios
- Setup:
  1. Configure mock to return HTTP 500
  2. Test connection refused (wrong port)
- Execution:
  1. Call tool with error configuration
  2. Verify graceful error handling
- Verification:
  - Returns McpError::ConnectionError for HTTP errors
  - Returns McpError::InvalidProtocol for malformed JSON
  - No panics

Test 6: test_http_headers_passthrough
- Purpose: Verify custom headers are sent with requests
- Setup:
  1. Create HttpTransport with custom headers
  2. Start mock that validates headers
- Execution:
  1. Call initialize with headers
- Verification:
  - Custom headers present in HTTP request
  - Authorization header handled correctly

Implementation Details:

1. Mock HTTP Server Setup:
```rust
async fn with_mock_server<F, Fut>(test: F)
where
    F: FnOnce(String) -> Fut,
    Fut: Future<Output = ()>,
{
    let (server, url) = MockHttpServer::start().await;
    test(url).await;
    server.shutdown().await;
}
```

2. HTTP Transport Creation:
```rust
let transport = HttpTransport::new(&url, HashMap::new());
let mut client = McpClient::new("test-server".to_string(), Box::new(transport));
```

3. Test Structure:
```rust
#[tokio::test]
async fn test_http_basic_tool_call() {
    with_mock_server(|url| async move {
        // Configure mock environment
        std::env::set_var("MOCK_TOOLS", ...);
        
        // Create HTTP transport
        let transport = HttpTransport::new(&url, HashMap::new());
        let mut client = McpClient::new("test".to_string(), Box::new(transport));
        
        // Test
        client.initialize().await.unwrap();
        let result = client.call_tool("echo", json!({})).await.unwrap();
        
        // Verify
        assert!(result["content"].is_array());
    }).await;
}
```

4. HTTP-Specific Considerations:
   - Unlike stdio (line-based), HTTP uses full request/response bodies
   - HTTP transport doesn't support notifications (returns error)
   - HTTP transport uses reqwest client (already in Cargo.toml)
   - Tests should verify Content-Type headers
   - Tests should verify HTTP status code handling

5. Error Scenarios to Cover:
   - Connection refused (wrong URL)
   - HTTP 404 (wrong endpoint)
   - HTTP 500 (server error)
   - Timeout (slow response)
   - Malformed JSON in response

6. Shared Test Data:
   - Use same tool definitions as stdio tests
   - Use same response fixtures
   - Ensure consistency across transport types

Reference existing patterns:
- @src/client/http.rs for HttpTransport implementation
- @tests/fixtures/mock_http_server.rs for mock setup
- @tests/tool_call_stdio_tests.rs for test structure patterns
- @tests/json_output_tests.rs for HTTP-related test patterns
</action>
  <verify>cargo test --test tool_call_http_tests -- --nocapture</verify>
  <done>All HTTP transport tests pass (6 tests minimum)</done>
</task>

</tasks>

<verification>
After completing this plan:
1. HTTP tests compile: cargo test --test tool_call_http_tests --no-run
2. All tests pass: cargo test --test tool_call_http_tests
3. Tests verify HTTP POST requests sent correctly
4. Tests verify JSON-RPC bodies formatted correctly
5. Tests verify responses parsed from HTTP bodies
6. Mock HTTP server starts/stops cleanly
7. No orphaned server processes remain
</verification>

<success_criteria>
Observable behaviors that indicate success:
- [ ] tests/tool_call_http_tests.rs exists with 6+ tests
- [ ] All HTTP transport tests pass
- [ ] Tests use MockHttpServer from fixtures module
- [ ] Tests verify HTTP POST with JSON-RPC body
- [ ] Tests verify Content-Type headers
- [ ] Tests verify HTTP status code handling
- [ ] Mock server cleans up after each test
- [ ] Tests cover same scenarios as stdio tests
</success_criteria>

<output>
After completion, create `.planning/phases/17-tool-call-integration-tests/17-03-SUMMARY.md`
</output>
